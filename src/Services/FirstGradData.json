{
  "w1":{
    "id":"08f36e18",
    "theme":"w",
    "question":"Что такое прогрессивный рендеринг?",
    "answer":"Обобщенное название технологии, которое используется для ускорения отрисовки web-страниц. Основная идея - это как можно раньше указать пользователю визуальный контент. Основная задача - уменьшение времени загрузки.\nК технологиям прогрессивного рендеринга можно отнести: \n\n\t1.Линейную загрузку картинок. При отрисовке страницы отображаются только те картинки, которые находятся в видимой области экрана;\n\n\t 2.Приоритизация видимого контента. При этом подходе минимизируют и инкапсулируют стили, разметку и скрипты для той части страницы, которую пользователь увидит первой. Для реализации можно использовать события DOMContentLoaded и load, либо применять отложенные скрипты, чтобы догрузить остальные ресурсы.\n\n\t3.Асинхронные фрагменты HTML. Идея похожа на SSR (Server Side Rendering). В браузер отправляются HTML страницы, созданные на backend.",
    "codeexample":"",
    "images":[]
  },
  "w2":{
    "id":"08f36e19",
    "theme":"w",
    "question":"Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?",
    "answer":"Адаптивный (adaptive) и отзывчивый (responsive) дизайн — это два подхода к созданию веб-сайтов и приложений, которые могут эффективно работать на устройствах с разными размерами экранов. Несмотря на то, что оба подхода имеют одну цель — улучшить пользовательский опыт на различных устройствах, они достигают этой цели по-разному. \n\nАдаптивный дизайн (Adaptive Design). \n\tСтруктура: В адаптивном дизайне создаются несколько фиксированных макетов для различных размеров экранов. Например, один макет для мобильных устройств, другой для планшетов, третий для десктопов. \n\tКак работает: Когда пользователь открывает сайт, адаптивный дизайн определяет размер экрана и загружает соответствующий макет. \n\tГибкость: Адаптивный дизайн менее гибок, поскольку макеты создаются заранее и адаптируются только к определённым размерам экранов. \n\tЧаще используется в проектах, где требуется более точный контроль над отображением контента на различных устройствах. \n\nОтзывчивый дизайн (Responsive Design) \n\n\tСтруктура: В отзывчивом дизайне используется единый гибкий макет, который адаптируется к любому размеру экрана. Это достигается с помощью медиа-запросов, гибких сеток (flexbox, grid) и относительных единиц измерения (проценты, em, rem). \n\n\tКак работает: Макет автоматически подстраивается под размер экрана в реальном времени, меняя свою структуру и элементы в зависимости от доступного пространства. \n\n\tГибкость: Отзывчивый дизайн более гибок, так как он не ограничивается фиксированными макетами и плавно адаптируется к любому экрану.",
    "codeexample":"",
    "images":[]
  },
  "w3":{
    "id":"08f36e20",
    "theme":"w",
    "question":"Разница между Progressive Enhancement и Graceful Degradation?",
    "answer":"Оба подхода используются для создания кросс-платформенных и кросс-браузерных интерфейсов. Progressive Enhancement предполагает создание веб-интерфейса от простого к сложному (как вариант сначала создание приложения на мобильном устройстве, потом под планшет, потом десктоп). Graceful Degradation это создание в обратном порядке - от наиболее сложного к более простому (от десктопа к мобильному, или от более современных браузеров к более слабым)",
    "codeexample":"",
    "images":[]
  },
  "w15":{
    "id":"08f36e21",
    "theme":"w",
    "question":"Что такое кроссбраузерность?",
    "answer":"Это корректная адаптивная верстка для правильного отображения сайта в разных браузерах и на разных устройствах.",
    "codeexample":"",
    "images":[]
  },
  "w16":{
    "id":"08f36e22",
    "theme":"w",
    "question":"Что такое Babel? Для чего он используется?",
    "answer":"Babel - это транспайлер, который переписывает код современного стандарта JavaScript на более поздний. Транспайлер - это программа позволяющая менять исходный код одной программы на эквивалентный исходный код на другом языке. Обычно Babel работает на сервере в составе системы сборки JS-кода, например, Webpack. Основная идея использования  Babel, в том, что Ecma International каждый год выпускает обновление для  JavaScript. Однако эти обновления в браузер внедряются  постепенно, чтобы не терять время, а сразу начать использовать новый функционал, который зачастую упрощают разработку используются Babel, которая осуществлять траспиляцию новых конструкций в старые варианты для лучше кроссбраузерности. Конфигураци Babel прописывается в файле babel.config, либо .babelrc для настроек одного пакета, а также указывается в package.json.",
    "codeexample":"",
    "images":[]
  },
  "w17":{
    "id":"08f36e23",
    "theme":"w",
    "question":"Разница между feature detection, feature inference и анализом строки user-agent?",
    "answer":"Все три подхода обозначены для определения браузерных возможностей пользователя. Feature detection или определения возможностей браузера заключается в определении поддерживает ли браузер определенный блок кода и если блок не поддерживается, то будет выполнен аналог или полифил. Такой подход помогает обеспечить работоспособность и предотвратить сбои и ошибки. Пример такого подхода - это библиотека Modernizr. Feature inference или определение возможностей - это проверка на наличие определенных возможностей. Подход примеряет функцию, которая предполагает, что определенная возможность уже существует. User-agent - это строка сообщаемая браузером, которая позволяет определить тип приложения, операционную систему, поставщика программного обеспечения. Доступ к ней можно получить через navigator.userAgent. Следует отметить, что два последних подхода не рекомендовано использовать, так как самым надежным является feature detection.",
    "codeexample":"//Feature detection \nif('geolocation' in navigator) {\n//use navigator.geolocation\n} else {\n//another code\n}\n\n//Feature inference\nif (document.getElementsByTagName) {\nelement = document.getElementById(id);\n}\n\n// User Agent\nconsole.log(navigator.userAgent);\n \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebkit/537.36 (KHTML, like Geco) Chrome/91.0.4472.106 Safari/537.36\"",
    "images":[]
  },
  "w4":{
    "id":"08f36e24",
    "theme":"w",
    "question":"Разница между layout, painting и compositing?",
    "answer":"Все три этапа относятся к отрисовке веб-страницы. \n\nLayout или раскладка - это расчет места для объекта на основе css правил. Painting или отрисовка - это рисование пикселей для отображения визуальных элементов. \n\nСompositing или композиция - это отрисовка слоев в определенном порядке, то есть правильное наложение.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/sfj3yg7g03kmgxp8hb4mt/The-construction-process-of-render-tree.webp?rlkey=pog0sjguxzo6n55rug647rbm2&st=47qbop9z&dl=1"]
  },
  "w5":{
    "id":"08f36e25",
    "theme":"w",
    "question":"Что такое безопасные (Secure) и HttpOnly cookies?",
    "answer":"Безопасные куки отсылаются на сервер только если запросы выполняется по протоколу SSL и HTTPS, однако важные данные никогда не следует передавать или хранить в cookies, поскольку сам их механизм весьма уязвим в отношении безопасности по flag secure никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с 52 версии в Chrome и FireFox не защищённые сайты с протоколом http не могут создавать куки с флагом secure. Куки HTTP Only недоступны из javascrip через свойство document.cookie и через xml http request, а также request API, что помогает избежать межсайтового скриптинга или XSS. Устанавливать этот флаг можно для тех cookie к которым не требуется обращаться через javascrip в частности если куки используются только для поддержки сеанса то в javascrip они не нужны. Так что в этом случае следует устанавливать флаг http only.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/uxb0e6gcs84n00yllwzzc/1-16.webp?rlkey=2xdl228rnfm40nwv7agfx0tb0&st=9dife3ur&dl=1"]
  },
  "w6":{
    "id":"08f36e26",
    "theme":"w",
    "question":"Что такое Content Security Policy (CSP)?",
    "answer":"CSP - политика безопасности контента. CSP - это http header который позволяет операторам сайта детально контролировать откуда могут быть загружены ресурсы на их сайт. Использование данного заголовка - это лучший способ предотвратить уязвимость межсайтового скриптинга или xss и атаки внедрения данных. CSP является обязательным для всех новых веб-сайтов и настоятельно рекомендуется для всех существующих сайтов с высоким уровнем риска. В случае, если сайт не предоставляет CSP заголовки браузер в свою очередь будет использовать стандартные правила по ограничению домена. Настройка CSP включает в себя добавление на страницу http-заголовка Content Security Policy и его настройку в соответствии со списком доверенных источников из которых пользователь может получать контент.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/4mmwcehunr2v2iqpzap6o/content-security-policy.webp?rlkey=iitfy6jnymgtzlnbovsjqxpq7&st=kud302e2&dl=1"]
  },
  "w7":{
    "id":"08f36e27",
    "theme":"w",
    "question":"Что такое межсайтовый скриптинг (XSS)?",
    "answer":"Межсайтовый скриптинг или XSS - это довольно распространённая уязвимость которую можно обнаружить на множестве web приложений. Суть довольно проста: злоумышленнику удаётся внедрить на страницу JS код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда пользователи будут заходить на страницу приложения, куда этот код был добавлен. Страница, предоставляемая сервером, когда кто-то её запрашивает при этом не изменяется, вместо этого XSS атака использует уязвимость на странице, которая включает переменную отправленную в запрос для отображения в необработанном виде в ответе. Специфика подобных атак заключается в том, что вредоносный код может использовать авторизацию пользователя в веб-системе для получения к ней расширенного доступа или для получения авторизационных данных пользователя.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/nsw1qshz6vu1i1mqfxja7/91d2b78d5464ef6a6e6cb.gif?rlkey=y7jim44zj2co7dhlt04osdy43&st=wl3fjw6d&dl=1"]
  },
  "w8":{
    "id":"08f36e28",
    "theme":"w",
    "question":"Что Такое API?",
    "answer":"API (Application programming interface) - это интерфейс для взаимодействия между различными программными компонентами. API предоставляет набор функций и протоколов, которые позволяют приложениям общаться друг с другом. Проще говоря, API позволяет одному приложению запрашивать и манипулировать данными или функциями другого приложения или сервиса, что облегчает интеграцию и расширение функциональности без необходимости глубокого понимания внутренней логики других приложений. API часто используется для выполнения базовых операций с данными — создания (Create), чтения (Read), обновления (Update) и удаления (Delete) данных (CRUD-операции). Эти операции реализуются через HTTP-запросы, такие как POST, GET, PUT и DELETE, направленные на определенные URL-адреса.",
    "codeexample":"",
    "images":[]
  },
  "w9":{
    "id":"08f36e29",
    "theme":"w",
    "question":"Что такое CDN?",
    "answer":"CDN (Content delivery network) - это сеть распределенных серверов, которые совместно работают для обеспечения быстрой и надежной доставки контента пользователям. Серверы в CDN расположены в различных географических точках по всему миру и содержат копии статических ресурсов, таких как изображения, видео, стили, скрипты и другие данные. Когда пользователь запрашивает ресурс, CDN перенаправляет запрос на ближайший сервер к пользователю. Это минимизирует задержку и ускоряет время загрузки страницы. Децентрализованная структура позволяет избежать перегрузок и снижает риски отказа в случае выхода из строя одного из серверов.",
    "codeexample":"",
    "images":[]
  },
  "w10":{
    "id":"08f36e30",
    "theme":"w",
    "question":"Что такое REST?",
    "answer":"REpresentational State Transfer то есть передача состояния представления - это архитектурный стиль взаимодействия компонентов распределённого приложения. В сети rest представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиасистемы. В определённых случаях, такие как например интернет-магазины, поисковые системы и прочие системы, основанные на данных, это приводит к повышению производительности и упрощению архитектуры. В общем случае rest является очень простым интерфейсом управления информацией без использования каких-то дополнительных внутренних прослоек. Каждая единица информации однозначно определяется глобальным идентификатором таким как URL, а каждый URL свою очередь имеет строго заданный формат. ",
    "codeexample":"",
    "images":[]
  },
  "w18":{
    "id":"08f36e31",
    "theme":"w",
    "question":"Почему очищать кэш важно? Как это можно сделать?",
    "answer":"У каждого браузера есть кэш для временного хранения файлов на веб сайтах. Именно поэтому их не нужно повторно загружать при переключении между страницами или перезагрузки 1 и той же страницы.\nСервер настроен на отправку заголовков, которые сообщают браузеру о необходимости хранить файл в течении заданного периода времени. Поэтому при повторном открытии страницы часть файлов загружается из кэша- это значительно увеличивает скорость веб сайта и сохраняет пропускную способность.\nОднако в то же время это может вызвать проблемы. Например, когда веб сайт был изменен или обновлен в процессе разработки, поскольку кэш пользователя все еще ссылается на старые файлы это может либо оставить их со старой функциональностью, либо сломать веб сайт- если кэшированные файлы CSS и JavaScript ссылаются на элементы, которые больше не существуют, либо они перемещены/переименованы.\nПоэтому при деплое новой порции обновлений имеет смысл чистить кэш.\nОчистка кэша - это процесс при котором браузер загружает новые файлы это делается путем присваивания файлу имени, отличного от старого файла. Обычный способ заставить браузер повторно загрузить файл- это просто добавить строку запроса в конец файла. Например, сделать версионирование и в конце имени файла указать новое число. Браузер считать его другим файлом и загружает.",
    "codeexample":"",
    "images":[]
  },
  "w11":{
    "id":"08f36e32",
    "theme":"w",
    "question":"Назовите критические этапы рендеринга?",
    "answer":"Критические этапы рендеринга или critical rendering pass - это последовательность шагов, которую выполняет браузер, когда HTML, CSS и JavaScript преобразуются в пиксели, которые видны на экране. Самый полный и последовательный список основных шагов выглядит следующим образом: Document Object Model - ответ в виде HTML превращается в токены, которые в свою очередь превращаются в узлы и в последующем формируют DOM дерево. Css Object Mode или CSSOM: если html документ содержит стили, то припасинге они запрашиваются и участвуют в построении CSSOM, который содержит все стили страницы, то есть данные о том, как стилизовать DOM.  JavaScript - если html-документ содержит тег script, то происходит либо исполнение этого скрипта, либо запрос и исполнение сторонних подключенных скриптов. JavaScript в свою очередь может модифицировать DOM дерево. Следующий шаг - это Accessibility Tree при парсинге HTML анализируются специальное атрибуты по типу roll и area, в результате чего происходит построение так называемого дерева доступности, которое в последующем может использоваться скринридерами. Render Tree: на данном этапе происходит объединение DOM и CSSOM или объектной модели документа и ассоциированных стилей каждого элемента. Для построения дерева рендера браузер проверяет каждый узел DOM, начиная от корневого, и определяет, какие CSS правила нужно присоединить к этому узлу. Дерево рендера охватывает только видимое содержимое. Layout/Reflow - в тот момент, когда дерево рендера построено, становится возможным этап компоновки или layout. Этот этап определяет, где и как на странице будут позиционированы элементы, и каковы связи между элементами. Другими словами на основании размеров элемента определяется его положение. Первый шаг, как уже было сказано, называется layout, все последующие шаги, связанные с пересчётами размеров называются reflow. Paint/Repaint: когда дерево рендера создано, компоновка произошла, пиксели могут быть отрисованы. Если говорить просто, то на этом этапе происходит покраска веб-страницы согласно заданным стилям, первая покраска называется paint все последующие перекраски называются repaint. Compositing: заключительный шаг, когда готовые спозиционированные элементы выстраиваются друг относительно друга по уровням или потокам по умолчанию все элементы на странице идут в главном или в основном потоке, однако задание определённых CSS свойств может вырвать их из основного потока и сформировать новый. На этапе compositing элементы в разных потоках выстраиваются друг относительно друга.",
    "codeexample":"",
    "images":[]
  },
  "w12":{
    "id":"08f36e33",
    "theme":"w",
    "question":"Разница между композицией и наследованием?",
    "answer":"Наследование - это концепция ООП, когда один класс наследует поля и методы другого класса, что обеспечивает возможность повторного использования кода. Предполагает тесную взаимосвязь между компонентами: производные компоненты должны наследовать свойства базового компонента, что сильно усложняет модификацию конкретного компонента. Композиция - это ещё одна концепция ООП, но в отличии от наследования, расширяемый класс ссылается на экземпляры другого класса. Предполагает наследование поведения,а не свойств, что существенно облегчает добавление новых свойств в конкретный компонент. Компоненты по возможности должны быть переиспользуемыми. Тесная связь наследующих компонентов делает их зависимыми от специфики реализации приложения в котором они используются. Композиция делает связи между компонентами слабыми, что повышает их автономность.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/ritlrywh8nhv9glmhmwhi/tcvaa8gtnipg_ridjunpf9b1tu.gif?rlkey=aklb6yhadtjp0tn6yu9zrp6i1&st=6gvb96l6&dl=1","https://www.dropbox.com/scl/fi/ae4bawenzdrgtns3qdpfk/qjjomgocinjckd5kxjmubl1gzqc.gif?rlkey=1q1q2j81zb5atfsdw0cu59576&st=5xwptagu&dl=1"]
  },
  "w13":{
    "id":"08f36e34",
    "theme":"w",
    "question":"Какие принципы можно использовать вместе с наследованием?",
    "answer":"Есть ещё три важных принципа ООП которые можно использовать совместно с наследованием - это делегация, или поручение задачи от внешнего объекта к внутреннему, композиция- включение объектом контейнером объекта содержимого и управление его поведением, причём последний не может существовать вне первого и агрегация - включение объектом контейнером ссылки на объект содержимое при уничтожении первого последний продолжает существование.",
    "codeexample":"",
    "images":[]
  },
  "w14":{
    "id":"08f36e35",
    "theme":"w",
    "question":"Основные принципы ООП?",
    "answer":"ООП (объектно-ориентированный подход программирования) базируется на 4 основных принципах: \n\n\tАбстракция - это отделение концепции от реализации. Основная идея состоит в том, чтобы представить объект минимальным объемом полей и методов для решения поставленной задачи. \n\n\tНаследование - это способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода, т.е при наследовании класса поток получает все методы и свойства класса родителя, при условии, что данные методы и свойство не являются приватными. \n\n\tИнкапсуляция - это размещение одного объекта или класса внутри другого для разграничения доступа к ним. \n\n\tПолиморфизм - это реализация задач одной и той же идеи разными способами.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/zw6a0xw7x6cb1zwai4qii/scale_1200.webp?rlkey=463p86o2kgrw9fg7ck5y5g4dh&st=hst9ns1u&dl=1"]
  },
  "h19":{
    "id":"08f36e36",
    "theme":"h",
    "question":"Что такое HTML и для чего он нужен?",
    "answer":"Это язык гипертекстовой разметки (HyperText Markup Language). Это стандартизированный язык, позволяющий создавать веб-страницы. Он интерпретируется браузером и отображается в виде структуры и содержания на веб-странице.",
    "codeexample":"",
    "images":[]
  },
  "h20":{
    "id":"08f36e37",
    "theme":"h",
    "question":"Какие глобальные атрибуты есть в HTML?",
    "answer":"В HTML есть категория атрибутов, которые можно применять практически к любому тегу. Самый яркий пример глобального атрибута - это class, с помощью него можно осуществлять поиск или стилизацию элемента. В качестве значения он принимает строку. class может быть задан абсолютно любому тегу. contenteditable делает любой элемент на странице  редактируемым, в качестве значения для атрибута используются булевы значения true или false. data* - это группа атрибутов, позволяющая перекидывать данные между HTML и DOM часто используется для взаимодействия с HTML при помощи javascript. hidden не требует явного указания значения, наличие атрибута само по себе означает состояние true. Прячет на странице любой HTML-элемент, причём элемент не виден не только для глаз пользователя, но и для скридеров. spellcheck - с помощью этого атрибута можно указать браузеру, что в элементе, которому он задан, нужно проверить правописание. tabindex указывает браузеру нужно ли видеть этот элемент при навигации по странице с помощью клавиатуры, часто используется для не интерактивных элементов, значение - отрицательное или положительное целое число.",
    "codeexample":"",
    "images":[]
  },
  "h21":{
    "id":"08f36e38",
    "theme":"h",
    "question":"Что такое категории контента в HTML5?",
    "answer":"Каждый элемент HTML принадлежит к некоторому количеству категорий контента которые объединяют элементы с общим набором характеристик. Такая группировка является свободной, то есть на самом деле не задаёт отношения между элементами таких типов, а помогает определить и описать их поведения и правила, которым они должны следовать, особенно когда дело доходит до сложных деталейю Также возможна ситуация когда элемент не входит ни в одну из этих категорий. Существует три основных типа категорий контента - это основные категории контента описывающие общие для многих элементов правила, категории контента для элементов форм описывающие общее правило для элементов форм, особые категории контента описывающие редкие категории актуальные только для нескольких элементов, возможно лишь в особом контексте.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/tz6qgip8ve5slu25dxubi/html5_content-model.webp?rlkey=d3chhz2nwehvu5oxcx8hfujbb&st=vkvm80mq&dl=1"]
  },
  "h22":{
    "id":"08f36e39",
    "theme":"h",
    "question":"Какие категории считаются основными категориями контента?",
    "answer":"К основным категориям контента относятся: Метаданные - это элементы, принадлежащие категории метаданных. Они изменяют отображение или поведение HTML документа, связывают его с другими документами и предоставляют другую дополнительную информацию; Потоковый контент - это элементы основного потока который обычно содержит текст и встроенный контент; Секционный контент - подобные элементы создают глобальные секции в текущей структуре документа, определяющие область действия заголовочного контента и элементов header и footer; Заголовочный контент - определяет заголовок секции явно отмеченной структурным элементом или не явно самим заголовочным элементом; Фразовый контент - определяет текст и его формат серии фразового контента образуют параграфы; Встроенный контент - импортирует документ в другой ресурс или вставляет содержимое на другом языке разметки или принадлежащее другому пространству имён; Интерактивный контент - это элементы которые специально разработаны для взаимодействия с пользователем; Явный контент - это контент который считается явным, когда он не скрыт и не является пустым, это контент который непосредственно отображён на странице. У элементов потокового или фразового контента должен быть хотя бы один явный узел. Контент форм - он включает в себя элементы, владельцем которых обычно является форма или тег форм.",
    "codeexample":"",
    "images":[]
  },
  "h23":{
    "id":"08f36e40",
    "theme":"h",
    "question":"Что такое doctype? И для чего он используется?",
    "answer":"Doctype используется для указания типа документа. Добавляется он первой строкой любого html-документа, служит для того, чтобы браузер мог понять как ему интерпретировать страницу.",
    "codeexample":"",
    "images":[]
  },
  "h24":{
    "id":"08f36e41",
    "theme":"h",
    "question":"Опишите базовую структуру HTML-страницы?",
    "answer":"В самом верху обязательно идет doctype, затем идет тег html, внутри него два основных тега - head (содержит вспомогательные данные о документе, данные внутри этого тега не отрисовываются на странице), body (тег, который содержит всю разметку html-документа)",
    "codeexample":"",
    "images":[]
  },
  "h25":{
    "id":"08f36e42",
    "theme":"h",
    "question":"Что такое валидация? И какие типы проверок HTML документа вы знаете?",
    "answer":"Валидация - это проверка документа специальной программой валидатором на соответствие установленным веб-стандартам и обнаружение ошибок. Стандарты называются спецификациями, разработаны они консорциумом world wide web - W3C. Работа валидатора состоит из следующего: определяется тип документа (который указан при помощи doctype), проверяется html-код на правильность, также проверяется правильность использования тегов и их вложенность. 4 типа проверки: проверка синтаксиса, проверка вложенности, проверка dtd (Document Type Definition ), проверка на наличие посторонних элементов. ",
    "codeexample":"",
    "images":[]
  },
  "h26":{
    "id":"08f36e43",
    "theme":"h",
    "question":"Основные этапы проверок валидности HTML-документа?",
    "answer":"Валидация - это проверка документов специальной программой валидатором на соответствие установленным веб-стандартам и обнаружения существующих ошибок. Валидным считается документ, который проходит следующие этапы: валидация DTD (Document Type Definition) любой HTML-документ должет содержать doctype для того, чтобы браузер  и валидатор могли понять какая версия стандарта используется, и в соответвие с этим применять определенные правила проверки; валидация синтаксиса на основании DTD валидации происходит  анализа синтаксиса на используемые тэги; проверка вложенности. Все используемые в HTML разметке тэги формируют вложенные структуры. Валидатор проверяет правильно ли выполнен данный механизм; проверка на посторонние элементы.  Если одна из проверка не успешна, то HTML-документа считается не валидным.",
    "codeexample":"",
    "images":[]
  },
  "h27":{
    "id":"08f36e44",
    "theme":"h",
    "question":"Если представить HTML5 как открытую веб-платформу, из каких блоков он состоит?",
    "answer":"Можно перечислить 8 основных пунктов: Семантика - позволяет более точно описать из чего состоит контент; Стилизация - позволяет создать сложные темы оформления; Доступ к устройствам - позволяет взаимодействовать с различными устройствами ввода и вывода; Связанность - позволяет общаться с сервером; Оффлайн хранилище - позволяет страницам хранить данные локально на клиентской стороне и более эффективно работать оффлайн; Мультимедиа - создание и подключение видео и аудио; 2D/3D графика - позволяют расширить возможности презентации; Производительность и интеграция - обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.",
    "codeexample":"",
    "images":[]
  },
  "h28":{
    "id":"08f36e45",
    "theme":"h",
    "question":"Какой тэг использовать для того, чтобы сверстать кнопку?",
    "answer":"Зависит от того, какую именно кнопку. Обычная кнопка, функциональность которой добавлена через JS - тогда тег button. Второй случай кнопка отправки формы - либо <button type=’submit’>, либо <input type=’submit’, value=’button’>. Третий вариант это кнопка-ссылка, здесь нужно использовать тег <a>, который стилизирован под кнопку при помощи CSS.",
    "codeexample":"",
    "images":[]
  },
  "h29":{
    "id":"08f36e46",
    "theme":"h",
    "question":"Что такое инлайновый стиль? Можно ли его переопределить?",
    "answer":"inline - когда стиль прописан не в отдельном файле/блоке, а непосредственно в коде. То есть инлайновый стиль применяется к определенному элементу в html и указывается прямо в html-файле при помощи атрибута style внутри тега. Inline стиль имеет самый высокий приоритет, игнорируя CSS правила, распространяющиеся на родителя и одноименные элементы/классы. Поэтому переопределить его можно только при помощи атрибута !important, который добавляется на CSS-свойство. Обычно инлайн стили не используют в современной разработке.",
    "codeexample":"",
    "images":[]
  },
  "h30":{
    "id":"08f36e47",
    "theme":"h",
    "question":"Есть ли у HTML элементов свои дефолтные специфичные стили?",
    "answer":"Да, практически каждый html-элемент обладает набором индивидуальных стилей. Это могут быть паддинги, марджины, размер шрифта, декорация текста и тд Проблема, что в разных браузерах разные дефолтные стили. Для их нивелирования используется normalize.css",
    "codeexample":"",
    "images":[]
  },
  "h31":{
    "id":"08f36e48",
    "theme":"h",
    "question":"Что такое семантика? Какие семантичные тэги вы знаете?",
    "answer":"Семантика - это использование правильных тегов, описывающих содержание контента внутри себя. Семантический тег описывает смысл элемента. (текст в теге p, заголовок в теге h, шапку в header и тп)",
    "codeexample":"",
    "images":[]
  },
  "h32":{
    "id":"08f36e49",
    "theme":"h",
    "question":"Как семантически правильно сверстать картинку с подписью?",
    "answer":"Внутрь тега figure помещается два тега - img и figcaption, в который помещается подпись к картинке",
    "codeexample":"",
    "images":[]
  },
  "h33":{
    "id":"08f36e50",
    "theme":"h",
    "question":"Типы списков в HTML?",
    "answer":"В HTML существуют три основных типа списков: Нумерованный список (Ordered List): Используется для отображения элементов в определенном порядке. Каждый элемент списка пронумерован автоматически. Создается с помощью тега <ol>, а элементы списка обозначаются тегом <li>. Ненумерованный список (Unordered List): Используется для отображения элементов без определенного порядка. Каждый элемент списка обозначен буллетом или маркером. Создается с помощью тега <ul>, а элементы списка обозначаются тегом <li>. Список определений (Definition List): Используется для отображения пар \"термин-описание\". Создается с помощью тега <dl>, термины обозначаются тегом <dt>, а описания — тегом <dd>. ",
    "codeexample":"",
    "images":[]
  },
  "h34":{
    "id":"08f36e51",
    "theme":"h",
    "question":"Для какого тэга используется атрибут alt и зачем он нужен?",
    "answer":"Это значит “альтернативный текст”, добавляется для тега img, то есть для картинки. В случае если картинка не отображается на странице, то вместо нее будет отображаться альтернативный текст. Этот атрибут обязателен при разработке. Его наличие улучшает доступность, так как прочитывается скринридерами.",
    "codeexample":"",
    "images":[]
  },
  "h35":{
    "id":"08f36e52",
    "theme":"h",
    "question":"Какая разница между тэгами <strong><em> и <b><i>?",
    "answer":"Если посмотреть на результат в браузере, то теги <strong> и <b> делают текст жирным, а теги <em> и <i> делают его курсивным, однако теги <strong> и <em> предназначены для добавления обернутому элементу логического выделения - то есть при чтении страницы скринридерами или поисковыми системами на данном тексте будет сделан акцент, а теги <b> и <i> такого акцента не добавляют.",
    "codeexample":"",
    "images":[]
  },
  "h36":{
    "id":"08f36e53",
    "theme":"h",
    "question":"Типы <input> элементов в HTML?",
    "answer":"В HTML для коммуникации с пользователем есть элемент input у него есть атрибут type. Некоторые примеры типов (их гораздо больше): text(для ввода букв, цифр и специальных символов), password (для ввода паролей, отображаются ***), e-mail (некоторые браузеры предлагают нужные символы и проверяют на соответствие формату email), number(позволяет вводить только числовые значения, ограничивать максимальное и минимальное), submit (поле превращается в кнопку для отправки данных), checkbox, radio, date/month/daytime-local (для ввода даты в виде выпадающего календаря) и тд.",
    "codeexample":"",
    "images":[]
  },
  "h37":{
    "id":"08f36e54",
    "theme":"h",
    "question":"Для чего используют data-атрибуты?",
    "answer":"Это устаревший подход. Раньше он применялся для хранения различной информации. То есть прямо в DOM-дереве можно хранить дополнительные данные.",
    "codeexample":"",
    "images":[]
  },
  "h38":{
    "id":"08f36e55",
    "theme":"h",
    "question":"Разница между <script>, <script async> и <script defer>?",
    "answer":"Когда происходит чтение или парсинг html-документа, парсинг может наткнуться на тег script. Script вызывает выполнение JS-кода, но при этом блокируется дальнейшее чтение html, пока не будет выполнен script. Поэтому этот тег добавляют обычно в конец документа. script с атрибутом async будет выполняться параллельно с чтением html-документа. Обычно это скрипт, который выполняется независимо от других скриптов документа. script defer - его выполнения произойдет только после полного парсинга страницы, то есть когда DOM-дерево будет полностью готово.",
    "codeexample":"",
    "images":[]
  },
  "h39":{
    "id":"08f36e56",
    "theme":"h",
    "question":"Для чего используется элемент <datalist>?",
    "answer":"Это html5 - элемент, который используется для создания выпадающего списка с возможностью в html нативной реализации автозаполнения. Для того чтобы добавить такой список на обычный input-элемент, ему добавляется атрибут list, а затем тегу datalist добавляется атрибут с таким же id. Когда пользователь начинает что-то печатать, ему предлагается список с подходящими вариантами.",
    "codeexample":"<input list=\"country\">\n<datalist id=\"country\">\n\t<option value=\"Russia\">\n\t<option value=\"Albania\">\n\t<option value=\"Bosnia\">\n\t<option value=\"Algeria\">\n</datalist>",
    "images":[]
  },
  "h40":{
    "id":"08f36e57",
    "theme":"h",
    "question":"Почему хорошей практикой считается располагать <link> для подключения CSS стилей внутри тэга <head>, а <script> для подключения JS ставить перед закрывающимся тэгом </body>?",
    "answer":"Необходимость помещать тэг <link>  внутри шапки сайта описано в спецификации. Чтение HTML страницы происходит слева направо сверху вниз, а построение loyat и его стилизации - это процессы, которые идут параллельно. Основная задача для улучшения UIX - это как можно раньше показать пользователю хоть какой-то контент, а не белую страницу, поэтому стили размещают внутри <head> или на самом высоком уровне страницы для того, чтобы их можно было как можно раньше запросить и добавить на читаемый HTML. Если их переместить вниз, то такой порядок препятствует прогрессивной загрузке страницы во многих браузерах. Таким образом они блокируют загрузку страницы, чтобы избежать перерисовку элемента если его стили изменяются, а пользователь все это время будет видеть просто белую страницу. Когда браузер встречает тэг script все процессы построения DOM и стилизации элементов откладываются до тех пор пока найденный скрипт не будет исполнен, поэтому тэг указывается в самом конце, чтобы не влиять на описанные процессы. Однако даже такое поведение можно отменить, если воспользоваться атрибутами async или deffer. Еще одна причина добавлять script  в конец документа - это то, что зачастую для работы скрипта нужны элементы DOM-дерева, для того, чтобы к моменту исполнения они были доступны тэг script и помещают перед закрывающимся тегом body.",
    "codeexample":"",
    "images":[]
  },
  "h41":{
    "id":"08f36e58",
    "theme":"h",
    "question":"Что такое мета-тэги?",
    "answer":"Это специальные теги <meta>, которые находятся внутри тега <head> и описывают само содержимое страницы. Они находятся в коде, но не отрисовываются в браузере. Основная их задача - это кратко описывать содержимое страницы поисковым системам, браузерам, социальным сетям. К ним можно отнести мета-тег для описании кодировки (<meta charset=\"UTF-8\">), СЕО-информации (автор, ключевые слова: напр., <meta name=\"keywords\" content=\"html, webdev\">), управления кешированием и другой дополнительной информации для браузеров.",
    "codeexample":"",
    "images":[]
  },
  "h42":{
    "id":"08f36e59",
    "theme":"h",
    "question":"Что описывается в тэге <head>?",
    "answer":"В теге <head> HTML-документа содержатся метаданные, которые не отображаются непосредственно на веб-странице, но играют важную роль для работы браузера, поисковых систем и других сервисов. В него входит тег <title> - в нем указывается основной заголовок html-страницы, который индексируется поисковиками. Теги <meta> - в основном нужны чтобы прописать кодировку, добавить описание и ключевые слова страницы, и вспомогательную информацию для браузеров. Также внутри тега <head> прописывается путь к таблицам стилей и другим внешним ресурсам с помощью тега <link>. Тег <style> может быть использован для вставки CSS-правил прямо в документ (но обычно так не делают). Также внутри тега <head> в некоторых случаях при помощи тега <script> подключаются скрипты (хотя чаще скрипты размещают перед закрывающим тегом <body>.",
    "codeexample":"",
    "images":[]
  },
  "h43":{
    "id":"08f36e60",
    "theme":"h",
    "question":"Для чего используются тэги <tr>, <th>, <td>?",
    "answer":"Это несамостоятельные теги, они используются внутри тега создания таблицы <table>. <tr> (table row) - служит контейнером, для создания строки таблицы, <th> (table head) - заголовок таблицы, <td> (table data) - для создания ячейки таблицы внутри строки.",
    "codeexample":"",
    "images":[]
  },
  "h44":{
    "id":"08f36e61",
    "theme":"h",
    "question":"Расскажите о meta-теге с name=\"viewport\"?",
    "answer":"Метатег viewport используется при построении отзывчивой версии сайта, то есть сайта оптимизированного для мобильных устройств. В ключевом атрибуте content описывается, каким образом страница должна себя вести на устройствах с разным разрешением. Здесь речь идёт о глобальном подходе. Свойство width определяет размера окна просмотра. Он может быть установлен на некоторое количество пикселей или на специальное значение device-width которое означает ширину экрана в CSS пикселях в масштабе 100%, свойство initial-scale контролирует уровень масштабирования при первой загрузке страницы. Обычно данное значение определяют как 1.0 свойства maximum-scale и minimum-scale определяет, как  пользователям разрешено увеличивать или уменьшать страницу, а user-scalable=no запрещает любое масштабирование на девайсе.",
    "codeexample":"",
    "images":[]
  },
  "h45":{
    "id":"08f36e62",
    "theme":"h",
    "question":"Что такое элемент <canvas>? И для чего он используется?",
    "answer":" Переводится как холст. Можно использовать для вставки изображений, градиентов и сложной анимации. А также он создает область, где при помощи JS можно рисовать объекты, преобразовывать их и изменять свойства. По сути он нужен для отрисовки графики.",
    "codeexample":"",
    "images":[]
  },
  "h46":{
    "id":"08f36e63",
    "theme":"h",
    "question":"Что такое <svg> и <canvas>?",
    "answer":"SVG - это язык разметки масштабируемые векторные графики созданный консорциумом всемирной паутины или W3C и входящий в подмножество расширяемого языка разметки XML, предназначен для описания двумерной векторной и смешанной векторно-растровой графики в формате xml, поддерживает как неподвижную так и анимированную интерактивную графики или если говорить в контексте разработки то декларативную и скриптовую. Canvas - это HTML элемент использующийся для рисования графики средствами языков программирования. В WEB разработке таким языком является JavaScript, его можно использовать для рисования графиков создание коллажей, анимации, редактирования и анализа изображений.",
    "codeexample":"",
    "images":[]
  },
  "h47":{
    "id":"08f36e64",
    "theme":"h",
    "question":"Разница между <canvas> и <svg>?",
    "answer":"Вопрос является открытым,поэтому постарайтесь запомнить несколько вариантов. Например: Canvas  - это одиночный дом элемент, а SVG - это набор элементов; canvas - это скриптовый язык, в то время как svg - это язык разметки; canvas используется для растровой графики,а  svg для векторной; у первого нет своего отдельного формата, а  svg изображение можно сохранить в отдельный файл соответствующем расширением; Canvas поддерживает различные события, а svg нет; Canvas с изображением нельзя сжимать, в то время как svg изображения поддаются сжатию.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/ykew95dhorergxt1ivp8y/3178625.webp?rlkey=mjhop6tpqb157jobzpm7dd9xv&st=0immbbh8&dl=1","https://www.dropbox.com/scl/fi/zeg3dnpwg4808txuo3pgk/3178624.webp?rlkey=wzqvcvn10x1kyu7rlnp7jc34x&st=gjhmnhj1&dl=1","https://www.dropbox.com/scl/fi/vmaklrec4epyz9rhx2c3t/3178623.webp?rlkey=egq4i0pl13g218r0z60u1v5pn&st=wkr3xc79&dl=1"]
  },
  "h48":{
    "id":"08f36e65",
    "theme":"h",
    "question":"В каких случаях лучше использовать <canvas>s, а в каких <svg>?",
    "answer":"Canvas следует использовать для редактирования изображений: обрезки, изменения размеров, применения различных фильтров по типу яркости, контраста и т.д., создания растровой графики, визуализации данных, создания фракталов и графиков функций, анализа изображений, а также создания игровой графики такой как спрайты и фоны. SVG следует использовать для создания пользовательских интерфейсов веб-приложений независимых от разрешения экрана, высоко интерактивных анимированных пользовательских интерфейсов, графиков и диаграмм или редактирования векторных изображений.",
    "codeexample":"",
    "images":[]
  },
  "h49":{
    "id":"08f36e66",
    "theme":"h",
    "question":"Плюсы и минусы <canvas> и <svg>?",
    "answer":"Плюсы canvas: 1.Высокая производительность при отрисовке любых 2D эффектов., 2. Стабильная производительность которая падает только в случаях увеличения разрешения изображений. Стабильность обеспечивается тем что работа происходит именно с пикселями. 3. Полученное изображение можно сохранить PNG или JPG файл. 4. Canvas лучше всего подходит для создания растровой графики редактирование изображений и операций требующих манипулирования на уровне пикселей. Минусы canvas: 1. Отрисовка основана на пикселях. 2. Не существует API для анимации приходится прибегать к использованию таймеров и других событий для обновления. 3.Слабые возможности по рендерингу текста. 4.Canvas - это не самый оптимальный вариант графики когда доступность имеет решающее значение. Холст представляет собой поверхность для рисования в выбранном контексте, то есть 2D или 3D, можно указать альтернативный контекст внутри элемента canvas, который будет показан в браузере при невозможности отображения графики. Кроме того можно выполнить проверку доступности выбранного canvas API с помощью JavaScript. На основе этого обеспечивается различная функциональность для пользователей браузеров с различной поддержкой canvas, но сам по себе этот механизм не прост для интеграции.  Плюсы svg: 1. Нет зависимости от разрешения svg, лучше подходит для кроссплатформенных пользовательских интерфейсов, так как позволяет масштабировать изображение при различных разрешениях экрана. 2. svg очень хорошо поддерживает анимацию, элементы могут быть анимированы с использованием описательного синтаксиса или с помощью JavaScript. 3. Можно получить полный контроль над каждым элементом используя SVG Dom API в JavaScript. 4. svg  хранится в формате xml, что представляет больше возможностей браузерам по обеспечению доступности svg документов по сравнению с canvas, таким образом svg выглядит лучшим решением для пользовательских интерфейсов веб-приложений. Минусы svg: 1. Низкая скорость рендеринга при увеличении сложности документа, так как используется Dom модель. 2. Не подходит для таких приложений как игры. Лучшим выбором будет именно комбинация из canvas и svg, так как каждыеских задач.",
    "codeexample":"",
    "images":[]
  },
  "h50":{
    "id":"08f36e67",
    "theme":"h",
    "question":"Для чего нужен атрибут autocomplete?",
    "answer":"Этот атрибут помогает заполнять поля форм текстом который был введён в них ранее, по сути это нативная поддержка автозаполнения. Значения сохраняются и предоставляются самим браузером, при этом данное автозаполнение исходя из безопасности может отключаться пользователям в настройках браузера, после чего не может управляться атрибутом autocomplete через HTML. Если же говорить о принудительном выключении автозаполнения в разметке, то autocomplete принимает два аргумента - это on - включает функцию автозаполнения текста и off - отключает автозаполнение. Это значение обычно используется для отмены сохранения в браузере важных данных таких, как, например, пароли и номера банковских карт, а также редко вводимых или уникальных данных, например, капча.",
    "codeexample":"",
    "images":[]
  },
  "h51":{
    "id":"08f36e68",
    "theme":"h",
    "question":"Что такое элемент <output> в HTML5?",
    "answer":"Элемент output требуется, когда нужно отобразить сумму двух введённых чисел в виде текста. В примере: есть два поля для ввода и нужно сложить числа из этих полей, после чего отобразить их сумму в виде текста. Для этого на тег формы добавляется специальный атрибут oninput данные с которого автоматически передаются в тег output. Также можно использовать атрибут форм для повышения читаемости, а для преобразования значений используется JS метод parseInt. ",
    "codeexample":"<form onsubmit=\"return false\" oninput=\"o.value = parseInt(a.value) + parseInt(b.value)\"> \n\t<input name=Ma\" type=\"number\"> +\n\t<input name=\"b\" type=\"number\"> =\n\t<output name=\"o\" />\n</form>\n\n// Using for\n<output name=\"o\" for=\"a b\"></output>",
    "images":[]
  },
  "h52":{
    "id":"08f36e69",
    "theme":"h",
    "question":"Что такое свойство valueAsNumber?",
    "answer":"JavaScript свойство valueAsNumber для полей формы, в частности для number date и  range, возвращает значение в виде числа, а не строки, то есть больше нет необходимости использовать parseInt или parseFloat, данные автоматически суммируется или вычитаются без необходимости их приведения к числовому типу.",
    "codeexample":"<form onsubmit=\"return false\" oninput=\"o.value = a.valueAsNumber + b.valueAsNumber\">\n\t<input name=\"a\" id=\"a\" type=\"number\" step=\"any\"> +\n\t<input name=\"b\" id=\"b\" type=\"number\" step=\"any\"> =\n\t<output name=\"o\" for=\"a b\"></output>\n</form>",
    "images":[]
  },
  "h53":{
    "id":"08f36e70",
    "theme":"h",
    "question":"Что такое атрибут target? Какие значения он принимает?",
    "answer":"Атрибут target используется в связке с тегом ссылки по умолчанию. При переходе по ссылке документ открывается в текущем окне или фрейме, при необходимости это поведение можно изменить атрибутом target. Все значения данного атрибута начинаются с нижнего подчёркивания, но принимает target четыре основные значения - это _blank: загружает страницу в новое окно браузера; _self: загружает страницу в текущее окно; _parent: загружает страницу в frame-родитель или, если фреймов нет, то значение отрабатывает как _self; и _top: отменяет все фреймы и загружает страницу  в полном окне браузера, если фреймов нет то это значение работает как _self. Чаще всего в проектах используется атрибут target со значением _blank.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/8f5057imhbny07f3b1gwi/image.webp?rlkey=orh58t4o9ltokv3r0q75hgnjk&st=7nogs9bp&dl=1"]
  },
  "h54":{
    "id":"08f36e71",
    "theme":"h",
    "question":"Что такое ApplicationCache в HTML5?",
    "answer":"Доступность приложения оффлайн становится всё более актуальной фичей для веб-приложений. Все браузеры по умолчанию имеют механизмы кэширования, однако не все они надёжные и работают ожидаемо. HTMLl5 устраняет некоторые из этих нюансов с помощью интерфейса ApplicationCache. Кэш приложения позволяет разработчику указать, какие файлы браузер должен кэшировать и сделать доступными для оффлайновых пользователей. Приложение будет работать корректно, даже если пользователь нажимает кнопку “обновить” находясь в автономном режиме. Использование интерфейса кэша дают приложению три важных преимущества: 1. Автономный просмотр: пользователи могут использовать сайт целиком находясь в оффлайне; 2. Скорость: ресурсы кэшируются локально, поэтому загружается быстрее; 3. Снижение нагрузки на сервер: браузер загружает с сервера только изменённые ресурсы.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/oiraa0nifvzws6ortyg7g/HTML-APP-CACHE.webp?rlkey=2fxqelx6sxhgg6du4pb5osabf&st=oy990au2&dl=1"]
  },
  "h55":{
    "id":"08f36e72",
    "theme":"h",
    "question":"Для чего используется элемент <picture>?",
    "answer":"Тег picture используется, когда для разных устройств или вариантов отображения нужны разные картинки. Он служит контейнером для одного или более элементов source и одного элемента img для обеспечения оптимальной версии изображения для разных размеров экрана. Одна и та же страница может быть открыта на разных устройствах и браузерных окнах разной ширины. У телефона небольшой экран и было бы отлично не загружать полноразмерные картинки с большим разрешением. Как раз для решения такой задачи и служит тег picture: браузер рассмотрит каждый из дочерних элементов source и выберет один соответствующий лучшему совпадению, чтобы выбрать оптимальное изображение. User agent анализирует атрибуты SRC, media и type элемента source и выбирает совместимое изображение, которое наилучшим образом соответствует текущему макету страницы и характеристикам устройства отображения.",
    "codeexample":"<picture>\n\t<source media=\"(min-width: 1024px\" srcset=\"https://picsum.photos/600/600\">\n\t<source media=\"(min-width: 768px\" srcset=\"https://picsum.photos/300/300\">\n\t<source media=\"(min-width: 360px\" srcset=\"https://picsum.photos/100/100\">\n\t<img src=\"https://picsum.photos/300/300\" alt=\"Just an image\" />\n</picture>",
    "images":[]
  },
  "h56":{
    "id":"08f36e73",
    "theme":"h",
    "question":"Что такое srcset? Как работает srcset?",
    "answer":"Srcset - это атрибут для элемента картинки, который позволяет удобно работать с отзывчивыми изображениями. Атрибуты srcset можно использовать, если требуется предоставить пользователям разные изображения в зависимости от ширины экрана их устройств. В srcset содержатся URL изображений и сведения об их ширине, браузер выберет из предоставляемого ему набора изображений то, что подходит лучше всего, причём если у пользователя имеется ретина дисплей с повышенной плотностью пикселей, браузер это учтёт при выборе изображения. Атрибуты srcset содержат список URL изображений, за которыми следуют сведения о ширине изображения, пары URL/ширина разделены запятыми. Браузер автоматически выберет наилучшее изображение, руководствуясь сложным набором критериев, в которые входит то, изображение какого размера выводятся у пользователя и то, каков текущий размер в области просмотра или имеется ли у пользователя дисплей высокого разрешения.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/0tlfv3v9iqx3p83p1pqz8/1.webp?rlkey=hl71ogzx9dmnwgandtub2yz4z&st=9xutr5jw&dl=1"]
  },
  "h57":{
    "id":"08f36e74",
    "theme":"h",
    "question":"Как семантически верно сверстать навигационное меню?",
    "answer":"Достаточно запомнить основную структуру <nav>, <ul>, <li>, <a>. В контейнер <nav> помещаются основные ссылки, по которым пользователь сможет быстро перейти на нужный раздел сайта. Внутри <nav> используется тег списка <ul>. Поскольку элементы меню однотипные по смыслу и связаны между собой. Каждый элемент списка - это <li>, а внутри каждого тега <li> находится ссылка <a>, где определён нужный адрес страницы.",
    "codeexample":"<nav class=\"menu\">\n\t<ul>\n\t\t<li><a href=\"#\">Главная</a></li>\n\t\t<li><a href=\"#\">О нас</a></li>\n\t\t<li><a href=\"#\">Контакты</a></li>\n\t</ul>\n</nav>",
    "images":[]
  },
  "h58":{
    "id":"08f36e76",
    "theme":"h",
    "question":"Что такое <iframe>?",
    "answer":" iframe или сокращение от Inline Frame то есть встроенный фрейм - это контейнер который находится внутри обычного документа и позволяет вставить любой HTML документ из другого источника часто Этот документ интерактивный например Карта видео или пост и соцсети содержимое внутри области существует независимо от окружающей страницы сам контейнер обычно называют фреймом внешний вид фрейма и его положение на странице можно задать через CSS Однако стилизация поддаётся именно фрейм а не его содержимое также данный тег поддерживает довольно много атрибутов которые помогают Как настраивать его внешний вид так и взаимодействие к основным можно отнести width и height ширина и высота служат для задания размеров src содержит ссылку на встраиваемый объект sendbox включает дополнительный набор ограничений для содержания в элементе alowfullscreen разрешает разворачивать фрейм на весь экран и frameborder определяет отображать границу фрейма или нет.",
    "codeexample":"<iframe\n\tid=\"inlineFrameExample\"\n\ttitle=\"Inline Frame Map\"\n\twidth=\"560\"\n\theight=\"400\"\n\tframeborder=\"1\"\n\tallowfullscreen=\"true\"\n\tsrc=\"https://yandex/ru/map-widget/v1/-/CDFerWEF0A\"\n></iframe> ",
    "images":[]
  },
  "h59":{
    "id":"08f36e77",
    "theme":"h",
    "question":"Для чего используются тэги <sub> и <sup>?",
    "answer":"Теги sub и sup относятся к текстурным тегам, однако чаще они используются для определения отдельных символов, а не слов. Их применяют для указания единиц измерения, написания простых формул, как математических, так и химических, а также выделения специфических элементов тэг sup  - это сокращение от Superscript отображает текст в виде верхнего индекса, а тег sub - это сокращение от Subscript и он обозначает текст в виде внешнего индекса. Для создания более сложных формул, например с несколькими степенями или математическими вычислениями, эти теги можно вкладывать друг друга. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/l17z7rotqw0h6lzlr7t65/i.webp?rlkey=4ybn8i8axxabzrzg9c09g3l3x&st=7fs29j78&dl=1"]
  },
  "h60":{
    "id":"08f36e78",
    "theme":"h",
    "question":"Как можно скрыть элемент разметки не используя CSS и JS?",
    "answer":"Для того, чтобы скрыть элемент на странице, существует очень много подходов. Это можно сделать через CSS используя display:none, visibility:hidden или даже opacity. Также элемент прячут с помощью JavaScript либо с помощью добавления класса со  скрывающими свойствами либо удалением его из дом дерева. Но дополнительно убрать элемент со страницы можно и с помощью атрибута hidden прямо в HTML разметке. Это отличный вариант для тех случаев, когда не подходят opacity или visibility. Следует отметить, что это не лучшая практика - влиять на внешний вид страницы через разметку, но иногда это именно то, что нужно. По сути, это display:none именно так он описан в браузерных стилях. Поскольку атрибут hidden глобальный, его можно добавить к абсолютно любому тегу, чтобы спрятать его от пользователя. Важно знать, что тег спрятаный при помощи атрибута hidden становится невидимым не только для пользователя но и для скринридеров.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/x6ys4q234knoh1vb04yb5/How-to-hide-text-in-HTML-code-Method-1-using-the-html-hidden-global-attribute-1080x608.jpg.webp?rlkey=7kyfa68tst0v577bens487ufl&st=kmjnshxb&dl=1"]
  },
  "h61":{
    "id":"08f36e79",
    "theme":"h",
    "question":"Разница между <meter> и <progress>?",
    "answer":"Элемент meter определяет собой числовое, возможно дробное значение в известном диапазоне. Этот элемент не подходит для измерения чего-то вроде температуры, поскольку она не имеет фиксированного диапазона. Для использования данного тега должно быть известно максимальное значение, однако meter может, например, использоваться для отображения занятого места на жёстком диске. Дополнительно у данного тега на UI есть различные цветовые обозначения в зависимости от наполненности шкалы. Элемент progress используется для отображения хода выполнения задачи. В отличие от элемента meter, прогресс описанный в progress может быть не окончательным, например можно написать, что задание выполняется, но неизвестно, когда задача будет выполнена до конца.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/fhzu82wf8adqnshf8agsd/progressbar.gif?rlkey=x09l3z6vpe0j331j7glmr4udd&st=g8xkb3ie&dl=1","https://www.dropbox.com/scl/fi/ba4asoj9vqeltzlesijwz/meter.webp?rlkey=5bz297io7lmzx8i77hn7m1tci&st=1hwy8scf&dl=1"]
  },
  "h62":{
    "id":"08f36e80",
    "theme":"h",
    "question":"Как можно сгруппировать опции внутри тэга <select>?",
    "answer":"Тег <select> представляет из себя элемент с выпадающим списком опций, каждая опция оборачивается в специальный тег <option>. Для того, чтобы сгруппировать несколько опций внутри <select>, можно использовать тег <optgroup> который и предназначен для решения данной задачи. Он указывается внутри тега <select> и в свою очередь оборачивает один или несколько элементов  <option>. Использование <optgroup> добавляет некоторые ограничения, а именно: нельзя вкладывать один <optgroup> в другой. Распространённые атрибуты, которые используются с данном тегом - это label -  добавляет обобщающий заголовок для сгруппированных опций disabled - находящиеся внутри группы опции станут недоступны для выбора.",
    "codeexample":"<form action=\"/action_page.php\">\n\t<label for=\"skills\">Choose a Skill:</label>\n\t<select name=\"skills\" id=\"skills\">\n\t\t <optgroup label=\"FrontEnd\">\n\t\t\t<option value=\"Angular\">Angular</option>\n\t\t\t<option value=\"React\">React</option>\n\t\t</optgroup>\n\t\t<optgroup label=\"Backend\">\n\t\t\t<option value=\"Java\">Java</option>\n\t\t\t<option value=\"PHP\">PHP</option>\n\t\t</optgroup>\n\t</select>\n\t<br><br>\n\t<input type=\"submit\" value=\"Submit\">\n</form>",
    "images":["https://www.dropbox.com/scl/fi/1x5y7mok71cbefh8fmoel/3fit9vrbt79szusx1jaj.webp?rlkey=2x25wogkbm8hrwbm4sx17c32j&st=rdsy40nw&dl=1"]
  },
  "h63":{
    "id":"08f36e81",
    "theme":"h",
    "question":"Что такое скринридер?",
    "answer":"Данный вопрос больше относится к доступности, чем к HTML, тем не менее доступность тесно связана с семантикой и валидностью разметки. Сайтами и приложениями пользуются разные люди. Кто-то может делать это с любого устройства, другим же нужны вспомогательные технологии. Вспомогательные технологии - это такие программы и устройства, которые упрощает взаимодействие пользователей с особыми потребностями с контентом, например: выносные кнопки, трекболы, брайлевские дисплеи, экранные лупы, скринридеры. Скринридер - это программа, которая превращает контент интерфейсов в речь или шрифт брайля. Другие названия: программы экранного доступа или чтения, программа чтения с экрана и экранное считывающее устройство. Она нужна людям со слепотой и слабовидящим, а также пользователем с когнитивными особенностями, которым легче воспринимать информацию на слух, например людям с дислексией. Слабовидящие пользователи могут сочетать скринридеры с другой вспомогательной технологией, например с экранной лупой она увеличивает контент на экране и тоже его озвучивает если это нужно.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/3atlo3xafga7bcy7krzya/EN-Screenreader.webp?rlkey=h4bmkkrd0gf7f00uoagijpn18&st=b10ukhkm&dl=1","https://www.dropbox.com/scl/fi/0zl34ij0lcxxoubwsgtnf/44b4d13c-96c5-4c54-a169-a140223bb9671.webp?rlkey=4jhjjqf8ccdfankg18hvluatw&st=3bzhhotn&dl=1"]
  },
  "h64":{
    "id":"08f36e82",
    "theme":"h",
    "question":"Как можно изменить форму картинки или HTML элемента?",
    "answer":"Для данной задачи есть свойство clip-path. Оно создаёт ограниченную область, которая определяет, какая часть элемента должна быть видимой, а обрезанная область - это траектория, определяемая либо как внутренняя ссылка, либо как внешний SVG, либо как фигура. Существует два способа использования clip-path: 1. На CSS, в этом случае доступны разные фигуры по типу polygon, circle, ellipse, inset и так далее, преимущество этого подхода заключается в лёгком синтаксисе, а также возможности использования относительных единиц. 2. На SVG - в данном варианте в качестве альтернативы можно создать фигуру с помощью SVG, а затем обрезать элемент по этой фигуре с помощью специального синтаксиса. К преимуществам данного подхода можно отнести: лучшую браузерную поддержку по сравнению с CSS, а также то что обрезку можно выполнять сложными фигурами, а не ограниченным набором.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/fgkdhsbg50ylzgsx7qmky/s_1C7AD0A4850094E4D2D26A3CFDC9C88A0039A9E3AB842A383CDFC6264774BE81_1629785847040_5.webp?rlkey=pgfduv6cl4ue2uuuhz4obsnl9&st=sa7m9vcc&dl=1","https://www.dropbox.com/scl/fi/s5p2u7s360ccd3499hrjj/s_1C7AD0A4850094E4D2D26A3CFDC9C88A0039A9E3AB842A383CDFC6264774BE81_1629785777260_2.webp?rlkey=divo1fx70a3f94chmatmng5wy&st=0m73spmq&dl=1"]
  },
  "h65":{
    "id":"08f36e83",
    "theme":"h",
    "question":"Чем отличается <article> от <section>?",
    "answer":"Элемент article задаёт содержание сайтов вроде “новости”, “статьи”, “записи блога”, “форумы” и так далее. Если немного абстрагироваться, то можно сказать, что это специальный вид section, который обозначает независимую и самодостаточную часть страницы. На его месте можно использовать section, но article добавляет более семантическое значение. section  немного похож на обычный div, так как используется, как контейнер, но он уже имеет особое семантическое значение: объекты, которые располагаются внутри него объединены общим смыслом. section задаёт раздел документа, может применяться для блока новостей, контактной информации, глав текста, вкладок в диалоговом окне и так далее, раздел обычно содержит заголовок, в отличие от article, тег section допускается вкладывать друг в друга также этот элемент служит для разбивки текста на разделы.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/yysm1zby2bwknstrhm4oe/div-section-article.webp?rlkey=ucuw01n4bgipb6qm6t9kcoguf&st=94o8tn5r&dl=1"]
  },
  "h66":{
    "id":"08f36e84",
    "theme":"h",
    "question":"Расскажите об особенностях стилизации <svg>?",
    "answer":"Стилизация SVG отличается от стилизации стандартных HTML элементов. SVG  основан на XML и стилевые свойства отличаются по названию. Два основных элемента или атрибута которые используются для стилизации - это заливка fill и обводка stroke. fill - это альтернатива background-color, а stroke - это аналог свойства border, с помощью него можно менять цвет основной линии, на их базе строятся дополнительные свойства по типу stroke-width, stroke-linecap, stroke-opacity, fill-opacity и так далее, изображение в формате SVG можно стилизовать напрямую в разметке, а также используя соответствующие селекторы делать это в CSS файлах. Наибольшая особенность связана со SVG спрайтами: если они используются, то стилизовать SVG  можно только в разметке. Также не получится динамически изменить свойства SVG с помощью JavaScript.",
    "codeexample":"<?xml version=\"1.0\" standalone=\"no\"?>\n<svg\n\t width=\"200\"\n\t height=\"150\"\n\t xmlns=\"http://www.w3.org/2000/svg\"\n\t version=\"1.1\">\n\t<path\n\t\td=\"M 10 75 Q 50 10 100 75 T 190 75\" \n\t\tstroke=\"black\"\n\t\tstroke-linecap=\"round\"\n\t\tstroke-dasharray=\"5,10,5\"\n\t\tfill=\"none\"\n\t/>\n\t<path\n\t\td=\"M 10 75 L 190 75\" \n\t\tstroke=\"red\"\n\t\tstroke-linecap=\"round\"\n\t\tstroke-width=\"1\"\n\t\tstroke-dasharray=\"5,5\"\n\t\tfill=\"none\"\n\t/>\n</svg>",
    "images":["https://www.dropbox.com/scl/fi/di6yytk4omn7kk3vw48gl/note-show.webp?rlkey=qz6esweku1n7e4cb1aa6u6uqz&st=6zhsr548&dl=1"]
  },
  "h75":{
    "id":"08f36e85",
    "theme":"h",
    "question":"Что такое ARIA роли в веб приложении?",
    "answer":"Для начала следует отметить, что ARIA - это большой блок, относящиеся к accessibility или доступности. В свою очередь, доступность означает предоставление пользователю возможности перемещаться и взаимодействовать с веб сайтами любыми способами.\nARIA- набор специальных атрибутов, которые могут быть добавлены в любую разметку, но особенно подходят для HTML. Атрибут role определяет типы объектов, такие как: статья, меню, оповещение или ползунок.\nДополнительные ARIA-атрибуты предоставляют другие полезные возможности, такие как описания для форм и текущие значения индикаторов выполнения.\nРасшифровывается ARIA как Accessible Rich Internet Application.\nРоль определяет способ сделать веб – контент и веб – приложение более доступным для людей с ограниченными возможностями. Например, ARIA делает доступным навигационные маркеры, javascript виджеты, подсказки на форме, сообщения об ошибках, автоматические обновления и многое другое.\nВсе это также предоставляет дополнительную информацию, программу чтения с экрана.",
    "codeexample":"",
    "images":[""]
  },
  "h67":{
    "id":"08f36e86",
    "theme":"h",
    "question":"Разница между кнопкой и ссылкой в HTML?",
    "answer":"По-другому этот вопрос может звучать, как “назовите особенности кнопок и ссылок”. Из-за дизайнов, где ссылка может выглядеть как кнопка и наоборот кнопка как ссылка, из-за JavaScript, который может добавить логику на любой элемент, границы между этими элементами стираются. Однако, если говорить о нативных возможностях каждого из них, то они довольно разные. К особенностям кнопки можно отнести следующие: кнопка получает фокус с клавиатуры по умолчанию, она способна отправлять данные формы на сервер и очищать форму, блокироваться с помощью атрибута disabled, добавляет подсказку скринридеру с помощью неявного атрибута role=\"button\", а также показывает состояние focus, hover, active, disable. Если добавить JavaScript, то кнопка идеальный элемент для: открывания модального окна, вызова всплывающего меню и переключения интерфейса. Что же касается ссылки то она может создавать гипертекст и сеть онлайн ресурсов перевести пользователя на новую страницу или окно, изменять url-адрес вызывать браузерные перерисовки и перезагрузки переходить по якорям внутри страницы, способна принимать focus по умолчанию с помощью атрибута href, регистрировать клик по нажатию клавиши enter, не блокироваться, в отличие от кнопки. Однако, её также можно сделать не активной с помощью tabindex =”-1” и area-hidden=”true”. Итого, главное различие между ссылкой и кнопкой - это то, что ссылки перемещают пользователя на новый ресурс, то есть переносят его из текущего контекста, кнопка же переключает что-то в интерфейсе или вызывает новый контент в том же самом контексте.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/41c1kqlljq9dpphev1ns4/1_am9jlbvMtHMUMd5900esvQ.webp?rlkey=z7ro82jpplcalygt7fc3q4z0w&st=xzzx8hv8&dl=1"]
  },
  "h68":{
    "id":"08f36e87",
    "theme":"h",
    "question":"Для чего используется атрибут decoding?",
    "answer":"Атрибут decoding используется в связке с тегом img, то есть с картинкой. Данный атрибут позволяет указать, как браузер должен декодировать изображение, он принимает три основных значения, которые определяют основной механизм: async - декодирование происходит вне основного потока, sync - декодирование идёт в основном потоке и auto - декодирование осуществляется по логике самого браузера. Следует отметить, что decoding и lazyload - это разные вещи decoding связан с тем, как браузер декодирует данные картинки, то есть картинка сначала загружается в кодированном виде, потом декодируется, и только потом отображается. По умолчанию декодирование происходит в основном потоке, а это может мешать другим процессам происходящим на странице с помощью decoding=”async” можно сообщить браузеру, что изображение может быть интерпретировано асинхронно, то есть декодировано в параллельном потоке и не должно влиять на основной поток рендера страницы. Здесь важно отметить, что в процессе загрузки браузер проскакивает область изображения, не зная какого размера нужно оставить место для него, и рендерит то, что идёт ниже. Одновременно с этим в параллельным потоке он подгружает картинку, узнаёт о её размерах и вписывает её в страницу, и когда изображение подгружается, вёрстка может скакать. Это в свою очередь негативно влияет на CLS или content layout shift метрику и об этом важно помнить когда планируется применять decoding.",
    "codeexample":"",
    "images":[]
  },
  "h69":{
    "id":"08f36e88",
    "theme":"h",
    "question":"Для чего используется атрибут enterkeyhint?",
    "answer":"Данный атрибут используется в связке с элементами формы, точнее тегами input и textarea. Также его можно добавлять на элементы с атрибутом contenteditable, который превращает их в редактируемые. Enterkeyhint - это атрибут, который указывает, какое местку действия или значок представить для клавиши ввода на виртуальных клавиатурах пользователя. Он позволяет авторам настраивать представление клавиши ввода, чтобы сделать её более полезной для конечного пользователя. Enterkeyhint может принимать одно из семи основных назначений: enter - обычно означает вставку новой строки; done - означает что вводить больше нечего и редактор методов ввода будет закрыт; go - означает перевод пользователя к цели набранного текста; next - переводит пользователя в следующее поле, которое будет принимать текст; previous - переводит пользователя в предыдущие поле, которое также принимает текст; search - переводит пользователя к результатам поискам введённого текста и sent - отправляет введённый текст.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/1kjzq1zenadq4pjtti98p/enterkeyhint-scaled.webp?rlkey=cs0zikj01pzevbwp5oq5d53kr&st=6daodhk1&dl=1"]
  },
  "h70":{
    "id":"08f36e89",
    "theme":"h",
    "question":"Для чего используют атрибут novalidate?",
    "answer":"Атрибут novalidate предназначен для отключения нативной валидации формы на стороне браузера, каждое поле формы, которое заполняет пользователь, может иметь чётко указанный тип и правила ввода. В момент, когда пользователь отправляет форму, браузер проверяет правильность заполненных данных, блокируя отправку в случае ошибки и показывая подсказку там, где она была допущена. Например, поля с атрибутом required должны быть обязательно заполнены и браузер укажет, если пользователь вдруг какой-нибудь из них пропустил. Атрибут  novalidate говорит браузеру не проверять поля и не препятствовать отправке формы, так как иногда подобное поведение бывает нежелательным, например, форма проверяется с помощью JavaScript и нужно избегать конфликтов с браузерной валидацией, в том числе и убрать всплывающие подсказки чтобы показать вместо них свои кастомные.",
    "codeexample":"<form action=\"/action_page.php\" novalidate>\n\t<label for=\"email\">Enter your email</label>\n\t<input type=\"email\" id=\"email\" name=\"email\">\n\t<input type=\"submit\">\n</form>",
    "images":[]
  },
  "h71":{
    "id":"08f36e90",
    "theme":"h",
    "question":"Для чего используют атрибут inputmode?",
    "answer":"Атрибут inputmode говорит браузеру на устройствах с экранной клавиатурой, какой набор символов показать. Приводит данные в конкретное поле, определяется данный атрибут для элементов input или textarea важно понимать разницу между атрибутом type и атрибутом inputmode. inputmode только подсказывает браузеру какой набор символов предложить пользователю для взаимодействия с полем ввода, в то время как type устанавливает тип данных, которые пользователь может ввести в поле ввода. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/lo7if5ltn8uy2j40zwiav/keyboard_screencaps_all.webp?rlkey=3ixpd67fdu1qwgem3a9pcqztr&st=phm3fscu&dl=1"]
  },
  "h72":{
    "id":"08f36e91",
    "theme":"h",
    "question":"Для чего используется атрибут pattern?",
    "answer":"Атрибут pattern определяет регулярное выражение, которому должно соответствовать значению элементов формы. Если же введённое значение не соответствует указанному паттерну, то input поля будет подсвечено, как не валидное. Важным моментом является также то, что если присутствует атрибут pattern, то форма не будет отправляться, пока поле не будет заполнено правильно. Атрибут паттерн является атрибутом для полей ввода с типом tel, text, e-mail, url, password, search. В примере: браузер проверит перед отправкой формы, что пароль не меньше шести символов в длину, и если это не так, то input  подсветится и появится всплывающая.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/vmr8h1zs0bh5ns3uyjtbv/chrome_tooltip-1078w.webp?rlkey=1dxa8qzqw3r2d0twfwr6qjbh9&st=kqz4xrf4&dl=1"]
  },
  "h73":{
    "id":"08f36e92",
    "theme":"h",
    "question":"Почему стоит использовать семантические теги в верстке?",
    "answer":"Семантическая вёрстка - это подход к разметке, который опирается не на внешний вид сайта, а на смысловое предназначение каждого блока и логическую структуру документа. Использовать семантические теги можно по многим причинам, основные из которых это 1. Сделать сайт доступным, для незрячих людей основной инструмент для просмотра сайтов не браузер, которые отрисовывает страницу, а скринридер, который читает текст со страницы вслух. Этот инструмент зачитывает содержимое страницы, и семантическая структура помогает ему лучше определять, какой сейчас блок, а пользователю понимать, о чём идёт речь. 2. Чтобы сайт был выше в поисковиках. Компании, которые создают поисковики, не разглашают правила ранжирования, но известно, что наличие семантической разметки страниц помогает поисковым ботам лучше понимать, что находится на странице и, в зависимости от этого, ранжировать сайты в поисковой выдаче. 3. Семантика прописана в стандартах. Многие разработчики по старинке используют конструкции типа <div id=”nav”> для обозначения навигации или других структурных элементов на странице, тем временем, в стандарте HTML5 появилось множество семантических тегов, которые рекомендуется использовать для разметки страниц вместо стандартных div и span. В спецификации для каждого тематического элемента описаны его роль. 4. Семантика удобна с точки зрения разработки, помимо плюсов для пользователей сайта и поисковых ботов, огромным плюсом семантической верстки является удобство её чтения другими разработчиками.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/0l7lnikvgymlcrzj2ik5l/html5-e1575378985564.webp?rlkey=y6789oy7q6cprs2b58o52tdye&st=kuhrt7yv&dl=1"]
  },
  "h74":{
    "id":"08f36e93",
    "theme":"h",
    "question":"Для чего используется тэг <label>?",
    "answer":"Тег <label> определяет текстовую метку для элементов textarea, input, Селект а также checkbox и radiobutton по своему виду данная метка ничем не отличаются от обычного текста, сверстанного с помощью span, однако, у неё есть одна важная отличительная особенность: при пользовательском клике по тексту расположенному внутри элемента label элемент формы, который связан с данным лейблом становится активным, т.е. получает фокус. Чтобы определить, к какому элементу формы относится текущая метка, можно воспользоваться одним из двух подходов: первый - можно использовать атрибут for для <label>, значение атрибута for должно быть эквивалентно значению атрибута id элемента формы, к которому будет относиться метка; второй - просто поместить элемент формы внутрь тега <label> и в этом случае атрибут for можно не использовать.",
    "codeexample":"<!-- Using \"for\" for a \"label\" -->\n<form action=\"/action_page.php\" novalidate>\n\t<label for=\"male\">Male</label>\n\t<input type=\"radio\" id=\"male\" name=\"sex\" />\n\t<label for=\"mail\">Female</label>\n\t<input type=\"radio\" id=\"female\" name=\"sex\" />\n</form>\n\n<!-- Using \"label\" as a wrapper -->\n<form action=\"/action_page.php\" novalidate>\n\t<label>\n\t\tMale\n\t\t<input type=\"radio\" id=\"male\" name=\"sex\" />\n\t</label>\n\t<label>\n\t\tFemale\n\t\t<input type=\"radio\" id=\"female\" name=\"sex\" />\n\t</label>\n</form>",
    "images":[]
  },
  "c75":{
    "id":"08f36e94",
    "theme":"c",
    "question":"Что такое CSS? И для чего он используется?",
    "answer":"CSS (Cascading Style Sheets - каскадные таблицы стилей) — это язык стилей, используемый для описания внешнего вида и форматирования документов, написанных на HTML. То есть предназначены для добавления стилей на веб-страницу.",
    "codeexample":"",
    "images":[]
  },
  "c76":{
    "id":"08f36e95",
    "theme":"c",
    "question":"Что такое CSS-правило?",
    "answer":"CSS-правило формируется из 2х основных составляющих: 1) селектор - указывает на HTML-элементы, к которым применяется стиль. Селектор определяет, какие элементы на странице будут затронуты данным правилом; 2) блок объявления - находится в фигурных скобках {} и содержит одно или несколько свойств и их значения.",
    "codeexample":"",
    "images":[]
  },
  "c77":{
    "id":"08f36e96",
    "theme":"c",
    "question":"Варианты добавление CSS стилей на страницу?",
    "answer":"4 основных способа: Инлайновые стили (на конкретный элемент); Внутренние стили (в теге style внутри head); Внешние стили (файл с CSS-стилями добавляется при помощи тега link в head); Импортированные (импорты внутри файлов стилей @import).",
    "codeexample":"",
    "images":[]
  },
  "c78":{
    "id":"08f36e97",
    "theme":"c",
    "question":"Типы позиционирования в CSS?",
    "answer":"5 основных типов: static (присваивается всем элементам по умолчанию - все элементы в основном потоке документа), relative (элемент можно перемещать относительно его первоначального места в документе, сам элемент остается в основном потоке), absolute ( элемент вырывается из основного потока и создает отдельные поток, позиционируется относительно ближайшего предка, у которого позиционирование не static, либо относительно края видимой области страницы), fixed (позиционирование только относительно окна браузера), sticky (внутри видимой области браузера ведет себя как fixed, при дальнейшем прокручивании скроллится вместе с родителем)",
    "codeexample":"",
    "images":[]
  },
  "c79":{
    "id":"08f36e98",
    "theme":"c",
    "question":"Блочная модель CSS?",
    "answer":"Блочная модель CSS (Box Model) описывает, как браузеры рассчитывают размеры и размещение элементов на веб-странице. Она определяет, как элементы в документе отображаются и взаимодействуют друг с другом. В нее входят следующие компоненты: сам контент (внутреннее пространство элемента), padding (внутренний отступ), border (граница - линия, окружающая контент и внутренние отступы), margin (внешний отступ). Таким образом суммарный размер элемента будет состоять из данных компонентов. (Чтобы размер элемента равнялся именно заданному значению, то используется свойство box-sizing: border-box).",
    "codeexample":"",
    "images":[]
  },
  "c80":{
    "id":"08f36e99",
    "theme":"c",
    "question":"Что такое селектор? И какие селекторы существуют?",
    "answer":"Это часть CSS-правила, которое сообщает браузеру, какому элементу/ам будет применен стиль. Все селекторы делятся на две большие группы: простые и составные. Простые (указан один вариант селектора): class, id, tag, универсальный (*), селектор атрибута. Составной селектор состоит из нескольких простых, разделенный либо пробелом либо другим символом: групповые селекторы (через ,), селектор потомка (через пробел вся цепочка: “div p”), селектор только дочернего элемента (знак >: “li > a”), селектор псевдокласса, псевдоэлемента.",
    "codeexample":"",
    "images":[]
  },
  "c81":{
    "id":"08f36e100",
    "theme":"c",
    "question":"Что такое специфичность селектора? Как считать вес селектора?",
    "answer":"Специфичность это способ, с помощью которого браузеры определяют, какие значения css-свойств будут применены к элементу. К одному элементу могут быть применены сразу несколько стилей. И вот какие стили будут отображены в браузере зависит от специфичности, которая базируется на определении веса селектора. Есть 4 основных веса селектора: inline - вес 1000, id - 10, класс/атрибут/псевдокласс - 10, элемент/псевдоэлемент - 10",
    "codeexample":"",
    "images":[]
  },
  "c82":{
    "id":"08f36e101",
    "theme":"c",
    "question":"Разница между Reset.css и Normalize.css?",
    "answer":"Так как почти все html-элементы обладают дефолтными стилями, а каждый браузер отображает их по разному, то чтобы во всех браузерах сайт выглядел одинаково, то применяется Reset.css (чтобы сбросить все дефолтные стили) либо Normalize.css (унифицирует отображение во всех браузерах).",
    "codeexample":"",
    "images":[]
  },
  "c83":{
    "id":"08f36e102",
    "theme":"c",
    "question":"Разница между margin и padding?",
    "answer":"padding это внутренний отступ (от границы блока до контента), margin - это внешний отступ (от границы блока до соседнего блока).",
    "codeexample":"",
    "images":[]
  },
  "c84":{
    "id":"08f36e103",
    "theme":"c",
    "question":"Разница между display: none и visibility: hidden?",
    "answer":"Оба правила скрывают элементы на странице. Но свойство display: none полностью убирает элемент с html-страницы, из потока документа, из поисковиков, он остается доступным только в DOM-дереве. Правило visibility: hidden оставляет элемент в основном потоке документа, при этом он не виден на странице, а также остается виден для поисковиков.",
    "codeexample":"",
    "images":[]
  },
  "c85":{
    "id":"08f36e104",
    "theme":"c",
    "question":"Разница между блочным (block) и строчным (inline) элементами?",
    "answer":"Блочный элемент по умолчанию всегда будет занимать всю доступную ширину экрана. Строчный элемент подстраивается под размер его контента. Блочные всегда идут друг под другом, а строчные могут располагаться рядом. Блочным элементам можно задавать ширину и высоту, для строчных это не работает. Блочные воспринимают отступы - margin и padding. Для строчных элементов margin padding сверху и снизу не работают.",
    "codeexample":"",
    "images":[]
  },
  "c86":{
    "id":"08f36e105",
    "theme":"c",
    "question":"Разница между классом и идентификатором в CSS?",
    "answer":"Обычно для добавления стилей лучше использовать класс, хотя id может быть использован для уникальной стилизации отдельного элемента. id встречается на странице только один раз, является уникальным. У каждого элемента может быть только один id. class может использоваться на нескольких элементах и у каждого элемента может быть несколько классов. Идентификатор имеет высокий вес в спецификации CSS - 100, у класса вес CSS - 10. Это означает, что стили, применяемые через идентификатор, имеют высокий приоритет и могут переопределить стили, заданные через классы или элементы.",
    "codeexample":"",
    "images":[]
  },
  "c87":{
    "id":"08f36e106",
    "theme":"c",
    "question":"Что такое CSS спрайт? И для чего он используется?",
    "answer":"CSS спрайт — это техника оптимизации загрузки веб-страниц, которая используется для уменьшения количества HTTP-запросов к серверу.\nCSS спрайт представляет собой одно большое изображение, которое объединяет несколько маленьких изображений. Эти маленькие изображения, как правило, являются графическими элементами интерфейса, такими как иконки, кнопки или фоны.\nСначала создается одно большое изображение (спрайт), в котором размещаются все маленькие изображения. Обычно это делается в графическом редакторе или с помощью инструментов автоматизации.\nВ CSS используется свойство background-image для установки спрайта как фона для элементов. Затем с помощью свойства background-position указывается, какая часть спрайта должна быть видима для конкретного элемента. Таким образом, из большого спрайта \"выбирается\" нужная часть для отображения.\nПлюсы использования:\nУменьшение количества HTTP-запросов: Вместо нескольких запросов на сервер за отдельными изображениями, отправляется только один запрос за спрайтом. Это уменьшает нагрузку на сервер и ускоряет загрузку страницы.",
    "codeexample":"/*Пример использования спрайта: Предположим, у вас есть три иконки, которые вы объединяете в одно изображение:*/\n.icon {\n\tbackground-image: url('sprite.png');\n\twidth: 32px; /* Ширина иконки */\n\theight: 32px; /* Высота иконки */\n\tdisplay: inline-block;\n}\n\n.icon-home {\n\tbackground-position: 0 0; /* Положение иконки в спрайте */\n}\n\n.icon-search {\n\tbackground-position: -32px 0; /* Положение иконки в спрайте */\n}\n\n.icon-settings {\n\tbackground-position: -64px 0; /* Положение иконки в спрайте */\n}\n\n/*В этом примере .icon применяет общий спрайт, а .icon-home, .icon-search и .icon-settings указывают, какую часть спрайта нужно показать, используя background-position.*/",
    "images":[]
  },
  "c88":{
    "id":"08f36e107",
    "theme":"c",
    "question":"Что такое вендорные префиксы? И для чего они используются?",
    "answer":"Это приставка к css-свойству, которая обеспечивает поддержку данного свойства браузером, в котором оно не внедрено на постоянной основе (в стадии разработке либо тестирования). Это инструмент кросс-браузерной совместимости. Можно автоматизировать процесс добавления префиксов с помощью специальных программ Autoprefixer.",
    "codeexample":"",
    "images":[]
  },
  "c89":{
    "id":"08f36e108",
    "theme":"c",
    "question":"Что такое псевдоэлементы? И для чего они используются?",
    "answer":"Псевдоэлемент - это ключевое слово, которое добавляется на селектор и позволяет стилизировать определенную часть выбранного элемента. Существует 5 типов: first-letter, first-line, before (вставка контента перед выбранным элементом), after (вставка после), selection (позволяет изменить часть элемента, которая была выбрана пользователем).",
    "codeexample":"",
    "images":[]
  },
  "c90":{
    "id":"08f36e109",
    "theme":"c",
    "question":"Что такое схлопывание границ (margin collapsing)?",
    "answer":"Это механизм взаимодействия внешних отступов по вертикали, когда у блочных элементов расположенных друг под другом отступы не суммируются, а объединяются между собой, и итоговое расстояние получается равным большему из марджинов. Также взаимодействуют марджины вложенных блоков. Исключения из правил: Флекс-контейнеры и их дети: Внутри flex-контейнеров отступы не схлопываются. Грид-контейнеры и их дети: Внутри grid-контейнеров отступы также не схлопываются. Элементы с overflow, padding, border: Если элемент имеет overflow, padding или border, его отступы не схлопываются.",
    "codeexample":"",
    "images":[]
  },
  "c91":{
    "id":"08f36e110",
    "theme":"c",
    "question":"Что такое CSS препроцессор?",
    "answer":"Это программа, которая позволяет генерировать css из собственного уникального синтаксиса. Синтаксис препроцессоров обычно проще и удобнее в использовании, чем в нативном css (переменные, вложенность, миксины)",
    "codeexample":"",
    "images":[]
  },
  "c92":{
    "id":"08f36e111",
    "theme":"c",
    "question":"Что такое z-index? Как формируется контекст наложения?",
    "answer":"Любой элемент в HTML документе может быть на переднем или на заднем плане, по умолчанию порядок наложения равен порядку следования в HTML. Если же позиционирование элементов и их дочерних элементов задано явно, то такие элементы будут прикрывать собой элементы без явно заданного свойства позиционирования. z-индекс учитывается только на явно позиционированных элементах, для не позиционированных элементов он не работает. Если значение z-индекс задано, формируется контекст наложения. Контекст будет сформирован, если: элемент - корневой элемент документа; элемент позиционирован не статически и z-индекс не равен auto; элемент имеет прозрачность не менее 1.  У каждого контекста наложения будет свой корневой элемент в HTML структуре, все дочерние элементы будут добавлены в контекст и займут своё место в порядке наложения. Элемент внизу одного контекста не получится расположить над элементом другого контекста, располагающимся выше по иерархии даже с максимальным  z-индексом.",
    "codeexample":"",
    "images":[]
  },
  "c93":{
    "id":"08f36e112",
    "theme":"c",
    "question":"Порядок наложения элементов в CSS (Stacking Order)?",
    "answer":"Элементы в HTML имеют объёмную структуру и могут перекрывать друг друга. При отсутствии z-индекса порядок наложения будет следующий (от нижнего к верхнему) : background и  border-элементы, элементы с  z-индекс < 0 и их дочерние элементы, элементы блочного уровня (position = static), float элементы, inline элементы, элементы с  z-индекс = 0/auto, элементы с  z-индекс > 0.",
    "codeexample":"",
    "images":[]
  },
  "c94":{
    "id":"08f36e113",
    "theme":"c",
    "question":"Как с помощью CSS определить, поддерживается ли свойство в браузере?",
    "answer":"В каскадных таблицах стилей есть специальная директива, которая называется supports. Данная директива позволяет проверить, поддерживает ли браузер свойства, правила или CSS селектор. Правила использования - аналогично с медиа запросами: основной код с помощью фигурных скобок оборачивается в директиву, в директиве в круглых скобках указывается вариант проверки и если условие срабатывает, то будет выполнен css-код написанный в фигурных скобках. Следует отметить, что директива support очень активно используется в подходе progressive enhancement.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/9h5dwkmj4s9l163afgfqp/blend-modes-supports-small.webp?rlkey=r15p1nnf9qlmwwi5oag6o7dmd&st=ghkr4l5v&dl=1"]
  },
  "c95":{
    "id":"08f36e114",
    "theme":"c",
    "question":"Как поддерживать страницы в браузерах с ограниченными функциями?",
    "answer":"Вопрос является открытым и ориентируется в первую очередь на опыт разработчика. Некоторые из базовых подходов: обнаружение функций с помощью библиотеки Modernizr, использование CSS директивы support, Autoprefixer для автоматической ставки браузерных префиксов, использование ресурса caniuse.com, чтобы проверить поддержку применения подходов Graceful degradation или Progressive enhancement.",
    "codeexample":"",
    "images":[]
  },
  "c96":{
    "id":"08f36e115",
    "theme":"c",
    "question":"Как исправлять специфичные проблемы со стилями для разных браузеров?",
    "answer":"Данный вопрос открытый и помогает понять Ваш опыт в браузерной верстке. Поскольку существует разные браузеры, для некоторых свойств в закладываются разные значения. В результате, одна и та же страница может выглядеть по-разному, поэтому применяются различные подходы, чтобы унифицировать начальные стили, а также писать CSS свойства которые будут отрабатывать одинаково. Вот некоторые из таких техник: использование Autoprefixer  для автоматической ставки браузерных префиксов, подключение Reset Css или Normalize.css, в редких и очень специфических случаях можно использовать CSS-хаки, разделение стилей для разных браузеров и их динамическая подгрузка, использование сторонних библиотек по типу Bootstrap или Tailwind CSS, которые уже решают эти проблемы со стилями, регулярное тестирование приложения на специализированных сервисах, как например Browserstack.",
    "codeexample":"",
    "images":[]
  },
  "c97":{
    "id":"08f36e116",
    "theme":"c",
    "question":"Глобальные ключевые слова в CSS?",
    "answer":"Для всех свойств CSS помимо стандартных значений можно задать значение в виде ключевых слов. В CSS есть четыре глобальных ключевых слова - это initial: у каждого из свойств CSS есть значение по умолчанию, оно применяется ещё до того, как что-либо написано в файле стилей. Ключевое слово initial сбрасывает все указанные значения свойства для конкретного блока до этих самых значений по умолчанию; inherit: CSS свойства делятся на наследуемые и не наследуемые, значение наследуемых свойств применяется не только к элементу для которого прописаны но и для всех вложенных дочерних элементов, это очень удобно, чтобы не писать много одинаковых свойств для разных селекторов перечисляя всех потомков; unset - это ключевое слово ведёт себя по-разному с наследуемыми и не наследуемыми свойствами, с наследуемыми свойствами ключевое слово unset ведёт себя как inherit, а с не наследуемыми свойствами оно ведёт себя как initial; revert - данное ключевое слово сбрасывает значение свойства до указанного в стилях браузера.",
    "codeexample":"",
    "images":[]
  },
  "c98":{
    "id":"08f36e117",
    "theme":"c",
    "question":"Что такое CSS-атрибут (attr)?",
    "answer":"Функция attr или аббревиатура attribute - это CSS функция которая умеет получать значение любого атрибута элемента, а потом использовать это значение прямо в таблице стилей. Функция работает и с псевдоэлементами, в этом случае возвращается значение атрибута элемента, для которого формируется псевдоэлемент. Функцию attr можно использовать с любым свойством CSS, но поддержка иных кроме content является экспериментальной.",
    "codeexample":"",
    "images":[]
  },
  "c99":{
    "id":"08f36e118",
    "theme":"c",
    "question":"Что такое перечисление селекторов?",
    "answer":"При помощи перечисления нескольких селекторов через запятую можно избежать дублирования кода. Если в нескольких элементах есть определённые повторяющиеся стили, то вполне допустимо внести эти стили в отдельный блок, после чего в качестве селектора указать несколько классов или тегов, или идентификаторов, перечислив их через запятую. Таким образом описанные стили будут применены сразу к нескольким элементам и нет необходимости повторно писать один и тот же код для каждого.",
    "codeexample":".main-title,\n.title {\n\tposition: relative;\n\tcolor: #ffffff;\n\tfont-weight: 500;\n}\n\nh1, h2, h3, h4, h5, h6 {\n\tmargin: 0;\n}",
    "images":[]
  },
  "c100":{
    "id":"08f36e119",
    "theme":"c",
    "question":"Для чего используется ключевое слово currentColor в CSS?",
    "answer":"Ключевое слово currentColor можно использовать в качестве значения для CSS свойства принимающего цвет, то есть оно будет работать для свойств color, background color, box shadow, text shadow и так далее. В качестве примера можно рассмотреть box shadow. Браузер подставит вместо currentColor текущее значение свойства color, то есть красный, таким образом можно соблюдать консистентность или однообразие палитры и, в случае изменения основного цвета, автоматически будут изменены все зависящие, то есть определённые через currentColor цвета.",
    "codeexample":"",
    "images":[]
  },
  "c101":{
    "id":"08f36e120",
    "theme":"c",
    "question":"Какие псевдоклассы были добавлены в CSS3?",
    "answer":"В спецификацию css-3 было добавлено 7 новых псевдо классов: первый :nth-child(n) - выбирает N-ый дочерний элемент внутри родительского элемента, и метка этого дочернего элемента N может принимать определённое значение или функции; второй :nth-last-child(n) выполняет ту же функцию что и первый но выполняет выборку элементов с конца; третий :last-child(n) выбирает последний дочерний элемент; четвёртый - :only-child(n) выбирает элемент, если он является единственным дочерним элементом родительского элемента; пятый :nth-of-type(n) выбирает элемент N-го типа внутри родительского элемента, N в свою очередь может принимать определённые значения или функции; шестой :first-of-type(n) выбирает первый элемент заданного типа внутри родительского элемента и седьмой :last-of-type(n) выбирает последней элемент заданного типа внутри родительского элемента.",
    "codeexample":"",
    "images":[]
  },
  "c102":{
    "id":"08f36e121",
    "theme":"c",
    "question":"Какие фильтры есть в CSS?",
    "answer":"CSS позволяет накладывать поверх картинок или фонов различные фильтры, это помогает, например, размыть или обесцветить изображение, сделать его более контрастным. Основное свойство называется filter. Ему в виде значения присваиваются специальные функции, таких функций можно выделить несколько это grayscale - делает изображение чёрно-белым в скобках можно указать значение от 0% до 100%, значение 100 делает изображение полностью чёрно-белым; sepia- это имитация старых изображений, то есть такой своеобразный эффект старины, принимает значение в процентах, которое также указывается от 0 до 100; saturate - насыщенность, позволяет сделать даже блёклое изображение более сочным, в виде параметров принимает проценты, дефолтное значение насыщенности изображение - это 100, а диапазон определяется от 0 до не ограниченного числа; hue-rotate меняет цвета изображение за счёт поворота цветового круга угол поворота указывается в скобках; invert - инвертирует цвет изображения превращая его во что-то похожее на негатив значение передаётся в процентах и варьируется от 0 до 100; brightness меняет яркость изображения, в скобках можно указать любое значение от нуля процентов и выше, значение ноль сделает изображение полностью чёрным значение 100% вернёт изображению исходную яркость; contrast меняет контраст изображения, в скобках можно указать любое значение от нуля процентов и выше, значение ноль сделает изображение полностью чёрным значение 100% вернёт изображению  исходный контраст; blur применяет размытие по Гауссу к изображению, значение в скобках указывает, сколько пикселей будут слиты друг с другом.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/93xrns2yngkz3arctizao/7f482f215540b6a97166e1e76a7c8ed9.webp?rlkey=jdxo4isjleke8jt0yqsf52c47&st=f9q52lu5&dl=1"]
  },
  "c103":{
    "id":"08f36e122",
    "theme":"c",
    "question":"Для чего используется псевдокласс :invalid?",
    "answer":"Обычно проверку формы перекладывают на JavaScript и в случае, если какие-то данные введены неверно, то на всю форму или на какой-то её конкретный элемент вешается класс, по которому добавляются стили. Однако, помимо динамического добавления классов можно воспользоваться и нативными возможностями CSS, для этого и применяется псевдокласс :invalid. Если говорить в общем, то данный псевдокласс облегчает стилизацию формы и элементов при её невалидности, он находит любые input или form элементы, контент которых не проходит валидацию или проверку в соответствии с типом поля и позволяет легко менять внешний вид полей, что в свою очередь даёт пользователю возможность видеть и исправлять ошибки. В дополнение можно добавить, что помимо псевдокласса :invalid есть псевдокласс :valid, который позволяет стилизовать поля, успешно прошедшие валидацию.",
    "codeexample":"",
    "images":[]
  },
  "c104":{
    "id":"08f36e123",
    "theme":"c",
    "question":"Расскажите про свойство display в CSS?",
    "answer":"По умолчанию, все элементы HTML бывают блочными и строчными. Но в вёрстке часто бывают ситуации, когда требуется сделать элемент не строчным, а блочным или наоборот, и в таких случаях можно использовать свойство display со значениями block - блочное отображение или inline - строчное отображение. Помимо этих двух значений существует смешанный тип inline-block, то есть срочно-блочное отображение. Также можно использовать none, который полностью скрывает элемент со страницы не удаляя его при этом из HTML разметки. Flex - элемент становится flex контейнером, ведёт себя как блочный, а вложенные элементы становятся flex-элементами. Inline-flex - аналогичен flex, только шириной подстраивается под контент внутри себя. Grid - элемент становится grid контейнером, снаружи grid контейнер ведёт себя как block, дочерние элементы такого контейнера начинают подчиняться правилам grid раскладки. Inline-grid - аналогичен grid, только шириной подстраивается под контент внутри себя, а также table и table-cell или таблица и ячейка таблицы - трансформируют элемент, добавляют ему табличное поведение, которое распространяется на вложенные элементы и на контент внутри.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/e4ocbi2ih6smprbyadncd/display-diagram-type-as-shape.webp?rlkey=z7gnortfi0iggq9f5hzr726m4&st=mxky16za&dl=1"]
  },
  "c105":{
    "id":"08f36e124",
    "theme":"c",
    "question":"В каком случае лучше использовать translate() вместо абсолютного позиционирования?",
    "answer":"Для анимаций лучше всего использовать именно CSS переходы или свойство translate. Всё дело в том, что браузер умеет хорошо его оптимизировать. У translate() большая частота кадров за счёт более быстрого рендеринга, под капотом у себя translate() использует субпиксельную интерполяцию которая работает плавнее и быстрее, что же касается анимации с помощью абсолютного позиционирования и заздания различных точек позиций элементов, здесь для движения используется пиксельная сетка, поэтому могут наблюдаться скачки. Также использование translate позволяет сделать небольшую хитрость в улучшении производительности анимаций - это вынос анимируемых элементов в отдельный слой, чтобы их изменения не затрагивали всё вокруг, делается это с помощью свойства will-change или, как это делалось раньше, transform со значением translateZ(0).",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/91uwh57h4o6f3b7gb0rwk/3.webp?rlkey=2epjjhe6o5sxw9ggkbxchw00r&st=fsmgt5tj&dl=1"]
  },
  "c106":{
    "id":"08f36e125",
    "theme":"c",
    "question":"Что такое плавающие элементы (floats)? Как они работают?",
    "answer":"При применении этого свойства происходит следующее: первое - элемент позиционируется как обычно, а затем вынимается из основного потока документа, после чего он сдвигается влево для left или вправо для right до того, как коснётся либо границы родителя, либо другого элемента float; второе - если пространства по горизонтали не хватает для того чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться; третье - другие непозиционировнные блочные элементы без float ведут себя так, как будто элемента с float нет, так как он убран из основного потока; четвёртое - строки, то есть inline элементы напротив знают о float и обтекают элемент по сторонам. Изначально это свойство было создано для того, чтобы текст мог обтекать изображение слева или справа, отсюда и такие особенности поведения. В последующем float стал использоваться для построения многоколоночных макетов, в данный момент построение многоколоночного макета с помощью float считается устаревшим подходом.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/a6msjn1fng0omnbv8u2bi/step3_float.webp?rlkey=lke151l6l16bpafa60mvcmxqs&st=uoyco6g4&dl=1"]
  },
  "c111":{
    "id":"08f36e126",
    "theme":"c",
    "question":"Расскажите о свойстве text-rendering?",
    "answer":"Свойство text-rendering позволяет указывать браузеру какие оптимизации нужно производить с текстом во время рендера. Когда браузер рассчитал внешний вид символа, он должен корректно отрисовать этот символ в пиксельной сетке экрана монитора.\nПроцесс заполнения пикселей после расчетов для видимой отрисовки чего угодно называется рендеринг. Рендеринг текста - это процесс отрисовки символа шрифта в пиксельной сетке, при этом для обеспечения более естественного вида текста, браузер может выполнять дополнительные вычисления и модификации символов: изменять кернинг (межсимвольное расстояние), объединять пары и даже тройки символов в лигатуры.\nText-rendering принимает 4 основных значения, которые определяют механизм оптимизации:\n - Auto - это значение по умолчанию. Браузер пытается самостоятельно угадать в какой момент отрисовки важна скорость вывода символов, в  какой читаемость, а в какой геометрическая точность.\n - OptimizeSpeed- при отрисовке текста, браузер будет ставить в приоритет именно скорость отрисовки, поэтому лигатура и кернинг будут отключены.\n - OptimizeLegibility - используется в случае, когда важна не скорость отрисовки, а удобочитаемость текста и визуальная красота сочетания символов. При таком значении браузер будет активно использовать лигатуры и корректировать кернинг.\n - GeometricPrecision - в этом случае основной приоритет при рендеринге текста - это геометрическая точность. В некоторых шрифтах кернинг изменяется не пропорционально изменению размера шрифта. Это может приводить к не самому лучшему внешнему виду текста, однако, довольно быстрой отрисовке.",
    "codeexample":"",
    "images":[]
  },
  "c112":{
    "id":"08f36e127",
    "theme":"c",
    "question":"Расскажите о свойстве text-decoration-skip-ink?",
    "answer":" В каскадных таблицах стилей (или CSS) есть основное свойство, которое управляет подчеркиванием текста- text-decoration. Определяя его значение, текст можно подчеркнуть/ перечеркнуть/нарисовать над ним линию. Но для того, чтобы управлять внешним видом верхнего и нижнего подчеркивания существует свойство text-decoration-skip-ink. Важно отметить, что если текст нужно перечеркнуть, то данное свойство будет проигнорировано.\nПринимает оно 3 основных значения:\n - none - в этом случае линия рисуется под тестом сквозь глифы.\n - auto - линия может рисоваться так, что не касается глифов. Это, кстати, значение по умолчанию.\n -all - линия будет рисоваться не касаясь глифов.",
    "codeexample":"",
    "images":[]
  },
  "c107":{
    "id":"08f36e128",
    "theme":"c",
    "question":"Расскажите о свойстве pointer-events?",
    "answer":"pointer-events позволяет управлять тем, как элементы будут реагировать на события мыши или прикосновения к сенсорному экрану. Свойство позволяет контролировать когда, как и может ли вообще указательное устройство взаимодействовать с элементом, принимает оно два основных значения это none и auto. None предотвращает событие указателя для элемента hover, active и так далее, в том числе способно отменять и JavaScript событие click. Auto - восстанавливает стандартное взаимодействие указателя с элементом, помимо этих двух ему можно передать значения по типу visiblePainted, visibleFill, visibleStroke, visible и так далее, однако эти значения работают только для SVG элементов. На практике pointer-events можно применять для случаев запрета пользователю клика правой кнопкой мыши по картинкам на сайте,  выключение взаимодействия со страницей во время обработки асинхронных запросов, блокировки любого элемента страницы от взаимодействия с курсором. Из негативных последствий необдуманного использования свойства можно назвать влияние на аналитику, другими словами из-за блокировки взаимодействия с элементом, аналитика может собираться не точно.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/jdwu9tnv3lpkqu1gxhjc5/o6nxqormoj09m42v39ty.webp?rlkey=3m35dtn05bdb5sfd5ulfhgku6&st=271opvc3&dl=1"]
  },
  "c108":{
    "id":"08f36e129",
    "theme":"c",
    "question":"Почему не стоит использовать краткую запись свойств CSS?",
    "answer":"Периодически при задании стилей к элементам используется сокращённая запись свойств, с одной стороны, это вполне оправдано, так как уменьшает количество написанного кода, с другой стороны есть проблемы дефолтной стилизации, например есть задача перекрасить пункт кнопки в красный цвет. Для этого можно указать свойство background: red; после чего кнопка изменит свой фон. Мы всего лишь хотим чтобы у нашей кнопки был красный фоновый цвет, но на самом деле, под капотом задаётся целый набор правил. За счёт простого использования краткой записи мы безоговорочно решили, что не хотим использовать фоновое изображение, заодно указав для него: стартовую позицию с левого верхнего края, повторение по осям X и Y,  прокрутку вместе с элементом и так далее. Почти все проблемы баги и регрессии в CSS происходят из-за того, что разработчик делает слишком многое слишком рано, а через некоторое время сталкивается с последствиями этого. Из-за этого факта следует вывод: в CSS нужно делать лишь то, что требуется и ничего более. Именно поэтому краткая форма записи CSS свойств не всегда приемлема.",
    "codeexample":"/* Our property */\n\n.btn {\n\tbackground: red;\n}\n\n/* Under the hood */\n\n.btn {\n\tbackground-image: initial;\n\tbackground-position-x: initial;\n\tbackground-position-y: initial;\n\tbackground-size: initial;\n\tbackground-repeat: initial;\n\tbackground-attachment: initial;\n\tbackground-origin: initial;\n\tbackground-clip: initial;\n\tbackground-color: red;\n}",
    "images":[]
  },
  "c109":{
    "id":"08f36e130",
    "theme":"c",
    "question":"Расскажите о свойстве outline?",
    "answer":"Если говорить просто, то outline немного похож на border. К его особенностям можно отнести то, что свойство не влияет на размеры элемента, а также его можно отодвинуть от границ на любое расстояние. outline  присутствует стандартных стилях браузера для акцента на сфокусированных интерактивных элементах, другими словами размеры не меняются, верстка страницы не ломается, но пользователь наглядно видит, какой элемент в фокусе. outline - это shortcut т.е. короткое свойство для записи сразу нескольких значений. Внутри себя оно содержит свойства:outline-width, outline-style и outline-color. Всё по аналогии со значениями border. outline-width определяет толщину обводки, принимает значение thin, medium, thick, или заздаёт тонкую, среднюю или толстую ширину. Также толщина может быть задана в пикселях, ram и em. outline-style определяется стиль обводки может быть определена как dotted, dashed, solid, double и так далее, outline-color определяет цвет обводки, принимает любое доступное значение цвета, включая ключевые слова transparent, current color и invert.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/66blycg6o10fllkzg12c8/border-style-css.webp?rlkey=09bp09c68sm50v9477qjbzdsx&st=8owoq975&dl=1"]
  },
  "c110":{
    "id":"08f36e131",
    "theme":"c",
    "question":"Назовите псевдоэлементы для подсветки текста?",
    "answer":"В CSS-3 помимо набора стандартных псевдоэлементов появились так называемые псевдоэлементы выделения. Они представляют собой части документа, которым присвоен определённый статус, обычно данные части имеют другой стиль, чтобы подсветить этот статус пользователю, например выбранные части документа обычно выделяются с помощью задания альтернативного цвета фона и переднего плана или световой размывки, чтобы указать их выбранный статус. Существует четыре основных псевдоэлемента выделения - это selection - определяет выделенный текст target-text - определяет текст, на который непосредственно нацелен фрагмент и URL адреса документа. Другими словами, это поисковая строка, которая хранится в URL. spelling-error - содержимое, которое было помечено  User agent, как ошибочное. grammar-error  содержимое которое было помечено User agent как грамматически неверное, следует отметить, что последние два псевдо элемента ещё не поддерживаются браузерами. Все псевдоэлементы выделения могут принимать свойства: color, background-color, cursor, current-color, outline, text-decoration,  text-emphasis-color, text-shadow; все эти свойства можно использовать для стилизации выделенного текста.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/etklw30lkejil6lo7o79o/style-text-to-scroll-fragments-2-1120x677.webp?rlkey=vew4vb5zppen4j31fhf7qxfwg&st=71uptk5n&dl=1"]
  },
  "j111":{
    "id":"08f36e132",
    "theme":"j",
    "question":"Типы данных в JavaScript?",
    "answer":"8 основных типов: строка, число, bigint, boolean, Symbol(), Object(), null, undefined.",
    "codeexample":"",
    "images":[]
  },
  "j112":{
    "id":"08f36e133",
    "theme":"j",
    "question":"Разница между == и === (нестрогое/строгое равенство)?",
    "answer":"Нестрогое просто сравнивает значения, строгое дополнительно сравнивает их типы.",
    "codeexample":"1 == ‘1’ / true; 1 === ‘1’ / false;",
    "images":[]
  },
  "j113":{
    "id":"08f36e134",
    "theme":"j",
    "question":"Разница между function declaration и function expression?",
    "answer":"Function Declaration и Function Expression — это два способа определения функций в JavaScript, и между ними есть несколько важных различий: Function Declaration (Объявление функции) - при помощи ключевого слова function; Function Expression (Функциональное выражение) - функция присваивается в переменную;Основная разница в поведении функций, объявленных разным способом, проявляется во всплытии (Hoisting): Function Declaration: Объявление функции полностью \"всплывает\" в начало своего контекста (глобального или локального). Это означает, что функцию можно вызывать до ее фактического определения в коде. Function Expression: Всплытие происходит только у переменной, которой присваивается функция, но не у самой функции. Это означает, что вы не можете вызвать функцию до того, как она была объявлена.",
    "codeexample":"//Function Declaration (Объявление функции) - при помощи ключевого слова function://\nfunction sayHello() {\n\t console.log(\"Hello!\");\n}\n\n//Function Expression (Функциональное выражение) - функция присваивается в переменную://\nconst sayHello = function() {\n\tconsole.log(\"Hello!\");\n};",
    "images":[]
  },
  "j114":{
    "id":"08f36e135",
    "theme":"j",
    "question":"Разница между null и undefined?",
    "answer":"Оба значения обозначают отсутствующие данные. Но undefined используется для обозначения отсутствия значения по умолчанию, например, для объявленной, но не инициализированной переменной, для значения функции, которая ничего не возвращает, для несуществующего свойства объекта, а null — для явного указания на отсутствие значения.",
    "codeexample":" (let x; console.log(x); // undefined\nlet y = null; console.log(y); // null).",
    "images":[]
  },
  "j115":{
    "id":"08f36e136",
    "theme":"j",
    "question":"Типы таймеров в JavaScript?",
    "answer":"Есть 2 основных типа таймеров: 1) setTimeout (позволяет вызывать некоторую функцию один раз по истечению определенного времени) 2)setInterval (позволяет вызывать функцию постоянно, через некоторый промежуток времени). Оба принимают два значения - функцию, которая будет выполнена по истечению, и время. setTimeout(sayHi, 1000) - sayHi() вызовется один раз, setInterval(sayHi, 1000) - sayHi() будет вызываться постоянно с промежутком в 1000 мс.",
    "codeexample":"",
    "images":[]
  },
  "j116":{
    "id":"08f36e137",
    "theme":"j",
    "question":"Что такое поднятие (Hoisting)?",
    "answer":"Поднятие переменных это механизм подъема функции или переменной в глобальную или функциональную область видимости. Это происходит с переменными, объявленными при помощи var, и с функциями определенными function declaration - к ним можно получить доступ еще до объявления в документе.",
    "codeexample":"",
    "images":[]
  },
  "j117":{
    "id":"08f36e138",
    "theme":"j",
    "question":"Что такое область видимости (Scope)?",
    "answer":"Это место откуда мы имеем доступ к переменной или функции. В JS мы имеем 3 области видимости - глобальная (), локальная(), блочная (новая, в ES6 - это область внутри {} для переменных, объявленных с помощью let и const).",
    "codeexample":"",
    "images":[]
  },
  "j118":{
    "id":"08f36e139",
    "theme":"j",
    "question":"Разница между var, let и const?",
    "answer":"Переменная, объявленная с помощью var, всплывает. То есть, если такую переменную  вызвать еще до ее инициализации, то мы получим undefined. В случае переменных, объявленных let или const, мы получим ошибку. Во-вторых, у let и const область видимости блочная - то есть, если они объявлены внутри {},то доступны только внутри этого блока и на всех вложенных уровнях. Переменная, объявленная с помощью var, такую область видимости игнорирует, она имеет функциональную область видимости, то есть доступна в пределах функции, если объявлена внутри нее, либо доступна глобально, если объявлена за пределами функций. В-третьих, разница между let и const, что переменная, объявленная const, не может быть переопределена.",
    "codeexample":"",
    "images":[]
  },
  "j119":{
    "id":"08f36e140",
    "theme":"j",
    "question":"Что такое замыкание (Closure)?",
    "answer":"Замыкание (closure) — это механизм в JavaScript, при котором функция «запоминает» своё лексическое окружение, даже когда она выполняется вне своей первоначальной области видимости. Когда функция создается в JavaScript, она запоминает не только свой код, но и окружение, в котором была создана. Это окружение включает все переменные и параметры, которые были в области видимости этой функции на момент её создания. Если функция обращается к переменным вне своего тела, она образует замыкание. Другими словами, при создании функции и использовании внутри нее переменных, эти переменные доступны только внутри этой функции. Для хранения этих переменных выделяется определенная память, и когда функция заканчивает свое выполнения, эта память очищается, и эти переменные больше нигде не существуют. Но если внутри одной функции создать вторую, то вложенная функция получит доступ к переменным, которые были объявлены во внешней функции. Этот механизм и называется замыканием. Тогда при отработке внешней функции возвращается внутренняя, которая замыкается на значение внешней и не дает памяти очиститься.",
    "codeexample":"//Например:\nfunction outerFunction() {\n\tlet outerVariable = \"I am outside!\";\n\n\tfunction innerFunction() {\n\t\tconsole.log(outerVariable);\n\t}\n\n\treturn innerFunction;\n}\nconst myClosure = outerFunction();\nmyClosure(); // Выведет: \"I am outside!\"\n\n/*Как это работает:\n\t1.Функция outerFunction создает переменную outerVariable и определяет внутреннюю функцию innerFunction, которая использует эту переменную.\n\t2.Замыкание возникает, когда innerFunction запоминает переменную outerVariable из своей внешней области видимости.\n\t3.Когда outerFunction завершает выполнение, переменная outerVariable обычно исчезла бы, но поскольку на неё ссылается innerFunction, она сохраняется.\n\t4.Когда мы вызываем myClosure(), функция innerFunction все еще имеет доступ к outerVariable, несмотря на то, что функция outerFunction уже завершила выполнение.*/",
    "images":[]
  },
  "j120":{
    "id":"08f36e141",
    "theme":"j",
    "question":"Что обозначает this в JavaScript?",
    "answer":"В JavaScript this — это ключевое слово, которое ссылается на текущий контекст выполнения, то есть объект, к которому принадлежит функция или метод, где используется this.",
    "codeexample":"//Например, this может использоваться:\n\t//1.в ​​методе объекта - this указывает на объект, которому принадлежит метод:\nconst person = { name: 'Alice',\n\tgreet() {\n\t\tconsole.log(this.name);\n\t}\n};\nperson.greet(); // 'Alice'\n\n\t//2.В конструкторах - в функции-конструкторе this ссылается на создаваемый объект:\nfunction Person(name) {\n\tthis.name = name;\n}\nconst person1 = new Person('Bob');\nconsole.log(person1.name); // 'Bob'\n\n\t//3.В стрелочных функциях - стрелочные функции не имеют своего собственного this. Они наследуют значение this из окружающего контекста:\nconst obj = {\n\tname: 'Carol',\n\tgreet: function() {\n\t\tconst inner = () => console.log(this.name);\n\t\tinner();\n\t}\n};\nobj.greet(); // 'Carol'",
    "images":[]
  },
  "j121":{
    "id":"08f36e143",
    "theme":"j",
    "question":"Что такое функции высшего порядка (Higher Order Functions)?",
    "answer":"Это функции, которые в качестве аргумента принимают другую функцию или же возвращают другую функцию (например, map, reduce, forEach, filter).",
    "codeexample":"",
    "images":[]
  },
  "j122":{
    "id":"08f36e144",
    "theme":"j",
    "question":"Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?",
    "answer":"Для превращения можно использовать один из двух подходов: либо функцию Boolean(), внутрь которой мы передаем данные, а на выходе получаем булевое значение - true либо false. Второй подход - использовать двойное отрицание - !! В JS существует 6 основных элементов, которые возвращают ложное значение: ‘’(пустая строка), 0, null, undefined, NaN, false.",
    "codeexample":"",
    "images":[]
  },
  "j123":{
    "id":"08f36e145",
    "theme":"j",
    "question":"Методы строк в JavaScript?",
    "answer":"length: Возвращает длину строки. toUpperCase(): Преобразует строку в верхний регистр. toLowerCase(): Преобразует строку в нижний регистр. indexOf(substring): Возвращает индекс первого вхождения подстроки или -1, если подстрока не найдена. includes(substring): Проверяет, содержится ли подстрока в строке, возвращает true или false. slice(start, end): Возвращает часть строки от start до end (не включая end). substring(start, end): Похож на slice, но не поддерживает отрицательные значения для start и end. substr(start, length): Возвращает подстроку определенной длины от заданной начальной позиции. trim(): Удаляет пробелы в начале и конце строки. split(separator): Разбивает строку на массив подстрок по указанному разделителю. replace(searchValue, newValue): Заменяет первое вхождение подстроки на новую строку. repeat(count): Повторяет строку указанное количество раз. charAt(index): Возвращает символ по указанному индексу. charCodeAt(index): Возвращает код символа по указанному индексу. concat(...strings): Объединяет две или более строки.",
    "codeexample":"",
    "images":[]
  },
  "j124":{
    "id":"08f36e146",
    "theme":"j",
    "question":"Методы массивов в JavaScript?",
    "answer":"length: Возвращает количество элементов в массиве. push(element): Добавляет один или несколько элементов в конец массива и возвращает новую длину массива. pop(): Удаляет последний элемент из массива и возвращает его. shift(): Удаляет первый элемент из массива и возвращает его. unshift(element): Добавляет один или несколько элементов в начало массива и возвращает новую длину массива. concat(...arrays): Объединяет два или более массива и возвращает новый массив. slice(start, end): Возвращает новый массив, содержащий копию части исходного массива от start до end (не включая end). splice(start, deleteCount, ...items): Изменяет массив, удаляя элементы, добавляя новые или и то, и другое, возвращает удаленные элементы. indexOf(element): Возвращает первый индекс указанного элемента в массиве, или -1, если элемент не найден. includes(element): Проверяет, содержит ли массив определенный элемент, возвращает true или false. toString() преобразует массив в строку, где элементы массива разделены запятыми. Этот метод не изменяет исходный массив. join(separator): Объединяет все элементы массива в строку, используя указанный разделитель. reverse(): Переворачивает порядок элементов в массиве на месте. sort(compareFunction): Сортирует элементы массива на месте в порядке, определяемом функцией сравнения. map(callback): Создает новый массив с результатами вызова функции для каждого элемента. forEach() выполняет предоставленную функцию один раз для каждого элемента массива. Этот метод не изменяет массив, но позволяет выполнить побочные эффекты или обработку каждого элемента. filter(callback): Создает новый массив со всеми элементами, прошедшими проверку, заданную функцией. reduce(callback, initialValue): Применяет функцию для накопления значения по массиву, возвращая единственное значение. find(callback): Возвращает первый элемент массива, который удовлетворяет условию, заданному в функции. findIndex(callback): Возвращает индекс первого элемента массива, который удовлетворяет условию, заданному в функции. every(callback): Проверяет, удовлетворяют ли все элементы массива условию, заданному в функции, возвращает true или false. some(callback): Проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в функции, возвращает true или false.",
    "codeexample":"",
    "images":[]
  },
  "j125":{
    "id":"08f36e147",
    "theme":"j",
    "question":"Что такое чистая функция?",
    "answer":"Это одна из концепций функционального программирования. В ней не должно быть побочных эффектов. Каждый раз она возвращает одинаковый результат, когда вызывается с тем же набором аргументов. Нечистая функция, например, может зависеть от какой-то внешней переменной и при вызове с одним же аргументом потенциально давать разные результаты.",
    "codeexample":"",
    "images":[]
  },
  "j126":{
    "id":"08f36e148",
    "theme":"j",
    "question":"Разница между .forEach() и .map()?",
    "answer":"Оба метода можно применять к массивам, чтобы перебирать их элементы и к каждому элементу применять выбранную функцию. При этом .forEach() перебирает массив и ничего не возвращает, а .map()перебирая массив, формирует и возвращает новый массив, который получен при выполнении функции. Результирующий массив можно присвоить в переменную и использовать дальше. Исходный массив ни тот ни другой метод не изменяют.",
    "codeexample":"",
    "images":[]
  },
  "j127":{
    "id":"08f36e149",
    "theme":"j",
    "question":"Разница между .call(), .apply() и bind()?",
    "answer":"Периодически внутри функции может использоваться ключевое слово this. В следствие ошибки или запутанности кода значение this может изменяться. Это называется потеря контекста. Для того чтобы этого избежать используются методы .call(), .apply() и bind() Методы .call(), .apply() и .bind() — это методы, которые позволяют управлять значением this внутри функции и задавать его вручную. Эти методы принадлежат всем функциям в JavaScript, так как каждая функция является объектом. Разница в том, что call() и apply() сразу вызывают функцию с заданным контекстом this, а bind() возвращает новую функцию с заданным контекстом this, которую можно вызвать позже. Основное различие между call() и apply() — это способ передачи аргументов (по отдельности или в массиве).",
    "codeexample":"",
    "images":[]
  },
  "j128":{
    "id":"08f36e150",
    "theme":"j",
    "question":"Почему в JS функции называют объектами первого класса?",
    "answer":"В JS любые типы данных ведут себя как объекты. У каждого типа данных есть набор методов, которые можно использовать. Функции также. Они обрабатываются также как любое другое значение: ее можно присвоить в переменную, она может быть свойством объекта (тогда она называется методом), ее можно передать в другую функцию в виде аргумента или вернуть из функции. ",
    "codeexample":"",
    "images":[]
  },
  "j129":{
    "id":"08f36e151",
    "theme":"j",
    "question":"Как определить наличие свойства в объекте?",
    "answer":"Три способа: 1) использование метода .hasOwnProperty() (obj.hasOwnProperty(‘prop’) / true or false), 2) применение оператора in (‘prop’ in obj / true or false) 3)обратиться к свойству напрямую (obj[‘prop’] / если его нет, то вернется undefined) ",
    "codeexample":"",
    "images":[]
  },
  "j130":{
    "id":"08f36e152",
    "theme":"j",
    "question":"Что такое IIFE (анонимная самовызывающаяся функция)?",
    "answer":"Она вызывается непосредственно после создания. Такой паттерн использовался до появления модулей ES6, чтобы избежать загрязнения  глобального пространства имен. Он применялся для создания поведения модуля. Переменные, созданные внутри функции не видимы в глобальной области видимости, и не засоряют глобальное пространство имен.",
    "codeexample":"",
    "images":[]
  },
  "j131":{
    "id":"08f36e153",
    "theme":"j",
    "question":"Что такое псевдомассив arguments?",
    "answer":"Это коллекция аргументов, которые передаются в функцию. Псевдомассивом его называют, потому что это объект подобный массиву. Кроме length другие методы массивов ему недоступны. С помощью него можно получить доступ к любому из аргументов, которые были переданы в функцию. В стрелочных функциях он недоступен. ",
    "codeexample":"",
    "images":[]
  },
  "j132":{
    "id":"08f36e154",
    "theme":"j",
    "question":"Разница между host-объектами и нативными объектами?",
    "answer":"Хост-объекты это объекты, которые предоставляются средой выполнения - то есть браузером - это например window, localstorage, document и тд Нативные объекты - это объекты, которые являются частью языка JS (String, Object, function и тд)",
    "codeexample":"",
    "images":[]
  },
  "j133":{
    "id":"08f36e155",
    "theme":"j",
    "question":"Почему результат сравнения 2х объектов это false?",
    "answer":"В JS механизмы сравнения примитивов и объектов отличаются. Примитивы сравниваются по значению, и если это строгое равенство (===), то дополнительно сравниваются типы. Объекты сравниваются по ссылке или адресу в памяти, где хранится переменная, соответственно, когда создаются объекты, даже если по внутренней структуре они одинаковы ссылки будут разные, поэтому сравнение двух одинаковых объектов или даже двух пустых объектов -  всегда false. Чтобы сравнение вернуло true переменной нужно присвоить ссылку на уже существующий объект.",
    "codeexample":"// Primitives\nconst a = 10;\nconst b = 20;\nconst c = 10;\nconsole.log(a === b); // false\nconsole.log(a === c); // true\n\n// Objects\nconsole.log({ a: 10 } === { a: 10 }); // false\nconsole.log({} === {});               // false\n\n// Equal odjects\nconst a = {a: 10 };\nconst b = a;\nconsole.log(a === b); // true",
    "images":[]
  },
  "j134":{
    "id":"08f36e156",
    "theme":"j",
    "question":"Что такое прототипное наследование? Как создать объект без прототипа?",
    "answer":"Все объекты в JavaScript имеют свойство Prototype, которая является ссылкой на другой объект. Когда к свойству объекта происходит обращение и если свойство не находится в текущем объекте, то механизм JavaScript просматривает прототип объекта и ищет это свойство там, затем он идет в прототип прототипа и так далее, до тех пор пока пока не найдет определенное свойство на одном из прототипов, или до тех пор пока не достигнет конца цепочки прототипов - это и есть прототипное наследование. Для того, чтоб создать объект без прототипа нужно воспользоваться Object.create(), внутрь которого в качестве аргумента передать null.",
    "codeexample":"// Inheritance\nconst a = { prop: \"Test\" };\nconst b = Object.create(a);\nconst c = Object.create(b);\nconsole.log(b);      // {}\nconsole.log(b.prop); // \"Test\"\nconsole.log(c);      // {}\nconsole.log(c.prop); // \"Test\"\n\n// Object with prototype\nconst e = {}\nconsole.log(e.toString) // [object Object]\n\n// Object without prototype\nconst f = Object.create(null);\nconsole.log(f.toString); // f.toString is not a function",
    "images":[]
  },
  "j135":{
    "id":"08f36e157",
    "theme":"j",
    "question":"Разница между классовым и прототипным наследованием?",
    "answer":"Классовое или классическое наследование - это механизм исследования, при котором экземпляры наследуется от классов, а также создаётся иерархическая система классов или подклассовые отношения. Экземпляры реализуются через конструктор функции через дискриптор new. Также экземпляр класса может не содержать дескриптор-класс начиная с версии ES6. Прототипное наследование - это механизм наследования, при котором экземпляры наследуется напрямую от других объектов, реализуется данный подход через фабрики или метод object create. Экземпляры могут быть составлены из множества различных объектов для упрощения выборочного насследования. К плюсам прототипного наследованием можно отнести: простота, если сравнивать с классовым; слабая связь: экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип. С прототипным наследованием легко поддерживать плоские иерархии используя конкатенацию, выборочное использование свойств одного объекта для создания другого и делегирование клонирования одного объекта в другой. Гибкая архитектура: поскольку можно выборочно наследоваться, больше не нужно беспокоиться о проблеме не правильного дизайна - новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/za3e0bpitk24zqynm7fie/main-qimg-e5427ba8cf6565194055be162060d83a-lq.webp?rlkey=4i9caeg37yq9d1ynzhghsp0v2&st=shb9ijv8&dl=1"]
  },
  "j136":{
    "id":"08f36e158",
    "theme":"j",
    "question":"Что такое SOLID?",
    "answer":"SOLID - аббревиатура для обозначения пяти принципов, которые используются в ООП. Общая идея говорит о том, что использование сразу нескольких принципов как единого целого намного лучше, чем использование по отдельности. Принципы SOLID: Принцип единой ответственности. У модуля должна быть только одна причина для изменения или класс должен отвечать только за что-то одно. Основная идея - это организовать свой код таким образом, чтобы в случае возникновения изменения  задействовать наименьшее количество модулей. Принцип открытости и закрытости. Модуль должен быть открыт для расширения, но закрыт для изменения.  Основная идея - это разработка устойчивого к изменениям приложения и закладывания такой архитектуры, чтобы небольшое изменение класса не затрагивала кучу связанных с ним модулей. Принцип подстановки Барбары Лисков. Необходимо, чтобы подклассы могли служить заменой для своих суперклассов, другими словами функции, использующие базовый тип должны иметь возможность использовать его подтипы. Основная цель - это проектировать логику таким образом, чтобы классы наследники могли использовать методы родителей. Принцип разделения интерфейсов. Сущности не должны зависеть от интерфейсов, которые не используют. Принцип инверсии зависимостей. Модули высших уровней не должны зависеть от модулей низких уровней, оба должны зависеть от абстракции, абстракции не должны зависеть от деталей, детали должны зависеть от абстракции.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/azrvoxeakhbr7v4y9jviz/Colorful-Diamond-Cycle-Map.webp?rlkey=2dn4kljy0lkx7485cshcduau3&st=72nqpw6n&dl=1"]
  },
  "j137":{
    "id":"08f36e159",
    "theme":"j",
    "question":"Какие ещё принципы кроме SOLID вы знаете?",
    "answer":"SOLID - это основной принцип объектно ориентированного программирования. Однако помимо него также есть принципы DRY - расшифровывается, как don’t repeat yourself - \"не повторяйся\", также известен как DIE или duplication is evel \"дублирование - это зло\". Этот принцип заключается в том, что нужно избегать повторений одного и того же кода, лучше использовать универсальные свойства и функции. KISS - keep it simple stupid, то есть \"не усложняй\". Смысл заключается в том, что стоит делать максимально простую и понятную архитектуру, применять шаблоны проектирования и не изобретать велосипед. YAGNI значит You aren't gonna need it \"вам это не понадобится\". Его суть в том, чтобы реализовывать только поставленные задачи и отказаться от избыточного функционала. APO или Avoid Premature Optimization - \"избегайте преждевременной оптимизации\" - это практика призывает разработчиков не оптимизировать код до того, как эта необходимость будет доказана. Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функции на рынок.",
    "codeexample":"",
    "images":[]
  },
  "j138":{
    "id":"08f36e160",
    "theme":"j",
    "question":"Однонаправленный поток данных и двусторонняя связь данных? В чем между ними разница?",
    "answer":"Эта концепция активно используется в архитектуре современных библиотек и фреймовков. Однонаправленный поток данных означает что только модель - это источник истины. Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание. Любые изменения в интерфейсе запускают события, которые сообщают пользователю о намерении модели. Для простоты понимания в ряде приложений такой моделью может быть state. Двухсторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, другими словами, при изменении интерфейса происходят изменения моделей и наоборот.Однонаправленные потоки данных чётко определены и по иерархии элементов идут сверху вниз то есть от родителя потомку. В то время как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/xuh0faary3xykghd0axoe/vue-vs-react-data-flow.webp?rlkey=3vw2t6uxozsdlue6xoiav9u52&st=pgd5h99y&dl=1"]
  },
  "j139":{
    "id":"08f36e161",
    "theme":"j",
    "question":"Почему расширение нативных JavaScript-объектов это плохая практика?",
    "answer":"JavaScript использует механизм прототипного наследования,то есть если свойство или метод не найдены в текущем объекте, то поиск будет осуществляться дальше по цепочке прототипов. Расширение нативных JavaScript-объектов означает добавление новых свойств или методов его прототипу. Расширив текущую версию прототипа кастомное свойство может вступить в конфликт с вновь добавленным. Можно получить сложную реализацию логики из-за добавленных свойств, которые используются только в одном проекте. Единственным решением расширения нативных JavaScript-объектов является создание полифила для старых браузеров.",
    "codeexample":"",
    "images":[]
  },
  "j140":{
    "id":"08f36e162",
    "theme":"j",
    "question":"Что такое NaN? Как определить, что значение равно NaN?",
    "answer":"NaN (not a number) - значение представляющее не число. Это не настраиваемое и не записываемое свойство глобального объекта. Оно получается когда математическая функция сработала неверно. NaN не равно любому другому, включая саму себя. Для того чтобы проверить является ли значение не числом используют функцию isNaN(), в качестве аргумента принимает проверяемую величину, а результатом работы возвращает boolean-значение.",
    "codeexample":"// NaN\nconsole.log(parseInt('test')); // NaN\nconsole.log(Math.sqrt(-1));    // NaN\n\nconsole.log(NaN === NaN);    // false\nconsole.log(NaN == NaN);       // false\nconsole.log(isNaN (NaN));      // true",
    "images":[]
  },
  "j141":{
    "id":"08f36e163",
    "theme":"j",
    "question":"Что такое временная мёртвая зона (temporal dead zone)?",
    "answer":"Одной из отличительной из особенностей между старым var и новыми let и const, является то, что var может “всплывать”, тем самым вызывая его до объявления получается undefined. Вызов значений let и const до их объявлений вызывает ошибку. Если немного углубиться, то механизм их работы описывает так называемая “временная мертвая зона”.  Дело в том, что  let и const на самом деле “всплывают” точно так же как и var, но для того, что того, чтобы отлавливать ошибки в ES6 для переменных констант создали “temporal dead zone”. Это значит, что переменные будут созданы когда интерпретатор зайдет в область видимости, но они будут недоступны до тех пор пока выполнение кода не дойдет до места их фактического объявления и только в этот момент произойдет выход из временной мертвой зоны.",
    "codeexample":"// START - temporal dead zone for 'b' and 'c'\nconsole.log(a); // undefined\nconsole.log(b); // ReferenceError: b is not defined 4 console.log(c); // ReferenceError: c is not defined\n\nvar a= 10;\n// END - temporal dead zone for 'b'\nlet b = 20;\n// END - temporal dead zone for 'c'\nconst c = 30;",
    "images":[]
  },
  "j142":{
    "id":"08f36e164",
    "theme":"j",
    "question":"Что такое объектная обертка (Wrapper Objects)?",
    "answer":"Понятие объектная обертка тесно связана со спецификой языка JavaScript . В JS основные типы данных - это примитивы и объекты/ Тем не менее даже у примитивов есть свои методы. Например, если применить к строке name применим метод .toUpperCase(), то результатом работы получим не ошибку, а трансформированное в верхний регистр слово. Такое поведение возможно благодаря объектной обертке, то есть момент исполнения кода этот примитив временно преобразуется в объект. Это аналогично тому, как если бы в момент применения метода использовался конструктор new String(). У каждого примитива, кроме null и undefined, есть такой объект-обертка. ПОсле работы со свойством или методом временный объект отбрасывается.",
    "codeexample":"// Primitive\nconst name = \"Elen\";\nconsole.log(typeof name); // string\n\n// No errors\nconsole.log(name.toUpperCase());             // \"ELEN\"\n// Wrapper Object 'String'\nconsole.log(new String(name).toUpperCase()); // \"ELEN\"",
    "images":[]
  },
  "j143":{
    "id":"08f36e165",
    "theme":"j",
    "question":"Можно ли изменить значение определенное через const?",
    "answer":" С появлением ES6 определять различные значения можно благодаря let и const. let унаследовала функциональность var, то есть переменная переданная через let в процессе выполнения скрипка может быть переопределена. const - это константа, то есть при попытке переопределения значения происходит ошибка. Однако,  если речь идет об объекте, то его свойства и методы могут быть изменены, а вот переназначение объекта в const по прежнему вызывает ошибку, это происходит потому что в саму const записывается записывается не значение, а ссылка на объект. Объект хранится в области оперативной памяти.",
    "codeexample":"// Reassign Error\na = { a: 20 }; // Uncaught TypeError: Assignment to constant variable.\n// Adding Property\na.b = 20\nconsole.log(a); // { a: 10, b: 20 }\n\n// Array\nconst c = [];\n// Reassign Error\nc = {}; // Uncaught TypeError: Assignment to constant variable.\n// Adding Values\nc.push(5);\nc.push(10);\nconsole.log(c); // [5, 10]",
    "images":[]
  },
  "j144":{
    "id":"08f36e166",
    "theme":"j",
    "question":"Как в JavaScript создать объект?",
    "answer":"Для того, чтобы создать JavaScript  существует три основных метода:\n\t1.Объектный литерал;\n\t2.Функция конструктор;\n\t3.Использование метода Object.create()",
    "codeexample":"// Object Literal\nconst person1 = {\n\tname: \"Anna\",\n}\nconsole.log(person1.name); // \"Anna\"\n\n// Function Constructor\nfunction Person(name) {\n\tthis.name name\n}\nconst person2 = new Person('Mary');\nconsole.log(person2.name); // \"Mary\"\n\n// Method 'Object.create'\nconst person3 = Object.create(person1); 16 person3.name = 'Inna';\nconsole.log(person3.name); // \"Inna\"",
    "images":[]
  },
  "j145":{
    "id":"08f36e167",
    "theme":"j",
    "question":"Для чего используется ключевое слово new?",
    "answer":"В JavaScript  для создания объектов используется несколько методов. Один из них - использование функции конструктора, которая вызывается со специальным словом new. Результатом выполнения получается новый объект (экземпляр класса).\nКлючевое слово new выполняет следующее:\n\t1.Создает пустой объект.\n\t2.Привязывает к созданному объекту значение this, то есть this указывает на вновь созданный объект.\n\t3.Функция устанавливает внутреннее недоступное свойство этого нового объекта prototype как внешний доступный объект прототип функции конструктора, то есть каждый объект, созданный функцией, автоматически получает свойство prototype.\n\t4.Возвращает значение this, если в реализации не указано другое.",
    "codeexample":"function Employee (name, position) {\n\tthis.name = name;\n\tthis.position = position;\n};\n\nconst person = new Employee ('Irina', 'Front-end dev');\nconsole.log(person.name);     // \"Irina\"\nconsole.log(person.position); // \"Front-end dev\"",
    "images":[]
  },
  "j146":{
    "id":"08f36e168",
    "theme":"j",
    "question":"Операторы «И» и «ИЛИ» (&& и ||)?",
    "answer":"В JS есть три логических оператора (&&, ||,  !). “И” (&&) находит и возвращает первое ложное значение, или последний операнд, когда все значения истинные). То есть как только находится первое подходящее значение, дальнейшая проверка не выполняется.  “ИЛИ” (||) возвращает первое истинное значение или последнее значение, если все операторы ложны. Для && выполнение прекращается, если найден ложный операнд. Для || выполнение прекращается, если найден истинный операнд.",
    "codeexample":"",
    "images":[]
  },
  "j147":{
    "id":"08f36e169",
    "theme":"j",
    "question":"Для чего используется оператор двойного отрицания (!!)?",
    "answer":"Оператор двойного отрицания (!!) используется для приведения значения, которая находится справа от него, к логическому типу. Таким образом используя его с каким-либо типом данных, например, null, undefined, строки, числа и т.д. на выходе получаем либо true, либо false.",
    "codeexample":"\nconsole.log(!!null);      // false\nconsole.log(!!undefined); // false\nconsole.log(!! '');       // false\nconsole.log(!!0);         // false\nconsole.log(!!'str');     // true\nconsole.log(!!100);       // true\nconsole.log(!!{});        // true\nconsole.log(!![]);        // true\n\n//Еще одним способом преобразования типом к логическому значению служит объект Boolean.\nconsole.log(Boolean (null));      // false\nconsole.log(Boolean (undefined)); // false\nconsole.log(Boolean('str'));      // true\nconsole.log(Boolean (100));       // true",
    "images":[]
  },
  "j148":{
    "id":"08f36e170",
    "theme":"j",
    "question":"Для чего используется оператор остатка (%)?",
    "answer":"Периодически в JS возникает необходимость получить остаток двух чисел, таким образом может проверять кратность. В JS основной способ проверки кратности - это оператор остатка (%). Данный оператор возвращает остаток от деления двух чисел. Если в остатке есть какое-то число отличное от 0, значит число не кратный, если 0, значит число кратный.",
    "codeexample":"\nconsole.log(5 % 2);  // 1\nconsole.log(4 % 2);  // 0 - 4 multiple of 2\nconsole.log(7 % 3);  // 1\nconsole.log(8 % 3);  // 2\nconsole.log(8 % 4);  // 2 - multiple of 4\n\n/*Если делимое число меньше делителя, то нацело оно не делится, результатом получается 0, а в остатке остается делимое число.*/\nconsole.log(1 % 7);  // 1\nconsole.log(3 % 7);  // 3",
    "images":[]
  },
  "j149":{
    "id":"08f36e170",
    "theme":"j",
    "question":"Как проверить, является ли значение массивом?",
    "answer":"Чтобы проверить является значение массивом используются метод Array.isArray(), внутрь которого передаете значение, и на выходе метод возвращает булевое значение. true, если данное представляет массив, false, если не массив.",
    "codeexample":"\n// No array\nconsole.log(Array.isArray(null));       // false\nconsole.log(Array.isArray (undefined)); // false\nconsole.log(Array.isArray(''));         // false\nconsole.log(Array.isArray (100));       // false\nconsole.log(Array.isArray({}));         // false\n\n// Array\nconsole.log(Array.isArray([]));         // true\nconsole.log(Array.isArray([1, 2, 3]));  // true",
    "images":[]
  },
  "j150":{
    "id":"08f36e172",
    "theme":"j",
    "question":"Как работает boxing/unboxing в JavaScript",
    "answer":"Термины упаковки и распаковка или boxing, unboxing пришли JavaScript из других языков программирования. На практике данный механизм тесно связан с понятием объект-обертка.\nЕсли у примитивного значения, например, строки мы вызываем метод  несмотря на то, что метод вызывается не у объекта, а у примитива это не вызывает ошибку. Происходит это благодаря объекту-обертки new String(), вызов которого происходит не явно. Этот объект оборачивает примив и вызывает метод, после исполнения объект уничтожается, а нам возвращается результат работы. Этот процесс получил название boxing (упаковка). Такое оборачивание может быть нативным, когда оно идет “под капотом”, а может быть явным, когда мы самостоятельно оборачиваем примитив в конструктор.",
    "codeexample":"// Boxing\nconst name = \"Alice\";\nconsole.log(typeof name);            // \"string\"\nconsole.log(name.toUpperCase());     // string=>String=>String.function=> string\n\n// Explicit boxing\nconst name = new String(\"Alice\");\nconsole.log(typeof name);            // \"object\"\nconsole.log(name.toUpperCase());     // String.function\n\n/*Распаковка (unboxing) - это преобразование ссылочных типов, т.е. объектов в базовые типы данных, т.е. в примитивы. Для данной цели можно использовать такие методы как valueOf() или toString()*/.\n\n// Unboxing\nconst age = new Number (32);\nconst name = new String(\"Alice\");\nconsole.log(typeof age);             // \"object\"\nconsole.log(typeof name);            // \"object\"\n\nconsole.log(typeof age.valueOf()); // \"number\" basic number type\nconsole.log(typeof age.toString());  // \"string\" basic character type\nconsole.log(typeof name.valueOf());  // \"string\" basic data type\nconsole.log(typeof name.toString()); // \"string\" basic data type",
    "images":[]
  },
  "j151":{
    "id":"08f36e173",
    "theme":"j",
    "question":"Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?",
    "answer":"Мемоизация - это прием создания функции способной запомнить ранее вычисленное значение, а также результат.  При повторном вызове функции  с одинаковыми аргументами она не будет выполнена, а результат работы вернется из кэша. Это является плюсом использования подобных функций. К минусам можно отнести то, что для хранения всех полученных результатов нужно выделять дополнительную память. На примере создается функция, внутри которой используя замыкание в const cashe хранятся результаты. Каждый раз когда вызывается мемоизированная функция происходит проверка, если кэш хранит ключ, которому соответствует передаваемая в функцию аргумент, то возвращается сохраненный результат, если такого ключа нет, то дополнительно при возврате результата в объекте  cashe создается новое поле с ключем аргумента и свойством результата. При повторном вызове мемоизированное значение просто вернется из функции.",
    "codeexample":"\nconst memoize = (fn) => {\n\tconst cache = {}\n\treturn function(param) {\n\t\tif(cache[param]) {\n\t\t\treturn cache[param];\n\t\t} else {\n\t\t\tconst result = fn(param);\n\t\t\tcache[param] = result;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n// Base function\nconst toUpper = (str = '') => str.toUpperCase();\n// Memoized base function\nconst toUpperMemoized = memoize(toUpper);\n\ntoUpper Memoized('Yauhen'); // Call function 'toUpper', get result\ntoUpper Memoized('Yauhen'); // Doesn't call 'toUpper', return result from 'cache'",
    "images":[]
  },
  "j152":{
    "id":"08f36e174",
    "theme":"j",
    "question":"Разница между оператором in и методом .hasOwnProperty()?",
    "answer":"Оба подхода предназнены для проверки наличия определенного свойства в объекте. Разница между ними заключается в том, что оператор in проверяет наличие свойства не только в самом объекте, но и в его прототипах, в то время как метод .hasOwnProperty() проверяет наличие свойства только в основном объекте.",
    "codeexample":"const test = new Object();\ntest.prop = 'just test';\n\nconsole.log('prop' in test);  // true\nconsole.log('toString' in test);  // true\n\nconsole.log(test.hasOwnProperty('prop'));    // true\nconsole.log(test.hasOwnProperty( 'toString')); // false",
    "images":[]
  },
  "j153":{
    "id":"08f36e175",
    "theme":"j",
    "question":"Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?",
    "answer":"В JavaScript есть два способа передачи и копирования: по значению и по ссылке. Когда копирование происходит по значению, это значит, что создается новое отдельное и независимое значение подобное оригиналу. Когда копирование происходит по ссылке, то новая сущность не создается, а по сути происходит создание псевдонима для уже существующего значения. Такой вариант копирования называется поверхностным.\nПри глубоком копировании, так как создается независимая копия, при изменений свойств в копируемом объекте копия сохраняет свое значение. При поверхностном копировании, при внесении изменений в копируемый объект, копия так же изменяют свои значения, так как по сути являются только ссылкой. Если изменить копию изменится и оригинал.\nДля того, чтобы сделать поверхностную копию объекта его достаточно присвоить в новую переменную.\nДля создания глубокого копирования можно использовать следующие варианты:\n\t1.spread operator;\n\t2.Метод Object.assign();\n\t3.Комбинацию JSON.parse() и JSON.stringify()/",
    "codeexample":"// Shallow\nconst car1 = {\n\tcolor: \"red\",\n\twheels : 4,\n};\n// Copy\nconst car2 = carl;\ncar2.color = \"black\";\nconsole.log(car1.color);   /* black */\nconsole.log(car2.color); /* black */\n\n// Deep\nconst car1 = {\n\tcolor \"red\"\n\twheels: 4,\n};\n// Copy (spread)\nconst car2 = {...car1};\n// Copy (Object.assign)\nconst car2 = Object.assign({}, car1);\n// Copy (JSON.parse() & JSON.stringify())\nconst car2 = JSON.parse(JSON.stringify(car1)); car2.color = \"black\";\nconsole.log(car1.color); /* red */\nconsole.log(car2.color); /* black */",
    "images":["https://www.dropbox.com/scl/fi/ez3hnk2jozuixfjohpani/objectclone.webp?rlkey=v8ylem1gjo8jgx0h8t59c1ja7&st=epgvv4cp&dl=1"]
  },
  "j154":{
    "id":"08f36e176",
    "theme":"j",
    "question":"Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?",
    "answer":"Сhaining или цепочка вызовов - это подход, при котором методы объекта вызывается один за другим без дополнительного обращения к исходному объекту. В нативной реализации JS,например, это некоторые методы строк и массивов. При использовании промисов это методы then() и catch(). Для того, чтобы реализовать такую возможность самостоятельно, можно использовать замыкание, либо из метода возвращать контекст вызова или ключевое слово this.",
    "codeexample":"// Native chaining\n'test'.split('').reverse().join('').toUpperCase();\n\n// Promise chaining\nmyPromise.then(test1).then(test2).catch(handleRejected);\n\n// Custom chaining\nconst counter = {\n\tcount: 0,\n\tplusOne() {\n\t\tthis.count++;\n\t\treturn this;\n\t},\n\tminusOne() {\n\t\tthis.count--;\n\t\treturn this;\n\t},\n\tshowResult() {\n\t\tconsole.log(this.count);\n\t\treturn this;\n\t}\n}\ncounter.plusone (). plusOne(). minusOne().plusOne(). minusOne().showResult();",
    "images":[]
  },
  "j155":{
    "id":"08f36e177",
    "theme":"j",
    "question":"Что такое необъявленная переменная?",
    "answer":"Необъявленная переменная создается при определении значения идентификатору, который не был объявлен с использованием ключевых слов var, let или const. Необъявленные переменные, объявляются за пределами текущей области видимости в глобальной области видимости. Таким образом они получают возможность быть видимыми в любом месте кода. Их  использование, так же как использование глобальных переменных, считается плохой практикой, так как из глобальной области к ним можно  получить свободный доступ и нарушить выполнение программы. В строгом режиме при попытке добавления значения необъявленной переменной будет выброшено ислючение ReferenceError.",
    "codeexample":"function func() {\n\tx = 'test';      // ReferenceError in 'use strict'\n}\n\nfunc();\nconsole.log(x);    // test",
    "images":[]
  },
  "j156":{
    "id":"08f36e178",
    "theme":"j",
    "question":"Как передаются параметры в функцию: по ссылке или по значению?",
    "answer":"Параметры, которые передаются в функцию всегда передаются по значению. Однако переменная представляющая объекты записаны ссылки на эти объекты, поэтому когда в функцию передают объект и изменяют свойство этого объекта это изменение сохраняется в объекте при выходе из функции. Поэтому может возникнуть ощущение того, что параметры в фунцию передают по ссылке, но если изменить значение переменной, представлющая объект,  то это изменение никак не повлияет объект, находящийся за пределами функций.",
    "codeexample":"function changeStuff (a, b, c) {\n\ta = a * 10;\n\tb.item = \"changed\";\n\tc = { item: \"changed\"\n};\n\nvar num = 10;\nvar obj1={ item: \"unchanged\" };\nvar obj2 = { item: \"unchanged\" };\n\nchangeStuff (num, objl, obj2);\n\nconsole.log(num);       // 10\nconsole.log(obj1.item); // \"changed\"\nconsole.log(obj2.item); // \"unchanged\"",
    "images":[]
  },
  "j157":{
    "id":"08f36e179",
    "theme":"j",
    "question":"Разница между функцией и методом?",
    "answer":"Функция - это фрагмент кода, который вызывается по имени и не связан с каким-либо объектом, и не определен внутри объекта. В функцию могут быть переданы данные для работы, то есть параметры и при желании могут быть возвращены данные. Метод - это фрагмент кода, который вызывается по имени и определяется внутри объекта он почти идентичен функции за исключением того что он всегда связан с объектом и работает только с данными внутри него.",
    "codeexample":"",
    "images":[]
  },
  "j158":{
    "id":"08f36e180",
    "theme":"j",
    "question":"Что такое прототип объекта в JavaScript?",
    "answer":"Объекты в JavaScript можно организовать в цепочке таким образом, чтобы свойства не найденные в одном объекте автоматически искалось бы в другом, т.е. прототипе. Для реализации такой цепочки есть специальное свойство, которое называется proto, если один объект имеет специальное ссылку proto на другой объект, то при чтении свойства из него если свойство отсутствует в самом объекте оно ищется в объекте proto, другими словами прототип - это резервное хранилище свойств и методов объекта, которая автоматически используется при поиске. Минус такого подхода в том, что он не поддерживается Internet Explorer ниже 10 версии. Однако в JavaScript имеется альтернативный встроенный в язык и полностью кроссбраузерный способ -  чтобы новым объектам автоматически ставить прототип конструктору ставится свойство prototype. При создании объекта через new его прототип proto записывается ссылка из prototype функции-конструктора.",
    "codeexample":"const admin = {\n\tadmin: true,\n};\nconst person = {\n\tuser: true,\n};\n\nperson.__proto__ = admin;\n\nconsole.log(person.user);  // true\nconsole.log(person.admin); // true\n\nconsole.log(person.hasOwnProperty ('user'));   // true\nconsole.log(person.hasOwnProperty( 'admin') ); // false (property from prototype 'admin')",
    "images":[]
  },
  "j159":{
    "id":"08f36e181",
    "theme":"j",
    "question":"Как работает метод Object.create()?",
    "answer":"метод object.create() в ES5 - это самый простой способ наследования одного объекта от другого без вызова функции конструктора в качестве аргумента. Метод принимает объект от которого будет происходить наследование в приведённом примере мы создаём новый объект emp1, который наследуется от объекта employee, другими словами прототип emp1 установлен на employee. После этого emp1 сможет получить доступ ко всем свойствам и методам employee, а также он может добавить новые или переопределить существующие задав новое свойство или методы с тем же именем. В дополнение к этому в методе Object.create также можно указать второй аргумент, который является объектом содержащим дополнительные свойства и методы для добавления к новому объекту, т.е. передав в метод дополнительный объект, его значениями можно расширить результирующий объект наследник или же переопределить некоторые свойства и методы.",
    "codeexample":"// ES5\nvar employee = {\n\tname: 'Ann',\n\tdisplayName: function () {\n\t\tconsole.log(this.name);\n\t}\n};\nvar emp1 = Object.create(employee);\nconsole.log(emp1.displayName());\n\n// Extend created object\nvar emp1 = Object.create(employee, {\n\tname: {\n\t\tvalue: 'Nadia'\n\t}\n});\n\nemp1.displayName();   // \"Nadia\"\nemployee.displayName(); // \"Ann\"",
    "images":[]
  },
  "j160":{
    "id":"08f36e182",
    "theme":"j",
    "question":"Разница между Object.freeze() и Object.seal()?",
    "answer":"Object.seal(): Предотвращает добавление или удаление свойств из защищенного объекта, использование delete в этом случае вернет false; Делает каждое существующее свойство не конфигурируемым, то есть они не могут быть преобразованы из дескрипторов данных, дескрипторы доступа и наоборот, а также никакой атрибут дескрипторов доступа не может быть изменен вообще, тогда когда как дескрипторы данных могут изменить свой writeable и их атрибуты, если у writeable  определено значение true; Может выдавать type error в строгом режиме при попытке изменить значение самого защищенного объекта. Object.freeze() делает все то же самое, что и Object.seal() плюс предотвращает изменение любых существующих свойств.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/tdgseggohhwb5ciiry3kc/https___dev-to-uploads.s3.amazonaws.com_i_wssueapx8jykyx0rkixk.webp?rlkey=tjraz55yx7zya7yev522540p3&st=fbztdiob&dl=1"]
  },
  "j161":{
    "id":"08f36e183",
    "theme":"j",
    "question":"Разница между методами .slice() и .splice()?",
    "answer":"Оба метода используется для работы с массивами. Метод slice возвращает выбранные элементы массива в виде нового массива, а метод splice используется для добавления или удаления элементов в или из массива. Главное отличие заключается в следующем: slice не изменяет исходный массив, splice изменяет, slice возвращает подмассив исходного массива, splice  возвращает удалённые элементы в виде массива, slice служит только для извлечения элементов из массива, splice служит для добавления и удаления элементов в и из массива.",
    "codeexample":"// slice\nconst arrayIntegers = [1, 2, 3, 4, 5];\n\nconst arrayIntegers1 = arrayIntegers.slice(0, 2);   // [1, 2]\nconst arrayIntegers2 =  arrayIntegers.slice(2, 3);    // [3]\nconst arrayIntegers3 = arrayIntegers.slice(4);          // [5]\n\n// splice\nlet arrayOriginall = [1, 2, 3, 4, 5];\nlet arrayOriginal2 = [1, 2, 3, 4, 5];\nlet arrayOriginal3 = [1, 2, 3, 4, 5];\n\nlet array1 = arrayOriginal1.splice(0, 2);\n// return [1, 2]; base array [3, 4, 5]\n\nlet array2 = arrayOriginal2.slice(3);\n// return [4, 5]; base array [1, 2, 3]\nlet array3 = arrayOriginal3.slice(3, 1, 'a', 'b', 'c');\n// return [4]; base array [1, 2, 3, 'a', 'b', 'c']",
    "images":[]
  },
  "j162":{
    "id":"08f36e184",
    "theme":"j",
    "question":"Как работают методы .find(), .findIndex() и .indexOf()?",
    "answer":"Все три метода используются для поиска элементов в массиве. Метод .find() возвращает первый элемент массива, соответствующий заданному критерию. Этот метод найдя первый подходящий элемент не продолжает дальнейший поиск массиву. В качестве аргумента он принимает функцию. Метод .findIndex() похож на .find(), но он вместо, что возвращать первый подходящий элемент массива, возвращает индекс такого элемента.В качестве передаваемого аргумента принимает функцию. Метод .indexOf() похож на .findIndex(), но в отличие от двух предыдущих принимает в качестве аргумента значение. Использовать его нужно в том случае, если при поиске нужного элемента не нужна сложная логика.",
    "codeexample":"\n// find\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst found arr.find(el => el > 5);\nconsole.log(found);   // 6\n\n// findIndex\nconst arr = [\"Inga\", \"Alla\", \"Iren\", \"Diana\"];\nconst foundIndex = arr.findIndex (el => el === \"Alla\");\nconsole.log(foundIndex); // 1\n\n// indexOf\nconst arr = [\"Inga\", \"Alla\", \"Iren\", \"Diana\"];\nconst foundIndex = arr.indexOf(\"Alla\");\nconsole.log(foundIndex);  // 1",
    "images":[]
  },
  "j163":{
    "id":"08f36e185",
    "theme":"j",
    "question":"Плюсы и минусы использования use strict?",
    "answer":"Use strict - это директива, которая используется для включения строго режима во всем скрипте или отдельных функциях. К преимуществам использования можно отнести: не позволяет случайно создавать глобальные переменные; любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение; при попытке удалить неудаляемые свойства выдаст исключение; требует, чтобы имена параметров функции были уникальными; this в глобальной области видимости равно undefined; перехватывает распространение ошибки, выдавая исключение; исключает неочевидные особенности языка. Минусы: нельзя использовать некоторые особенности языка; нет доступа к function.caller и function.arguments; объединение скриптов в строгом режиме может вызвать проблемы.",
    "codeexample":"",
    "images":[]
  },
  "j164":{
    "id":"08f36e186",
    "theme":"j",
    "question":"Разница между методами .push(), .pop(), .shift() и .unshift()?",
    "answer":"Методы .push(), .pop(), .shift() и .unshift() используются для работы с массивами, добавляя или удаляя элементы. Метод .push() добавляет один или несколько элементов в конец массива и возвращает новую длину массива. Метод .pop() удаляет последний элемент массива и возвращает его. Метод .shift() удаляет первый элемент массива и возвращает его. Метод .unshift() добавляет один или несколько элементов в начало массива и возвращает новую длину массива. Методы, которые работают с концом массива (.push() и .pop()), более эффективны с точки зрения производительности, так как они не требуют пересчета индексов элементов, в отличие от методов, работающих с началом массива (.shift() и .unshift()).",
    "codeexample":"",
    "images":[]
  },
  "j165":{
    "id":"08f36e187",
    "theme":"j",
    "question":"Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?",
    "answer":"Иммутабельность (immutability) — это концепция, согласно которой объект или структура данных не может быть изменена после своего создания. Вместо изменения существующего объекта создается его новая версия с изменениями, оставляя исходный объект нетронутым. Плюсы иммутабельности: Предсказуемость: Поскольку объекты не меняются, легче предсказать поведение программы. Безопасность: Уменьшается вероятность появления ошибок, связанных с изменением состояния объектов в разных частях программы. Тестируемость: Тестировать иммутабельный код проще, так как исходные данные не изменяются. Отладка: Легче отслеживать состояние программы во времени, так как каждое изменение приводит к созданию нового объекта. Минусы: Производительность: При создании новых объектов на основе старых вместо их изменения требуется больше памяти и времени, особенно при работе с большими данными. Усложнение кода: В сложных структурах данных требуется более сложное управление копированием объектов (например, глубокое клонирование). Требуются дополнительные библиотеки: Иногда для удобства работы с иммутабельностью могут понадобиться сторонние библиотеки, такие как Immutable.js или immer. Чтобы достичь иммутабельности можно использовать const и метод Object.freeze(), или использовать дополнительные библиотеки.",
    "codeexample":"",
    "images":[]
  },
  "j166":{
    "id":"08f36e188",
    "theme":"j",
    "question":"Типы всплывающих окон в JavaScript?",
    "answer":"Существует три типа модальных окон, которые JS поддерживает нативно и которые можно использовать для взаимодействия с пользователем. Это alert - выводит диалоговое окно с кнопкой Ok, используется чтобы информировать пользователя, что что-то произошло. Confirm - отображает диалоговое окно с кнопками ok и cancel. Пользователь может подтвердить или отклонить свой выбор. И prompt - диалоговое окно с кнопками ok и cancel, а также с полем для ввода данных. С помощью него можно получить какую-то дополнительную информацию от пользователя.",
    "codeexample":"",
    "images":[]
  },
  "j167":{
    "id":"08f36e1189",
    "theme":"j",
    "question":"Типы объектов JavaScript?",
    "answer":"Можно выделить 9 основных типов объектов: объект массива (используется для хранения упорядоченных коллекций данных), строковый объект (используется для работы со строковыми значениями), объект даты (используется для манипулирования датой и временем), числовой объект (работает с числовыми данными), логический объект (предоставляет истинные или ложные значения), функциональный объект (представляет функции), объект Math (содержит математические константы и функции, используется для выполнения математических операций), объект RegExp (представляет регулярные выражения, которые используются для поиска и сопоставления текста по заданным шаблонам), объект Object (базовый объект, от которого наследуются все другие объекты в JavaScript. Используется для создания пользовательских объектов с определенными свойствами и методами.)",
    "codeexample":"",
    "images":[]
  },
  "j168":{
    "id":"08f36e190",
    "theme":"j",
    "question":"Парадигмы программирования в JavaScript?",
    "answer":"JavaScript поддерживает несколько парадигм программирования, включая объектно-ориентированное программирование (ООП) и функциональное программирование (ФП). Объектно-ориентированное программирование (ООП): Наследование: Позволяет одному объекту наследовать свойства и методы другого объекта, что способствует повторному использованию кода. Инкапсуляция: Объединяет данные и методы, которые работают с этими данными, внутри объекта, ограничивая доступ к ним извне. Полиморфизм: Позволяет методам работать с объектами разных типов, обеспечивая их гибкость и универсальность. Абстракция: Позволяет скрывать сложные детали реализации и предоставлять простой интерфейс для взаимодействия с объектом. Функциональное программирование (ФП): Чистые функции: Функции, которые не имеют побочных эффектов и возвращают одно и то же значение при одинаковых входных данных. Иммутабельность: Данные не изменяются после их создания; любые изменения данных приводят к созданию новых объектов. Ссылочная прозрачность: Вызовы функций с одинаковыми аргументами всегда возвращают одинаковые результаты, что делает код предсказуемым и легко тестируемым. Замыкание: Механизм, позволяющий функции запоминать контекст, в котором она была создана, и доступ к переменным этого контекста. Функции первого класса: Функции в JavaScript могут быть переданы как аргументы другим функциям, возвращены из функций, а также присвоены переменным. Функции высшего порядка: Функции, которые принимают в качестве аргументов другие функции или возвращают их.",
    "codeexample":"",
    "images":[]
  },
  "j169":{
    "id":"08f36e191",
    "theme":"j",
    "question":"Что такое функциональное программирование?",
    "answer":"Функциональное программирование - это парадигма программирования, в которой процесс вычисления трактуется, как вычисление значения функций, противопоставляется в парадигме императивного программирования, которое описывает процесс вычисления, как последовательное изменение состояний при необходимости. В функциональном программировании вся совокупность последовательных состояний вычислительного процесса предоставляется явным образом, например, как список. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций и не предполагает явного хранения состояния программой, соответственно не предполагает оно и изменяемость этого состояния в отличие от императивного, где одной из базовых концепций является переменная хранящая своё значение и позволяющая менять его по мере выполнения алгоритма. Таким образом, приложение написанное в функциональном стиле проходит через три основных этапа: первый - это получение аргументов для работы, второй - выполнение функции с этими аргументами или без них, третий - возвращение результата. ",
    "codeexample":"",
    "images":[]
  },
  "j170":{
    "id":"08f36e192",
    "theme":"j",
    "question":"Плюсы и минусы функционального и объектно-ориентированного программирования",
    "answer":"Большой плюс функционального программирования - это использование функциональной парадигмы, которая позволяет избежать общих состояний и нежелательных эффектов. Также исключаются ошибки возможные из-за конкурирования функций благодаря таким фичам. как неявное программирование. Функции радикально упрощаются и легко перестраиваются для более лёгкого, по сравнению с ооп, повторного использования. Вычисления, которые используют чистые функции, легко масштабируются на несколько процессов без опасения возникновения проблем с ресурсами. Минус функционального программирования - это чрезмерная эксплуатация функциональных подходов, что иногда может привести к снижению читабельности кода, так как конечный код получается более абстрактным, кратким и менее конкретным. Некоторые общие идиомы функционального программирования могут вызывать трудности у начинающих разработчиков. Концепции функционального программирования описываются идиомами и обозначениями из лямбда исчислений и теории категорий требующих для понимания знания основ этих областях. Если говорить о плюсах ООП то это простая для понимания концепция объектов и методов вызова. ООП стремится использовать императивный стиль нежели декларативный, который читается, как прямой набор машинных инструкций. Минусы ООП - это, как правило, зависимость от общего состояния. Объекты и их поведения связаны с одной сущностью которой может быть получен доступ любым количествам функций в неопределённом порядке, что в конечном итоге может привести к непредсказуемому поведению.",
    "codeexample":"",
    "images":[]
  },
  "j171":{
    "id":"08f36e193",
    "theme":"j",
    "question":"Типы ошибок в JavaScript?",
    "answer":"Можно выделить три основных типа ошибок - это ошибки времени загрузки - это ошибки которые возникают при загрузке веб-страницы; ошибки времени выполнения - это ошибки возникающие из-за неправильного использования команды внутри языка HTML и логические ошибки это ошибки которые возникают из-за неправильной логики выполняемой в функциях или других операциях. И уже исходя из данной классификации можно выделить следующие варианты ошибок: EvalError ошибка в конструкции Eval, является устаревшей; Range Error происходит, когда число не попадает в диапазон; ReferenceError ошибка ссылки, когда логика ссылается на несуществующий элемент в коде; SyntaxError - синтаксическая ошибка; TypeError - ошибка при использовании в логике неверного типа; URIError появляется при использовании методов encodeURI и decodeURI с не валидными данными; ThrowError ошибка при использовании ключевого слова throw; CustomError - тип ошибки созданный непосредственно разработчиком.",
    "codeexample":"",
    "images":[]
  },
  "j172":{
    "id":"08f36e194",
    "theme":"j",
    "question":"Разница между typeof и instanceof?",
    "answer":"typeof - это оператор, который возвращает строку с типом того, что передаётся. Он проверяет, принадлежит ли значение одному из восьми основных типов: число, строка, логическое значение, undefined и так далее. instanceof работает на уровне прототипов, в частности он проверяет появляется ли правый операнд где-нибудь в цепочке прототипов левого. В большинстве случаев это означает, что объект был создан с помощью этого конструктора или его потомка, но также прототип может быть задан явно методом object set property of или свойством proto. Таким образом instanceof применим только к объектам. Также instanceof не может проверить, какой именно конструктор был использован для создания объекта, но вернёт true даже если объект является производным от проверяемого класса. Оператор проверяет текущий объект и возвращает true, если объект имеет указанный тип и false, если объект данный тип не имеет. ",
    "codeexample":"const ClassFirst = function () {};\nconst ClassSecond = function () {};\nconst instance = new ClassFirst();\ntypeof instance;                     // object\ntypeof instance == 'ClassFirst';     // false\ninstance instanceof Object;          // true\ninstance instanceof ClassFirst;      // true\ninstance instanceof ClassSecond;     // false\n\n'example string' instanceof String;  // false\ntypeof 'example string' == 'string'; // true\n'example string' instanceof Object;  // false\ntypeof 'example string' == 'object'; // false\n\ntrue instanceof Boolean;             // false\ntypeof true == 'boolean';            // true\n\n99.99 instanceof Number;             // false\ntypeof 99.99 == 'number';            // true\nfunction() {} instanceof Function;   // true\ntypeof function() {} == 'function';  // true",
    "images":[]
  },
  "j173":{
    "id":"08f36e195",
    "theme":"j",
    "question":"JavaScript статически, или динамически типизированный язык?",
    "answer":"JavaScript это язык с динамической типизацией. В языке с динамической типизацией тип переменной проверяется во время выполнения в отличие от языка со статической типизацией где тип переменной проверяется во время компиляции. И поскольку JavaScript - это язык со слабой динамической типизацией, переменные в JS не связаны ни с каким типом, а это значит что переменная может содержать значение любого типа данных. Таким образом, например, переменная, которой присвоен числовой тип может быть преобразована в строковый тип и это не вызовет никаких ошибок и исключений.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/nq4z1rtwwyxqdw0b5s21d/Ahg8rVL.webp?rlkey=38irl2kprt01pxnwmu76zf3b2&st=lybxl85h&dl=1"]
  },
  "j174":{
    "id":"08f36e196",
    "theme":"j",
    "question":"Что такое регулярное выражение (Regular Expression)?",
    "answer":"Регулярное выражение - это шаблон, используемый для сопоставления последовательностей символов в сроках. В JavaScript регулярные выражения также являются объектами. Эти шаблоны используются в методах test, exec, match, replace, search и split. Создать регулярное выражение можно двумя способами. Более очевидный - это использование литерала регулярного выражения то есть по сути создать переменную и присвоить ей специальное значение описанное внутри наклонных черт. За пределами крайней наклонной черты указываются специальные символы, которые называются флагами, они описывают, каким образом должен вести себя механизм поиска: должен ли он быть глобальным, нужно ли учитывать регистр символов и так далее. Второй способ - это вызвать функцию конструктор RegExp в качестве аргументов. Функция принимает два значения: первый - это строка регулярного выражения, второй - уже описанные флаги. Шаблон регулярного выражения может состоять из обычных символов или комбинация обычных и специальных символов.",
    "codeexample":"// literal form\nlet re = /ab+c/g;\n\n// constructor form\nlet re new RegExp('ab+c', 'g');",
    "images":[]
  },
  "j175":{
    "id":"08f36e197",
    "theme":"j",
    "question":"Что такое рекурсия?",
    "answer":"Рекурсия - это логика, при которой функция в своём теле вызывает саму себя. Функцию, вызывающую себя, называют рекурсивной функцией, а вызов рекурсивной функции называется рекурсивным вызовом.  Рекурсия - это не фича только языка JavaScript, данная логика применима для любого языка программирования. Одной из самых распространённых задач на собеседовании по рекурсии может быть сумма чисел в последовательности Фибоначчи, когда есть функция принимающая число, это число раскладывается на ряд Фибоначчи, и по результату возвращается сумма вхождений. Реализацию логики можно видеть в примере: функция называется Фибоначчи: внутри она содержит простое условие, и если входящее число меньше или равно единице, то оно возвращается, если нет - то возвращается сумма из двух предыдущих значений, каждая из которых пробрасывается в эту же функцию. Это и есть рекурсия, то есть вызов функций из самой себя.",
    "codeexample":"function fibonacci(n) {\n\tif (n<=1) {\n\t\treturn n;\n\t} else {\n\t\treturn fibonacci(n-1) + fibonacci (n-2);\n\t}\n}\nfibonacci (12); // 144",
    "images":[]
  },
  "j176":{
    "id":"08f36e198",
    "theme":"j",
    "question":"Что такое прототип (Prototype) объекта?",
    "answer":"Прототип - это план объекта, если он существует в текущем объекте, то используется как резерв для свойств и методов. То есть если какого-то значения нет в объекте, оно ищется в прототипе. Это способ обмена свойствами и функциональностью между объектами и основная концепция прототипного наследования в JS. Например, несмотря на то, что метод toString не существует в объекте “O” он не выдаёт ошибку, а возвращает строку object Object Когда свойства не существует в объекте, оно ищется в его прототипе, а если нет в прототипе, то в прототипе прототипа и так далее, до тех пор пока не найдено свойство с таким же именем в цепочке прототипов. Конец цепочки прототипов - это Object.prototype.",
    "codeexample":"const o = {};\nconsole.log(o.toString()); // logs [object Object]\n\nconsole.log(o.toString === Object.prototype.toString); // logs true\n\n/* which means we we're looking up the Prototype Chain and it the Object.prototype and used the \"toString\" method. */",
    "images":[]
  },
  "j177":{
    "id":"08f36e199",
    "theme":"j",
    "question":"Какие методы используются в регулярных выражениях?",
    "answer":"В регулярных выражениях используется два основных метода это test и exec. Метод exec ищет совпадение с регулярным выражением в переданной ему в качестве аргумента строке. Поведение данного метода зависит от того, имеет ли регулярное выражение флаг g или global. Если нет, то возвращается первое совпадение, если же флаг g есть, то тут срабатывает следующим механизм: для начала вызов exec возвращает первое совпадение и запоминает позицию после него в свойстве last index, далее следующий такой вызов начинает поиск с позиции  last index и возвращает следующее совпадение, после чего происходит запоминание позиции и обновление last index новым значением, и, в заключение, если совпадений больше нет, то exec возвращает null, а для last index устанавливается значение равное нулю.",
    "codeexample":"const str = 'Java and JavaScript are different programming languages';\nconst regex = /Java/g;\n\nlet result\nwhile (result = regex.exec(str)) {\n\tconsole.log('Found ${result[0]} on the position ${result.index}`);\n}\n/*\nFound Java on the position @\nFound Java on the position 7\n*/",
    "images":[]
  },
  "j178":{
    "id":"08f36e200",
    "theme":"j",
    "question":"Что такое полифил (polyfill)?",
    "answer":"Это блок кода, который выполняет аналогичную логику метода, для которого и был написан. Полифил используется для обеспечения работы современного javascript-кода старых браузеров, это делается за счёт реализации новых возможностей языка на старом синтаксисе. Сам процесс преобразования нового кода в старый называется транспиляцией. В большинстве своём полифилы создаются для логики, которая может работать некорректно в разных браузерах, либо в старых версиях браузера. Также полифилом можно считать любую пользовательскую функцию, которая решает какие-то проблемы кроссбраузерности.",
    "codeexample":"// map\nlet newArray = givenArray.map((ele) => {\n\treturn ele\n})\n\n// map ployfill\nArray.prototype.customMap = function(processFunc){\n\tlet newArray = [];\n\tfor(let index = 0; index < this.length; index++){\n\t\tconst curele processFunc(this [index], index); n\t\tif(curEle){\n\t\t\tnewArray.push(curEle)\n\t\t}\n\t}\n\treturn newArray\n}",
    "images":[]
  },
  "j179":{
    "id":"08f36e201",
    "theme":"j",
    "question":"Что такое switch/case? Правила использования switch/case?",
    "answer":"switch/case является альтернативой if/else и представляет собой более наглядный способ выполнения кода в зависимости от переданного условия. Инструкция switch сравнивает выражение со случаями или кейсами, перечисленными внутри неё, а затем выполняет соответствующие инструкции. Каждый случай отделён ключевым словом case, внутри case описывается логика и в конце указывается ключевое слово brake. Это нужно чтобы прекратить дальнейшее выполнение проверок, если одна из них сработала. В конце указывается обязательно блок default  для случаев, когда не один из кейсов не отработал. При использовании конструкции switch/case необходимо придерживаться следующих правил: условие может быть числом или строкой, не допускается дублирование значений, инструкция default является опциональной, если ни для одного блока кейс не найдено совпадение, выполняется блок default, break используется для остановки цикла break также является опциональным, но без него выполнение цикла будет продолжаться.",
    "codeexample":"const score = 20;\n\nswitch(score){\n\tcase 10:\n\t\tconsole.log(\"Score value is 10\");\n\t\tbreak;\n\tcase 20:\n\t\tconsole.log(\"Score value is 20\");\n\t\tbreak;\n\tdefault:\n\t\tconsole.log(\"Score value is neither 10 or 20\");\n}",
    "images":[]
  },
  "j180":{
    "id":"08f36e202",
    "theme":"j",
    "question":"Типы функций по способности принимать другие функции?",
    "answer":"JavaScrip так как вся его суть сводится к тому что Функция может принимать другие функции как аргументы или же возвращать их в JS можно выделить три основных типа функций в зависимости от принимаемых данных функция первого порядка это функция которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значение функция высшего порядка это функция которая принимает другую функцию в качестве аргумента или возвращает функцию как значение и унарная функция её ещё называют функция монада - это функция которая принимает только один аргумент который не является функцией ",
    "codeexample":"// First Order Function\nconst firstOrder = () => console.log('Hello');\n\n// Higher Order Function\nconst higherOrder = firstOrder Return => firstOrder Return();\nhigherOrder (firstOrder);\n\n// Unary Function\nconst unaryFunction = (a) => console.log(`${a} + world!');",
    "images":[]
  },
  "j181":{
    "id":"08f36e203",
    "theme":"j",
    "question":"Что такое выражения (expression) и инструкции (statement) в JavaScript?",
    "answer":"В JavaScript выражения или Expression - это фрагмент кода, некая комбинация значений, переменных, операций и функций, которые в ходе своего выполнения приводят к вычислению и возврату некоторого значения, например числа, строки или значения логического типа. Выражения могут быть сколь угодно длинными, но они всегда будут приводить к вычислению некоторого одного значения например 5 + 3 вернёт 8 а Math.random() случайное число. Инструкция или statement - это фрагмент кода, который выполняет какое-то определённое действие или, если говорить другими словами, является командой. Большинство инструкций в JavaScript заканчивается точкой запятой, примеры инструкции - это блоки if else while for switch и так далее. ",
    "codeexample":"// expressions\nconst x = 5;\nconst y = getAnswer();\nconst z = 2 + 5;\nMath.random();\n\n// statements\nif (a > 5) {\n\t9 + 9;\n}\n\nif (true) { return 2 }\n\nswitch (expr) {\n\tcase 'Oranges':\n\t\tconsole.log('Oranges are $0.59 a pound.');\n\t\tbreak;\n\tcase 'Papayas':\n\t\tconsole.log('Mangoes and papayas are $2.79 a pound.');\n\t\tbreak;\n\tdefault:\n\t\tconsole.log('Sorry, we are out of ${expr}.`);\n}",
    "images":[]
  },
  "j182":{
    "id":"08f36e204",
    "theme":"j",
    "question":"Разница между .some() и .every()?",
    "answer":"Оба метода предназначены для перебора массива, они проверяют каждый элемент массива на соответствие условиям переданной функции, после чего возвращают полученный результат. some() перебирает массив и смотрит, соответствует ли один конкретный элемент массиве в логическому условию, every() можно использовать, чтобы узнать, соответствуют ли все элементы массива логическому условию. Оба метода возвращают булевое значение true если условие выполнилось и false если оно не прошло.",
    "codeexample":"const identity = (x) => x;\n\n[true, true].some (identity);            //true\n[true, true].every (identity);           //true\n\n[true, false].some (identity);           //true\n[true, false].every (identity);          //false\n\n[false, false].some (identity);          //false\n[false, false].every (identity);         //false\n\n[undefined, true].some (identity);       //true\n[undefined, true].every(identity);       //false\n\n[undefined, false].some (identity);      //false\n[undefined, false].every(identity);      //false\n\n[undefined, undefined].some (identity);  //false\n[undefined, undefined].every (identity); //false",
    "images":[]
  },
  "j183":{
    "id":"08f36e205",
    "theme":"j",
    "question":"Как сгенерировать случайное число в JavaScript?",
    "answer":" Самый простой вариант для того чтобы сгенерировать случайное число в JavaScript - это воспользоваться функцией Math.random() - это одна из самых часто используемых функций объекта Math она возвращает случайное число в диапазоне от нуля до единицы не включая единицу.На самом деле, функция не генерирует случайное число, это лишь имитация. За генерацию подобных чисел отвечают специальные алгоритмы, которые относятся к категории и PRNG или pseudorandom number generator их также называют генераторами псевдослучайных чисел. Любой PRNG алгоритм генерирует числа, которые в конечном счёте будут повторяться поэтому числа генерируемые с помощью Math.random() можно предугадать. Для небольших проектов такой генерации вполне достаточно, но для серьёзных продакшн проектов лучше использовать специализированные сторонние библиотеки.",
    "codeexample":"// Getting a random number between 0 and 1\nfunction getRandom() {\n\treturn Math.random();\n}\n\n// Getting a random integer between two values, inclusive\nfunction getRandomIntInclusive(min, max) {\n\tmin = Math.ceil(min);\n\tmax = Math.floor(max);\n\treturn Math.floor(Math.random() * (max - min + 1) + min);\n}",
    "images":[]
  },
  "j184":{
    "id":"08f36e206",
    "theme":"j",
    "question":"Типы операторов в JavaScript?",
    "answer":"В JavaScript можно выделить 11 основных типов операторов это: операторы присваивания - это обычное одинарное равно, либо комбинация равно и например математической операции; операторы сравнения, как нетрудно догадаться, используются для сравнения двух или более значений; арифметические операторы - умножения, деления, сложения и вычитание и так далее; битовые или поразрядные операторы - обрабатывают свои операнды как последовательности нулей и единиц; логические операторы, их три - это и, или, не; строковые операторы - самый простой пример - это плюс или конкатенация строк; условный или тернарный оператор комбинация “?”, как проверяемое условие и “:”, как вариант исполнения; оператор запятая “,” просто вычисляет оба операнда и возвращает значение последнего операнда; унарные операторы - это операция только с одним операндом, например удаление из объекта или оператора определения типа; операторы отношения сравнивают свои операнды и возвращают результат сравнения в виде булевого значения; оператор нулевого слияния новый тип, который представляет из себя два вопросительных знака.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/6s4jxc3l0m3ci9elbyflg/width_1280x2_q70.webp?rlkey=rokohvuurjbtvehi89gspb9vv&st=oetol86j&dl=1"]
  },
  "j185":{
    "id":"08f36e207",
    "theme":"j",
    "question":"Разница между параметром и аргументом функции?",
    "answer":"Параметры - это переменные, которые используются при создании функции, то есть это переменная, указанная в круглых скобках в объявлении функции; аргументы - это фактически значение или данные, которые передаются функции при её вызове.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/4ibarynqenbjavn9yy8n2/argumenty-funkczii-i-parametry-funkczii-javascript-1536x828.webp?rlkey=wd02z5xpxo96vqrvuk0mka6zv&st=x68xa8p6&dl=1"]
  },
  "j186":{
    "id":"08f36e208",
    "theme":"j",
    "question":"Правила задания имён для переменных и функций в JavaScript?",
    "answer":"В JavaScript есть два основных ограничения, которые касаются имён переменных: 1. имя переменной должно содержать только буквы цифры или символы доллара и нижнего подчёркивания. 2. первый символ не должен быть цифрой. Что же касается функций, то тут ещё проще, имя функции должно понятно и чётко отражать, что она делает и что возвращает. Функция - это действие, поэтому её имя обычно является глаголом. Есть много общепринятых префиксов, таких как create, show, get и так далее и начинать именно с них, это отличная подсказка, которая поможет понять что делает функция.",
    "codeexample":"// Correct\nlet width = 0;\nlet name = 'Jack' ;\nlet _nickName = 'Max';\nlet $1;\nconst checkAge = () => { });\nconst checkName = () => {};\nconst sortList = () => {};\n\n// Incorrect\nlet 1name = 'Jack';\nlet 2nickName = 'Max';\nlet my-name = 'Stan';\nconst admin = () => {}; 15 const listOfPeople = () => {};",
    "images":[]
  },
  "j187":{
    "id":"08f36e209",
    "theme":"j",
    "question":"Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?",
    "answer":"Неявное преобразование - это способ приведения значения к другому типу без участия разработчика, другими словами данный тип преобразования происходит автоматически. Если разобрать на практических примерах, то результатом сложения числа 1 и строки “шесть” будет 16, в других языках это бы привело к ошибке. Единица конвертируется в строку и конкатенируется с шесть при этом дополнительно ничего не выполнялось, преобразование произошло автоматически. При сложении false и true получается также единица false было преобразовано в ноль, а true в один 0 + 1 = 1. Результатом умножения 6 числом и “два” строкой будет 12 строка два была преобразована в число перед умножением на шесть. Так работает не явное преобразование, явное преобразование предполагает участие разработчика в приведении значения к другому типу и здесь идут явные преобразования с использованием parseInt или number для приведения к числу или, например, объекта обёртки boolean или двойного восклицательного знака для приведения значения к булевому типу и так далее.",
    "codeexample":"// Implicit Coercion\nconsole.log(1 + '6');           // 16\nconsole.log(false + true);      // 1\nconsole.log(6 * '2');           // 12\n\n// Explicit Coercion\nconsole.log(1 + parseInt('6')); // 7\nconsole.log(6 + Number('2'));   // 8",
    "images":[]
  },
  "j188":{
    "id":"08f36e210",
    "theme":"j",
    "question":"Для чего применяется метод Array.from()?",
    "answer":"Array.from() создаёт новый массив на основе переданного объекта. Объект должен быть либо массиво подобным, как, например, строка или псевдомассив-объект arguments, либо интегрируемые, как например коллекции Set или Map. Функция Array.from() принимают три аргумента: объект, на основе которого создаётся массив - это обязательный аргумент, и два опциональных: функция преобразования элемента перед его добавлением массив - работает как метод map, то есть перед добавлением элементов массив над ним можно дополнительно выполнить какие-то манипуляции и в заключении значение, которое будет использоваться как this функций из второго параметра результатом работы метода будет новый массив, составленный из элементов переданного объекта.",
    "codeexample":"// Array from string\nconsole.log(Array.from('front')); // ['f', 'r', 'o', 'n', 't']\n\n// Array from Set\nconst arr1 = new Set(['foo', window]);\nconsole.log(Array.from(arr1)); // ['foo', window]\n// Array from Map\nconst arr2 = new Map ([[1, 2], [2, 4], [4, 8]]);\nconsole.log(Array.from(arr2)); // [[1, 2], [2, 4], [4, 8]]",
    "images":[]
  },
  "j189":{
    "id":"08f36e211",
    "theme":"j",
    "question":"Назовите способы преобразования массива в объект?",
    "answer":"В JavaScript Есть несколько вариантов преобразования массива в объект. Самые часто используемые - это метод Object.assign, применение spread оператора появившегося в стандарте es-6, использование метода reduce. При Object.assign внутрь метода передаются два аргумента первый - это пустой объект, куда и будут добавляться значения, второй - это массив, который требуется преобразовать; при использовании spread оператора исходный массив просто распыляется внутрь объекта, а при методе reduce происходит преобразование исходного массива, в результате которого его значение будут присвоены в объект, который в свою очередь передаётся вторым аргументом в reduce.",
    "codeexample":"const arr = ['frontend', 'backend', 'qa'];\n\n// 1 approach - method assign\nconst obj = Object.assign({}, arr);\n\n// 2 approach - spread operator\nconst obj = {...arr };\n\n// 3 approach - method reduce\nconst obj = arr.reduce((res, key, index) => {\n\tres[index] = key;\n\treturn res;\n}, {});",
    "images":[]
  },
  "j280":{
    "id":"08f36e368",
    "theme":"j",
    "question":"Разница между Object и Map?",
    "answer":"Objects похожи на коллекцию map в том, что позволяет устанавливать ключи для значений, извлекать эти значения, удалять ключи и определять, хранится ли что-то в ключе. По этой причине objects исторически использовались в качестве map-коллекции, но есть важное отличие, которое делает использование map предпочтительнее в определённых случаях.\nКлючами object являются строки и символы, тогда как для map они могут быть любыми значениями, включая функции, объекты и любые примитивы. Ключи в map упорядочены, а ключи добавленные в объект – нет. Таким образом, при итерации по нему, объект map возвращает ключи в порядке вставки.\nМожно легко получить размер map с помощью свойства length. В то время как количество свойств в object должно быть определено вручную. Map является итерируемым и, таким образом,  по элементам коллекции можно спокойно пройтись. Тогда как операция по объекту требует получения ключей или использование дополнительных методов. Производительность map в сценариях, связанных с частым добавлением и удалением пар ключ/значения, намного лучше чем в object.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/ojpmjbrpu7jx24m2y5gmo/1693469945535.webp?rlkey=rtt7bwsq0lvf2kim3izwzlqto&st=2d79n25z&dl=1"]
  },
  "j190":{
    "id":"08f36e212",
    "theme":"j",
    "question":"Что такое каррирование?",
    "answer":"Каррирование - это процесс в функциональным программировании, в котором возможно преобразовать функцию с несколькими аргументами в набор вложенных функций с одним аргументом. Исходная функция возвращает новую функцию, которая ожидает следующий встроенный аргумент. Новая функция, ожидающая следующего аргумента, возвращается при каждом вызове карированной функции до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы благодаря механизму замыканий ждут того момента когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисление и возвращает результат. Преобразование функции позволяет легко получать частичные данные избегая многократных передач одной и той же переменной. Каррирование создаёт вложенные функции в соответствии с количеством аргументов функций, поэтому каждая функция получает аргумент и если аргумента нет каррирование не выполняется.",
    "codeexample":"function mul (x) {\n\treturn function (y) {     // anonymous function\n\t\treturn function (z) { // anonymous function\n\t\t\treturn x * y* z;\n\t\t};\n\t};\n}\n\nconsole.log(mul(2) (3) (4));  // output: 24\n\nconsole.log(mul (4) (3) (4)); // output: 48",
    "images":[]
  },
  "j281":{
    "id":"08f36e369",
    "theme":"j",
    "question":"Для чего используются метод Object.seal()?",
    "answer":"Создаваемое в JavaScript объект можно изменять, то есть новое новые свойства могут быть добавлены, а существующие свойства могут быть изменены или удалены.\n\nМетод Object.seal() запечатывает объект, предотвращая добавление новых свойств к нему и делая все существующие свойства не настраиваемыми и неконфигурируемыми, то есть они не могут быть преобразованы из дескрипторов данных в дескрипторы доступа и наоборот.\n\nЗначение представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми. Однако при попытке удаления свойства оператор Delete возвращает false. Также Object.seal() выдаёт TypeError в строгом режиме при попытке изменить значение защищённого объекта.",
    "codeexample":"const obj = {\nprop: function() {},\nfoo: 'bar',\n};\n\n// Change properties\nobj.foo = 'baz';\nobj.lumpy = 'woof';\ndelete obj.prop;\n\n// Apply seal\nconst o= Object.seal (obj);\nassert(o === obj);\nassert(Object.isSealed (obj) === true);\n\n// Possible change of existing property\nobj.foo = 'quux';",
    "images":[]
  },
  "j191":{
    "id":"08f36e213",
    "theme":"j",
    "question":"Для чего используется свойство .dataset?",
    "answer":"Свойство dataset позволяет считывать или устанавливать любые data атрибуты на HTML элементы. data атрибут - это пользовательский атрибут на элементе, название которого начинается с префикса data, например data-test-id. Дата атрибуты используется, чтобы хранить значения на элементах в HTML. Использование таких атрибутов - это валидный и безопасный способ передачи пользовательских данных, но для того, чтобы получить значение данного атрибута, можно воспользоваться свойством dataset. Обращение к свойству dataset  возвращает объект со всеми data атрибутами, которые есть на элементе. Названиями полей или ключами в объекте будут имена дата атрибутов после префикса data, например, если атрибут называется data-episode, то в объекте поле этого атрибута будет называться episode, если data-id то просто id. ",
    "codeexample":"<ul>\n\t<li data-id=\"1541\" data-episode=\"1\">Дapт мол</li>\n\t<li data-id=\"9434\" data-episode=\"4\">Дapт Вейдep</li>\n\t<li data-id=\"5549\" data-episode=\"4\">Дapт Сидиус</li>\n</ul>\n\n<script>\n\tconst items = document.querySelectorAll('li');\n\tconst firstItem = items[0];\n\tconsole.log(firstItem.dataset); // { id: '1541', episode: '1'}\n</script>",
    "images":[]
  },
  "j192":{
    "id":"08f36e214",
    "theme":"j",
    "question":"Каким образом можно обмениваться кодом между файлами?",
    "answer":"Способ обмена зависит от среды выполнения JavaScript кода. На клиенте, то есть в браузере, пока переменные и функция объявлены в глобальной области видимости, все скрипты могут на них ссылаться - это первый вариант обмена, однако глобальные переменные - это плохая практика, поэтому такой подход лучше не использовать. В качестве альтернативы можно применять AMD через requare.js для модульного подхода. На сервере, то есть, например, на node.js обычно используется подход commonJS. При данном подходе каждый файл считается модулем, и он может экспортировать переменные и функции, добавляя их к объекту module.exports. Также, с версией Ecmascript 2015 появилась возможность использовать модульный синтаксис, который был призван заменить как AMD, так и commonJS. В конечном итоге использование import и export уже активно применяется  как в браузере так и в Node.JS. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/ef0y8kylcnmxqhiescvxo/image-1685417132225.webp?rlkey=alitbljwf3sd0yd903lsabua7&st=bqvhpytg&dl=1"]
  },
  "j193":{
    "id":"08f36e215",
    "theme":"j",
    "question":"Как работает «сборщик мусора» в JavaScript?",
    "answer":"Основной алгоритм сборки мусора называется “алгоритм пометок” или Mark and Sweep. Согласно этому алгоритму сборщик мусора регулярно выполняет следующие шаги: он помечает и запоминает все корневые объекты, затем идёт по ним и помечает все ссылки из них, далее он идёт по помеченным объектам и отмечает их ссылки, все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды и так далее, пока не будут посещены все достижимые из корней ссылки, все не помеченные объекты в итоге удаляются. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/t9gdq2g7uy2izh8ti8cai/2441328_a732_2.webp?rlkey=nwxzzqla11603ggikmk1dptr5&st=pcl8p0tj&dl=1"]
  },
  "j194":{
    "id":"08f36e216",
    "theme":"j",
    "question":"Что такое утечки памяти?",
    "answer":"Утечки памяти можно определить, как фрагменты памяти, которые больше не нужны приложению, однако, по какой-то причине невозвращённые операционной системе или в пул свободной памяти. Языки программирования используют различные способы управления памятью. Одни языки предоставляют разработчику вспомогательные средства для управления памятью, другие ожидают от программиста явных указаний касательно используемых и неиспользуемых участков памяти. Если говорить о JavaScript, то это автоматический сборщик мусора алгоритмом mark and sweep. Однако проблема точного определения того, используется ли на самом деле некий участок памяти или нет, не разрешима, другими словами, только разработчик знает, можно или нет вернуть операционной системе некую область памяти.",
    "codeexample":"var ol = { \n\t02: {\n\t\tх: 1\n\t}\n};\n// Созданы 2 объекта.\n// на объект о2 есть ссылка в объекте ol, как на одно из его свойств.\n// На данном этапе ни один объект не может быть уничтожен сборщиком мусора.\n\nvar 03 = 01; // Переменная 03 - это вторая сущность, которая\n\t\t\t// имеет ссылку на объект, на который указывает переменная 01.\n\n01 = 1;   // Теперь на объект, на который изначально ссылалась переменная ol, есть лишь\n\t\t\t// одна ссылка, представленная переменной о3\n\nvar 04 = 03.02; // Ссылка на свойство о2 объекта.\n\t\t\t// Теперь на этот объект есть 2 ссылки. Одна как на свойство\n\t\t\t// другого объекта.\n\t\t\t// Вторая - в виде переменной 04\n\n03 = '374'; // Теперь на объект, на который изначально ссылалась переменная 01,\n\t\t\t// нет ни одной ссылки.\n\t\t\t// Он может быть уничтожен сборщиком мусора.\n\t\t\t// Однако, на его свойство 02 всё ещё ссылается\n\t\t\t// переменная 04. В результате память, занимаемая этим объектом,\n\t\t\t// не может быть освобождена.\n\n04 = null; // На свойство о2 объекта, изначально записанного в переменную 01,\n\t\t\t// теперь нет ссылок, значит\n\t\t\t// объект может быть уничтожен сборщиком мусора.",
    "images":[]
  },
  "j195":{
    "id":"08f36e217",
    "theme":"j",
    "question":"Назовите основные типы утечек памяти в JavaScript?",
    "answer":"В JavaScript есть четыре основные причины утечек памяти: 1. Глобальные переменные. Помимо того, что использование глобальных переменных является плохой практикой, так они ещё являются одной из причин утечек памяти. Даже если говорить о вполне безобидных переменных, созданных осознанно, во многих программах их слишком много. Они по определению не подвергаются сборке мусора, а следовательно засоряют память не нужными данными. Для того, чтобы избежать подобных ошибок, можно добавить оператор Use strict или, если проще, использовать строгий режим. 2. Таймеры или забытые коллбеки. В JavaScript программах использование функции setInterval обычное явление. Таймеры, а также весь относящийся к ним код не подвергаются сборке мусора. Поэтому каждый таймер возвращает свой идентификатор, используя который, данный таймер можно остановить вручную, и когда пишешь код, об этой возможности не нужно забывать. 3. Замыкание - это внутренняя функция, у которой есть доступ к переменным, объявленным во внешней по отношению к ней функции. Таким образом JavaScript сохраняет в памяти все",
    "codeexample":"",
    "images":[]
  },
  "j196":{
    "id":"08f36e218",
    "theme":"j",
    "question":"Разница между Rest и Spread операторами?",
    "answer":"Несмотря на то, что синтаксис Rest и Spread одинаков, задачи которые они выполняют, противоположные. Spread оператор используется для разделения коллекций на отдельные элементы. С помощью Spread  удобно производить “распыление”, например, когда в массив или объект можно добавлять новое значение их других массивов или объектов , причем эти значения не обязательно перечислять полностью. Достаточно взять распыляемую структуру и поставить … Так же он используется при копировании объектов или массивов. Rest предназначен для соединения отдельных значений в массив. Позволяет группировать массив определенные данные. Например, собрать остаточные аргументы передаваемые в функцию.",
    "codeexample":"// Spread\n// with array\nconst names1 = ['Jack', 'Max'];\nconst names2 = ['Leo', 'Tommy', ...names1];\nconsole.log(names2); // ['Leo', 'Tommy', 'Jack', 'Max']\n// with object\nconst obj1 = { name: 'Jack' };\nconst obj2 = {\n\tname: 'Max',\n\tage: 30,\n\t...obj1\n};\nconsole.log(obj2); // { name: 'Jack', age: 30 }\n\n// Rest\nconst log = (a, b, ...rest) => {\n\tconsole.log(a, b, rest);\n};\nlog('Basic', 'rest', 'operator', 'usage'); // Basic rest ['operator', 'usage']",
    "images":[]
  },
  "j197":{
    "id":"08f36e219",
    "theme":"j",
    "question":"Что такое деструктуризация?",
    "answer":"Деструктуризация или деструктурирующее присваивание это выражение доступно со стандарта ES6, которая предоставляет удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные. Оно призвано минимизировать написанный код, а так же сделать его более понятным несмотря на объем.",
    "codeexample":"// Array destructuring\nconst people = ['Lili', 'Mary', 'Nina'];\n// ES5\nvar lili = people[0];\nvar mary = people[1];\nvar nina = people [2];// ES6\nconst [lili, mary, nina];\n\n// Object destructuring = people;\nconst person = { name: 'Lili', age: 20 };\n// ES5\nvar name = person.name;\nvar age = person.age;\n// ES6\nconst { name, age} = person;",
    "images":[]
  },
  "j292":{
    "id":"08f36e381",
    "theme":"j",
    "question":"Что такое итераторы?",
    "answer":"Итераторы применяются для организации последовательного доступа к элементам набора данных, массивам, объектам Set/Map, строкам и так далее.\nТак, благодаря итераторам, можно перебрать набор данных, с помощью цикла for…of.\nДополнительно, в стандарте ES6 было добавлено еще 1 понятие- это «итерируемые объекты». Итерируемые объекты- это объекты, содержимое которых можно перебрать в цикле.\nЕсли сравнивать обычный объект и итерируемый, то последний обладает определенными отличиями, а в частности: у него есть специальный метод, который возвращает объект. У этого объекта есть специальный метод, который называется next. Сам метод также возвращает объект, у которого есть 2 свойства: done и value. Перебор будет идти до тех пор, пока возвращаемый методом объект не вернет свойства done со значением true.",
    "codeexample":"",
    "images":[]
  },
  "j295":{
    "id":"08f36e382",
    "theme":"j",
    "question":"Для чего используется метод .getOwnPropertyDescriptors()?",
    "answer":"Метод .getOwnPropertyDescriptors() возвращает все собственные дескрипторы свойств объекта. Если немного упростить, то можно сказать, что этот метод позволяет возвращать все сведения для всех свойств заданного объекта, включая данные о геттерах и сеттерах.\nПомимо этой основной задачи, у него есть еще 1 возможность- это то, что он позволяет создавать мелкие копии объектов и клонировать объекты, создавая новые, при этом копируя, помимо прочего, геттеры и сеттеры. Напомню, что get- это функция, которая возвращает значение свойства, а set- это функция, которая записывает значение свойства. Оба поля относится к, так называемым, дескрипторам свойства, а, в свою очередь, дескриптор- это объект, который описывает поведение свойства. Таким образом, метод позволяет не только читать эти значения, но и при копировании переносить их",
    "codeexample":"",
    "images":[]
  },
  "j198":{
    "id":"08f36e220",
    "theme":"j",
    "question":"Что такое статический метод класса (static)? Как осуществляется его вызов?",
    "answer":"Свойства и методы являются статическими, если они не привязаны к конкретному экземпляру класса и имеют одинаковое значение вне зависимости от того какой экземпляр ссылается на них. Статические свойства обычно определяются конфигурационными переменными, а статические методы являются чисто служебными функциями, которые не зависят от состояния экземпляра и часто используются для создания вспомогательных функций приложения. Данные свойства и методы внутри класса обозначаются специальным словом static . Также статичные методы функции принадлежат объекту класса, но недоступны другим объектам того же класса, а это значит, что если создать экземпляр класса, то к статичным методам обратиться не получится. Для того, чтобы их вызвать внутри другого статичного метода используется ключевое слово this. В нестатичном методе используется, либо имя класса.ю либо их вызов происходит через конструктор.",
    "codeexample":"class Person {\n\tstatic getName() { \n\t\treturn \"Alisa\";\n\t}\n\tstatic nickName() {\n\t\treturn '${this.getName()}S`;\n\t}\n\tuseName() {\n\t\tPerson.getName();           // Call static method using Class\n\t\tthis.constructor.getName(); // Call static method using 'this'\n\t}\n}\nconsole.log(Person.getName());     // \"Alisa\"\nconsole.log(Person.nickName()); // \"AlisaS\"\n\nconst pers = new Person();\nconsole.log(pers.getName());// TypeError: pers.getName is not a function",
    "images":[]
  },
  "j199":{
    "id":"08f36e221",
    "theme":"jib",
    "question":"Что такое DOM?",
    "answer":"DOM - это объектная модель документа, которую браузер создает в памяти компьютера на основании html-кода, полученного им от сервера. DOM имеет древовидную структуру, поэтому его еще называют DOM-дерево",
    "codeexample":"",
    "images":[]
  },
  "j200":{
    "id":"08f36e222",
    "theme":"jib",
    "question":"Что такое распространение события (Event Propagation)?",
    "answer":"Это механизм, который отрабатывает, когда какое-либо событие происходит в документе. Событие распространяется от объекта window до вызывающего его элемента, при этом событие последовательно затрагивает всех предков целевого элемента. Есть три фазы распространения событий: Capturing(фаза захвата - событие начинается от корня документа и проходит по DOM-дереву до целевого элемента), target(событие достигает целевого элемента - обычно его называют event target), bubbling(всплытие - заключительная фаза: событие возвращается обратно до window параллельно вызывая все события на родительских элементах)",
    "codeexample":"",
    "images":[]
  },
  "j201":{
    "id":"08f36e223",
    "theme":"jib",
    "question":"Что такое делегирование событий (Event Delegation)?",
    "answer":"Это прием разработки, когда вместо того, чтобы вешать много однотипных обработчиков на все элементы, можно добавить один обработчик на общего предка (например, не вешать обработчики на каждую ячейку таблицы, а добавить обработчик на саму таблицу (тег table) и с помощью event.target  отслеживать элемент, на который произошел клик)",
    "codeexample":"",
    "images":[]
  },
  "j202":{
    "id":"08f36e224",
    "theme":"jib",
    "question":"Разница между e.preventDefault() и e.stopPropagation()?",
    "answer":"Метод preventDefault()отключает поведение элемента по умолчанию. Например, если его использовать на ссылке и вызвать при клике, то мы отменим переход, а если на форме, то мы отменим ее отправку при клике на submit. Метод stopPropagation() отключает распространение событие события - т есть всплытие или погружение. ",
    "codeexample":"",
    "images":[]
  },
  "j203":{
    "id":"08f36e225",
    "theme":"jib",
    "question":"Методы поиска элементов в DOM?",
    "answer":"document.getElementById(‘id’); document.getElementsByName(‘name’); (редко используется); document.getElementsByTagName(‘div’); document.getElementsByClassName(‘class’); document.querySelector(‘nav + p’); (вернет только первый найденный элемент); document.querySelectorAll(‘nav > ul > li’); (вернет все найденные элементы);",
    "codeexample":"",
    "images":[]
  },
  "j204":{
    "id":"08f36e226",
    "theme":"jib",
    "question":"Разница между event.target и event.currentTarget?",
    "answer":"event.target - это элемент, в котором происходят события, или который вызывает событие. А event.currentTarget - это непосредственно элемент, к которому прикреплен прослушиватель события. ",
    "codeexample":"",
    "images":[]
  },
  "j205":{
    "id":"08f36e227",
    "theme":"jib",
    "question":"Разница между .stopPropagation() и .stopImmediatePropagation()?",
    "answer":"При наступления события в браузере происходит всплытие - в результате обработчики вызываются на самом элементе, а затем на всех родителях. Остановить такое поведение всплытия можно добавив .stopPropagation() или .stopImmediatePropagation()При этом .stopPropagation() отменяет всплытие, но на текущем обработчике событие срабатывает. А .stopImmediatePropagation()не только остановит всплытие, но и остановит обработку событий на текущем элементе.",
    "codeexample":"",
    "images":[]
  },
  "j206":{
    "id":"08f36e228",
    "theme":"jib",
    "question":"Разница между событиями load и DOMContentLoaded?",
    "answer":"Оба события срабатывают при загрузке веб-страницы в браузере. Но DOMContentLoaded отрабатывает, когда браузер полностью загрузил html и DOM-дерево было построено, однако внешние ресурсы (стили, картинки, шрифты) еще не прогружены. А load срабатывает, когда загружен и html и все внешние ресурсы. Таким образом DOMContentLoaded всегда срабатывает раньше чем load. ",
    "codeexample":"",
    "images":[]
  },
  "j207":{
    "id":"08f36e229",
    "theme":"jib",
    "question":"Разница между attribute и property у DOM-элементов?",
    "answer":"Аttribute - это статичное значение определенного DOM-элемента, которая не изменяема и может быть добавлена в HTML разметку. Property - это вычисленное значение DOM-элемента, оно может динамически изменяться.Например, в поле input есть атрибут value, значение этого атрибута можно получить с помощью getAttribute() или свойства value. При первом рендеринге эти значения будут одинаковыми, но если пользователь введет какие-либо данные в input, то при повторном обращении за новыми значениями динамически поменяются только value.",
    "codeexample":"<!-- After page is rendered -->\n<input type=\"text\" value=\"Hello world\">\n<script>\n\tinput.getAttribute (value); // \"Hello world\" \n\tinput.value;                // \"Hello world\"\n</script>\n\n<!-- After user intered any value into input field -->\n<input type=\"text\" value=\"New Text\">\n<script>\n\tinput.getAttribute(value); // \"Hello world\"\n\tinput.value;               // \"New Text\"\n</script>",
    "images":[]
  },
  "j208":{
    "id":"08f36e230",
    "theme":"jib",
    "question":"Разница между HTMLCollection и NodeList?",
    "answer":"HTMLCollection - это динамическия HTML коллекция, которая представляет собой массивоподобной итерируемой объект дочерних элементов. NodeList - это статический список node или узлов, в которые входят все найденные в документе элементы. Например, getElementsByClassName() возвращает HTMLCollection, querySelectorAll() возвращает NodeList. Отличие между ними,в том, что если разметку динамически будет добавлен еще один элемент, то обновленные данные будут присутствовать только в HTMLCollection, так как HTMLCollection - это динамическая структура данных, а NodeList - статическая.",
    "codeexample":"\n<ul id=\"list\">\n\t<li class=\"item\">First Item</li>\n\t<li class=\"item\">Second Item</li>\n</ul>\n<script>\n\tdocument.getElementsByClassName('item'); // HTML Collection (2)\n\tdocument.querySelectorAll('.item');      // NodeList (2)\n</script>\n\n<!-- Dynamicaly added one LI-element -->\n<ul id=\"list\">\n\t<li class=\"item\">First Item</li>\n\t<li class=\"item\">Second Item</li>\n\t<li class=\"item\">Third Item</li>\n</ul>\n<script>\n\tdocument.getElementsByClassName('item'); // HTML Collection (3)\n\tdocument.querySelectorAll('.item');      // NodeList (2)\n</script>",
    "images":[]
  },
  "j209":{
    "id":"08f36e231",
    "theme":"jib",
    "question":"Как динамически добавить элемент на HTML-страницу?",
    "answer":"Создание новых элементов осуществляются с помощью метода .createElement(), внутрь которого передается тег создаваемого элемента. С помощью методов .classList.add() на созданный элемент можно навесить класс, а используя .createTextNode() можно создать текстовую ноду, которую в последующем с помощью .appendChild можно поместить внутрь созданного элемента, после того как элемент полностью готов с помощью .appendChild() он помещается в основную разметку DOM-дерева.",
    "codeexample":"// Create element\nconst newP = document.createElement(\"p\");\n// Add class to element\nnewP.classList.add(\"pStyle\");\n// Create text-node\nconst textNode = document.createTextNode(\"Hello world\");\n// Add text-node inside created element\nnewP.appendChild(textNode);\n// Add created element inside DOM\ndocument.getElementById(\"test\").appendChild(newP);",
    "images":[]
  },
  "j210":{
    "id":"08f36e232",
    "theme":"jib",
    "question":"Типы узлов DOM-дерева?",
    "answer":"Спецификация браузерного JavaScript насчитывает 12 типов узлов. На практике чаще всего применяются четыре: document - входная точка в DOM-дерево; elementNode (узлы элементы) по сути это узлы обычных HTML-тэгов, из которых состоит страница; textNode (текстовые узлы) содержат текст; commentNode (узлы комментарии). Любой комментарий на HTML-странице становится отдельным типом узла. Каждому из типов узлов соответствует свое цифровое значение от 1 до 12. Для проверки к какому типу относится узел используется  свойство nodeType, которая возвращает числовое значение.",
    "codeexample":"// DOM nodes\nconst unsigned short ELEMENT_NODE = 1;\nconst unsigned short ATTRIBUTE_NODE = 2;\nconst unsigned short TEXT_NODE = 3;\nconst unsigned short CDATA_SECTION_NODE = 4;\nconst unsigned short ENTITY_REFERENCE_NODE = 5; // legacy\nconst unsigned short ENTITY_NODE = 6;           // legacy\nconst unsigned short PROCESSING_INSTRUCTION_NODE = 7;\nconst unsigned short COMMENT_NODE = 8;\nconst unsigned short DOCUMENT_NODE = 9;\nconst unsigned short DOCUMENT_TYPE_NODE = 10;\nconst unsigned short DOCUMENT_FRAGMENT_NODE = 11;\nconst unsigned short NOTATION_NODE = 12;        // legacy\n\n// Checking node types\nconsole.log(document.nodeType);       // 9\nconsole.log(elementNode.nodeType);    // 1\nconsole.log(textNode.nodeType);       // 3\nconsole.log(commentNode.nodeType);    // 8",
    "images":[]
  },
  "j211":{
    "id":"08f36e233",
    "theme":"jib",
    "question":"Свойства для перемещения по DOM-дереву?",
    "answer":"Существует 12 основных свойств, которые позволяют перемещаться по DOM-дереву от найденного элемента. Они делятся на две большие группы. Для всех типов узлов: childNodes - возвращает коллекцию дочерних элементов; firstChild и lastChild - обеспечивают доступ к первому и последнему дочернему элементу соответственно; previousSibling и nextSibling - свойства для возврата соседей, первое возвращает предыдущий узел, второе - следующий узел. Всё это происходит в границах одного элемента, то есть общего родителя; для того, чтобы получить родительский узел существует свойство parentNode. Данные 6 методов возвращают любой тип узла - это может быть текст или комментарий. Для передвижения только по узловым элементам существует еще 6 методов: parentElement; children; firstElementChild; lastElementChild; previousElementSibling; nextElementSibling. По сути это копии первых 6, однако, они возвращают только Node элементы.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/8mzxa4f6i91jfx0s2jlz6/dom-links-2x.webp?rlkey=25ju7u0bg7zqplbwp27h84af7&st=rk6hsy1e&dl=1","https://www.dropbox.com/scl/fi/dzjdrvhdh93w3wybjpwth/dom-links-elements-2x.webp?rlkey=5xinxqt8nndr0hlfktwwpjw66&st=ek1y206x&dl=1"]
  },
  "j212":{
    "id":"08f36e234",
    "theme":"jib",
    "question":"Виды событий в JavaScript?",
    "answer":"Список часто используемых DOM-событий: События мыши: mousedown, mouseup - события нажатия/отпускания кнопки мыши; click - включают оба описанные ранее события; dblclick - двойное нажатие; mousemove - это событие перемещения курсора; mouseover - срабатывает при вхождении курсора мыши в область принадлежащей целевому элементу и другим элементам вложенным в него; 2. Клавиатурные события: keydown и keyup - когда пользователь нажимает/отпускает клавиатуру; keypress - событие происходит когда пользователь нажал клавишу на клавиатуре над элементом. 3. События формы: submit - подтверждение отправки формы; focus и blur - фокусировка и расфокусировка определенного поля формы; change - срабатывает при изменении данных внутри input поля или textarea; reset - событие происходит перед очисткой формы. 4. События перетаскивания: dragstart и dragend - срабатывает когда пользователь начал/закончил перетаскивание элемента; drag - вызывается непосредственно в момент перемещения элемента.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/dng73qgyzgwiz0vijdcv7/javascript-events.webp?rlkey=j6r2y3pe1lq2addps429rod7g&st=ngg47iix&dl=1"]
  },
  "j213":{
    "id":"08f36e235",
    "theme":"jib",
    "question":"Как добавить обработчик события на DOM-элемент?",
    "answer":"В браузерном JavaScript есть три основных способа добавления обработчика на элемент: встроенный обработчик событий в этом случае добавление происходит непосредственно в HTML разметке на элемент. Плюсом подхода является то, что элемент, на который требуется добавить событие, не нужно искать. Минус - на элементе может быть только один обработчик; свойства обработчика событий. В этом случае элемент нужно сначала найти в разметке, а затем свойство эквивалентное обработчику, например, onclick, onsubmit, onmousemove и т.д., присвоить вызываемую функцию. Минус - если на один элемент нужно повесить два обработчика , то такой способ не подойдет. О двух этих вариантах полезно знать и рассказывать при ответе на вопрос, но на практике в реальных проекта нужно использовать третий вариант. Добавления события через функцию addEventListener(). Порядок действия точной такой же как  во втором варианте.: сначала в разметке ищется элемент; на него используя addEventListener() добавляется обработчик в функцию двумя первыми аргументами передается название события без приставки “on” и callback, который будет вызван.",
    "codeexample":"const testFunc = () => console.log('Hello world!');\n\n// Inline event handler\n<button onclick=\"testFunc()\">Press me</button>\n\n// Event handler properties\nconst btn = document.querySelector('button');\nbtn.onclick = testFunc();\n\n// Function 'addEventListener'\nconst btn = document.querySelector('button');\nbtn.addEventListener('click', testFunc);",
    "images":[]
  },
  "j214":{
    "id":"08f36e236",
    "theme":"jib",
    "question":"Как удалить обработчик события с DOM-элемента?",
    "answer":"Самый часто используемый подход, который применяется для добавления события на элемент это функция addEventListener(), и если такой вариант используется в коде, то для удаления с элемента обработчика, применяется функция которая по аналогии называется removeEventListener(). Её особенностью и плюсом является то, что как и addEventListener() в качестве двух первых аргументов она принимает те же самые данные, т.е. названия события и callback-функцию.",
    "codeexample":"const testFunc() => console.log('Hello world!');\n\nconst btn = document.querySelector('button');\n\nbtn.addEventListener('click', testFunc); // Add event handler\nbtn.removeEventListener('click', testFunc); // Remove event handler",
    "images":[]
  },
  "j215":{
    "id":"08f36e237",
    "theme":"jib",
    "question":"Сколько аргументов принимает addEventListener?",
    "answer":"Функция addEventListener, с помощью которой на элемент можно добавить обработчик события, принимает 3 аргумента - два обязательных и один опциональный. Имя событий без приставки “on”, например, click, dblclick. submit, reset и т.д. 2. Callback-функция, которая будет вызвана при срабатывании события. 3. Является опциональным и может быть либо объектом, либо булевым значением. Если это объект он принимает 3 основных свойства: once со значениями true или false, при определения значения как true обработчик будет автоматически удален после выполнения, т.е. callback-функцию можно вызвать только один раз; capture - также определяется через булевое значение, данное свойство определяет на какой фазе должен сработать обработчик, если true - событие будет перехвачено на стадии погружения, а не всплытия. Поскольку это часто используемый параметр, то вместо определения объекта можно воспользоваться сокращенной формой записи и просто передать булевое значение;passive, если его значение определено как true, то обработчик никогда не вызовет preventDefault. Дополнительно существует mouse systemgroup, useCapture, wantsUntrustes, но это специфичные кейсы, которые используются очень редко.",
    "codeexample":"const testFunc = () => console.log('Hello world!');\nconst btn = document.querySelector('button');\n\n// Default\nbtn.addEventListener('click', testFunc);\n\n// once\nbtn.addEventListener('click', testFunc, { once: true });\n\n// capture\nbtn.addEventListener('click', testFunc, { capture: true });\nbtn.addEventListener('click', testFunc, true);\n\n// Combination\nbtn.addEventListener('click', testFunc, {\n\tonce: true,\n\tcapture: true,\n\tpassive: true,\n});",
    "images":[]
  },
  "j216":{
    "id":"08f36e238",
    "theme":"jib",
    "question":"Разница между innerHTML и outerHTML?",
    "answer":"Оба свойства предназначаются для возврата разметки HTML элемента. Свойство innerHTML содержит HTML-код, который находится внутри найденного элемента. При установке нового значения этого свойства внутренний HTML-код изменяется и рендерится браузером заново. Свойство outerHTML работает аналогично innerHTML. Разница заключается в том, что outerHTML  возвращает полный HTML-код найденного элемента.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/m39qit1lw8cdgvi150x90/1232210-20230920154304417-95251847.webp?rlkey=64hha01rsyjgtktxqz8j7qt0h&st=96d76lgy&dl=1"]
  },
  "j217":{
    "id":"08f36e239",
    "theme":"jib",
    "question":"Расскажите про координаты в браузере?",
    "answer":"Чтобы перемещать и позиционировать элементы на экране в браузере имеется система координат. Оси координат начинаются в левом верхнем углу экрана и идут вправо для оси X и вниз для оси Y. Позиционирование с помощью координат может быть относительно окна браузера или относительно отдельного элемента. Всего существует две системы координат: одна начинается от угла HTML страницы, а вторая от угла окна браузера. С помощью первой можно определять, как элемент расположен относительно всей страницы, а с помощью второй, как элемент расположен относительно окна браузера и того, что там находится. Объекты, события мыши и тач события содержат координаты места на экране и в документе, где событие произошло page X page Y - для документа, client X и client Y - для экрана. Координатами элемента является расстояние в пикселях от осей системы координат до левого верхнего угла. С помощью метода элемента Get bounding line tracking можно получить подробные данные о координатах элемента и его размере.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/mwr68xs3ev9u14nkiujft/download.webp?rlkey=8d19djb2k5dmwnqadjwz2fdqg&st=oe84g4lk&dl=1"]
  },
  "j218":{
    "id":"08f36e240",
    "theme":"jib",
    "question":"Разница между JSON и XML?",
    "answer":"JSON - это формат обмена данными, xml - это язык разметки, в котором можно задавать синтаксис, структуру, типы данных и их модель. JSON позволяет определять данные любого формата. В то время как в xml есть свои правила и ограничения, JSON более компактный, так как представляет из себя формат ключ-значение. xml - объёмный т.к. данные оборачиваются в разметку и за счёт этого нюанса парсинг данных в xml формате происходит медленнее, чем парсинг данных в JSON формате.Оба могут быть использованы для передачи данных и для работы с обоими стандартами используются различные фреймворки и библиотеки.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/1knr2izjq2yyeu4nl32we/json-vs-xml.webp?rlkey=rpwpssgwk2b9opwlxrfxaluyr&st=08wm0gzd&dl=1"]
  },
  "j219":{
    "id":"08f36e241",
    "theme":"jib",
    "question":"Как узнать об использовании метода event.preventDefault()?",
    "answer":"У объекта события можно вызвать специальный метод preventDefault который отменит выполняемые по умолчанию действия. Например, если его добавить на кнопку submit, которая находится в форме, то при клике на эту кнопку форма перестанет отправляться. Однако, помимо вызова метода может понадобиться проверка, а был ли вызван данный метод у объекта события для такой проверки есть специальное свойство которое называется defaultPrevented, находится оно также внутри объекта события и возвращает булевое значение true, если метод preventDefault был вызван и false если данный метод на событии не вызывался.",
    "codeexample":"const anchor = document.getElementById('myAnchor');\n\nanchor.addEventListener('click', (event) => {\n\tevent.defaultPrevented; // false\n\tevent.preventDefault();\n\tevent.defaultPrevented; // true\n});",
    "images":[]
  },
  "j220":{
    "id":"08f36e242",
    "theme":"jib",
    "question":"Для чего используется свойство window.navigator?",
    "answer":"Если говорить просто, то свойство navigator возвращает объект описания приложения, которое выполняет скрипт. В подавляющем большинстве случаев данным приложением является браузер. Сам объект содержит свойства описывающее браузер и методы для выполнения действий. Из самого свойства можно получить немного полезной информации о настройках браузера у клиента, в частности, используя свойство userAgent, можно узнать, какой именно браузер использует пользователь. language возвращает предпочитаемый язык интерфейса в виде языкового тега, languages возвращает массив предпочитаемых языков в порядке предпочтительности, cookieEnabled возвращает true, если браузер пользователя поддерживает куки и они включены, в противном случае возвращается false.",
    "codeexample":"navigator.userAgent\n// \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\"\n\nnavigator. Language\n// \"ru\"\n\nnavigator. Languages\n// [\"ru\", \"en-US\", \"es-ES\"]\n\nnavigator.cookieEnabled\n// true",
    "images":[]
  },
  "j221":{
    "id":"08f36e243",
    "theme":"jib",
    "question":"Для чего используется метод .focus()?",
    "answer":"Вызов метода focus() на DOM элементе, устанавливает фокус на этот элемент. Когда элемент находится в фокусе он перехватывает и обрабатывает события клавиатуры. Важный нюанс заключается в том, что фокус нельзя установить на элемент, если тот заблокирован. Например, если у кнопки или поля ввода стоит атрибут disabled, то фокус на этот DOM элемент установлен не будет. Обычно метод focus() вызывается без аргументов, однако по умолчанию браузер прокручивает страницу до элемента, на который перемещён фокус. Если такое поведение не нужно, то в метод можно дополнительно передать объект со свойством preventScroll. Если preventScroll установлен в true, то прокрутки страницы к элементу не произойдёт, если preventScroll установлен false - это значение по умолчанию, браузер прокрутит страницу до сфокусированного элемента. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/9eptv0mqlw8agq73vuj2u/610234c7e9882140331ef0e609b982f3.gif?rlkey=zlhpcg08rw9xygmhsxu3qc2q1&st=dto0sij4&dl=1"]
  },
  "j222":{
    "id":"08f36e244",
    "theme":"jib",
    "question":"Для чего используется свойство .forms?",
    "answer":"forms - это поле или свойство объекта document. Оно хранит коллекцию всех элементов форм, которые есть на текущей открытой странице, данная коллекция доступна только для чтения. Если на странице форм нет, тогда возвращённый результат будет пустым, а длина коллекции равна нулю. В качестве примера можно взять страницу с тремя формами: форма для применения промокода, форма с полем для подписки на рассылку и форма авторизации с помощью номера телефона. При обращении к свойству forms мы получим живую коллекцию или HTML Collection которая очень напоминает массив, но также она позволяет обращаться к элементам по их имени или идентификатору. Формы, у которых указаны атрибуты ID или name, можно получить по значению этих атрибутов, в остальных случаях получить форму можно по индексу, который совпадает с порядком описания форм на странице. ",
    "codeexample":"<form>\n\t<label for=\"promocode\">Пpoмokoд</label>\n\t<input id=\"promocode\" type=\"text\" name=\"promocode\" placeholder=\"WIN-1234\" required>\n\t<button type=\"submit\">Применитb</button>\n</form>\n\n<form id=\"subscriptionFormId\">\n\t<label for=\"email\">Пoчra</label>\n\t<input id=\"email\" type=\"email\" name=\"email\" placeholder=\"email@example.com\" required>\n\t<button type=\"submit\">Пoдписьcя</button>\n</form>\n\n<form id=\"loginFormId\" name=\"loginFormName\">\n\t<label for=\"phone\">Baш Hoмep</label>\n\t<input id=\"phone\" type=\"tel\" name=\"phone\" placeholder=\"776-2323\" required>\n\t<button type=\"submit\">Отправить код подтверждения</button>\n</form>\n\n// Promocod form \ndocument.forms[0]\n\n// Newsletter subscription form\ndocument.forms[\"subscriptionFormId\"]\ndocument.forms.subscriptionFormId\n\n// Login form\ndocument.forms['loginFormName']\ndocument.forms.loginFormName",
    "images":[]
  },
  "j223":{
    "id":"08f36e245",
    "theme":"jib",
    "question":"Для чего используется метод .scrollIntoView()?",
    "answer":"Метод scrollIntoView() позволяет программно прокрутить окно до определённого элемента вне зависимости от положения элемента в окне. Следует отметить, что прокручивание осуществляется таким образом, чтобы элемент, на котором был вызван scrollIntoView() стал виден пользователю. scrollIntoView() может быть аргумент булевого типа если указать true, то скролл будет перемещён, чтобы верхняя граница элемента совпадала с верхней границей окна, если указать false то скролл остановится так, чтобы нижняя граница элемента была вровень с нижней границей окна. Дополнительно можно указать объект, который более точно определит механизм прокрутки. В нём можно определить свойства behavior, которые задают анимацию прокрутки и принимает значение auto или smooth - это главная прокрутка, block определяет вертикальное выравнивание, принимает start, center, and и nearest, и inline - определяет горизонтальное выравнивание и также принимает аналогичное значение как и блок.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/rczp8wlz8at7mzw08hb8l/Screenshot_2020-08-09_at_14.33.29.webp?rlkey=qbzgplc5vk1rr6o0p4s2n8ive&st=k4g3pkxe&dl=1"]
  },
  "j282":{
    "id":"08f36e370",
    "theme":"jib",
    "question":"Как использовать media выражения в JavaScript?",
    "answer":"Чтобы определить соответствует ли документ строке  media запроса в JavaScript, можно использовать метод  matchMedia. Несмотря на то, что он официально является частью спецификации модуля представления объектной модели  CSS, которая  сейчас находится в статусе рабочего проекта, у него отличная браузерная поддержка. Его использование почти идентично  media запросам в CSS. В качестве аргумента в него передаётся строка media запроса.\nМетод matchMedia возвращает ‘Media Query List’. Это объект, который хранит информацию у media запроса, поэтому из него нужно использовать именно ключевое слово ‘matches’. Это логическое свойство только для чтения, которое возвращает true, если документ соответствует мультимедийному  запросу.\nТаким образом, применяя синтаксис медиа запросов из CSS, их можно можно использовать и в JavaScript.",
    "codeexample":"const mediaQuery = window.matchMedia(' (min-width: 768px)');\n\nconsole.log(mediaQuery);\n// {media: (min-width: 768px)', matches: false, onchange: null}\n\nif (mediaQuery.matches) {\nconsole.log('Media Query Matched!');\n}",
    "images":[]
  },
  "j283":{
    "id":"08f36e371",
    "theme":"jib",
    "question":"Как использовать media выражения в JavaScript?",
    "answer":"Чтобы определить соответствует ли документ строке  media запроса в JavaScript, можно использовать метод  matchMedia. Несмотря на то, что он официально является частью спецификации модуля представления объектной модели  CSS, которая  сейчас находится в статусе рабочего проекта, у него отличная браузерная поддержка. Его использование почти идентично  media запросам в CSS. В качестве аргумента в него передаётся строка media запроса.\nМетод matchMedia возвращает ‘Media Query List’. Это объект, который хранит информацию у media запроса, поэтому из него нужно использовать именно ключевое слово ‘matches’. Это логическое свойство только для чтения, которое возвращает true, если документ соответствует мультимедийному  запросу.\nТаким образом, применяя синтаксис медиа запросов из CSS, их можно можно использовать и в JavaScript.",
    "codeexample":"const mediaQuery = window.matchMedia(' (min-width: 768px)');\n\nconsole.log(mediaQuery);\n// {media: (min-width: 768px)', matches: false, onchange: null}\n\nif (mediaQuery.matches) {\nconsole.log('Media Query Matched!');\n}",
    "images":[]
  },
  "j284":{
    "id":"08f36e372",
    "theme":"jib",
    "question":"Разница между методами .submit() и .requestSubmit()?",
    "answer":"Для начала можно отметить общую задачу, которую решают данные методы - это отправка данных формы. Если посмотреть на пример разметки, то можно увидеть, что у поля name есть атрибут ‘required’.\n\nКак сработал бы обычный .submit в том случае, если значение  name отсутствует? Он подсветит ошибку, но при этом отправит форму, так как его совсем не волнует  валидна форма или нет.\n\nКак сработает .requestSubmit() в этом случае? Он подсветит ошибку и не отправит форму до тех пор, пока она не будет валидна.\n\nТаким образом, используя комбинацию JavaScript и атрибутов HTML, можно реализовать нативную валидацию и блокировку отправки при её не прохождении. Важный нюанс, .requestSubmit() - довольно свежий метод и хоть он работает почти везде, но тем не менее нужно иметь  в виду браузерную поддержку.",
    "codeexample":"<form action=\"/changename\">\n\t<label for=\"name\">Name</label>\n\t<input type=\"text\" id=\"name\" required>\n</form>\n\n<button>Change name</button>\n\n<script>\n\tconst btn = document.querySelector('button'); const form = document.querySelector('form');\n\n\tbtn.addEventListener('click', function () {\n\t\tform.submit();\n\t});\n\t// or\n\tbtn.addEventListener('click', function () {\n\t\tform.requestSubmit();\n\t});\n</script>",
    "images":[]
  },
  "j285":{
    "id":"08f36e373",
    "theme":"asyncjs",
    "question":"SSR (Server-Side Rendering) и CSR (Client-Side Rendering) плюсы и минусы?",
    "answer":"SSR- означает, что html страница полностью генерируется на сервере.\n\nCSR- означает, что страница загружается пустой, а затем javascript на клиенте генерирует html код.\n\nК плюсам с SSR можно отнести:\n\t-более быстрое первое отображение.  Поскольку пользователь видит html страницу сразу после загрузки, не нужно ждать, пока javascript завершит свою работу;\n\t-лучший SEO. Готовая разметка, возвращаемая сервером, лучше индексируется;\n\t-обработка большинства задач на сервере сберегает ресурсы на устройстве пользователя.\n\nМинусы SSR:\n\t-сложность. Серверный рендеринг может привести к сложному коду, поскольку некоторые паттерны, библиотеки, созданные для работы на клиенте могут не работать или работать не эффективно на сервере;\n\t-нагрузка на сервер. Чем больше обрабатывает сервер, тем быстрее он может упасть под большой нагрузкой;\n\t-разрыв времени ответа. Запрос на сервер занимает больше времени, чем отработка на клиенте.\n\nК преимуществам CSR можно отнести:\n\t-ресурсы сервера. Всю обработку осуществляет браузер пользователя, что может сохранить серверные ресурсы;\n\t-быстрые переходы после первоначальной загрузки. Если все необходимые данные уже загружены и приложение работает в браузере, то переходы между страницами и интерактивные вещи могут происходить быстрее, чем в SSR.\n\nНедостатки CSR:\n\t-позднее отображение. Пользователи могут видеть пустую или частично загруженную страницу, пока не выполнится весь javascript;\n\t-проблемы с SEO. Как уже упоминалось, из-за возврата пустой разметки страницы, которая впоследствии генерируется JSом;\n\t-большая нагрузка на клиентский код. Все данные загружаются и обрабатываются на клиенте что, может быть проблематично для устройств с малой вычислительной мощностью.",
    "codeexample":"",
    "images":[]
  },
  "j286":{
    "id":"08f36e374",
    "theme":"asyncjs",
    "question":"Что такое OSI модель?Что такое REST и RESTful api?",
    "answer":"Если говорить просто, то REST-  это набор архитектурных принципов построения сервис ориентированных систем. RESTful- прилагательное, употребляющееся по отношению к сервисам, которое следуют принципам REST.\n\nДля того, чтобы распределенные системы считались спроектированными по REST архитектуре, необходимо, чтобы они удовлетворяли следующим критериям:\n\t- client server. Система должна быть разделена на клиент и на сервер;\n\t- stateless. Сервер не должен хранить какой-либо информации о клиентах;\n\t- в запросе должна храниться вся необходимая информация для его обработки, и, если необходимо, идентификации клиента;\n\t- КЭШ. Каждый ответ должен быть помечен является он кэшируемым или нет;\n\t- uniform interface. Универсальный интерфейс между компонентами системы;\n\t- convenient presentation of data (удобное представление данных). Другими словами, возвращаемые данные должны быть в одном из распространенных форматов обмена. Например, xml, html или JSON.",
    "codeexample":"",
    "images":[]
  },
  "j287":{
    "id":"08f36e375",
    "theme":"asyncjs",
    "question":"Разница между preload, prefetch, preconnect и prerender?",
    "answer":"Все 4 варианта это значение атрибута rel, который используется для разных вариантов оптимизации загрузки ресурсов.\n\nPreload говорит браузеру, как можно скорее загрузить и кэшировать ресурс. Например, скрипт или таблицу стилей. Это полезно, когда ресурс понадобится через несколько секунд после загрузки страницы, и нужно ускорить этот процесс. Следует отметить, что браузер ничего не делает с ресурсом после загрузки. Скрипты не выполняются, таблицы стилей применяются. Ресурс просто кэшируется и в последующем немедленно предоставляется по запросу.\n\nPrefetch просит браузер загрузить и кэшировать ресурс. Например, скрипт или таблицы стилей в фоновом режиме. Загрузка происходит с низким приоритетом, поэтому не мешает более важным ресурсам. Это полезно, если ресурс понадобится на следующей странице и нужно заранее его кэшировать. Здесь тоже браузер ничего не делает с ресурсом после загрузки.\n\nPreconnect просит браузер заранее подключиться к домену, когда требуется ускорить установку соединения в будущем. Установка нового соединения обычно занимает несколько сотен миллисекунд. Она производится 1 раз, но все равно отнимает время. Если заранее установить соединение, то можно сэкономить время и быстрее загрузить ресурсы с домена.\n\nPrerender просит браузер загрузить URL адрес и отобразить его на невидимые вкладки. Поэтому, когда пользователь нажимает на ссылку, страница должна отобразиться немедленно. Это полезно, если мы уверены, что пользователь посетит определенную страницу и хотим ускорить ее отображение.",
    "codeexample":"",
    "images":[]
  },
  "j224":{
    "id":"08f36e246",
    "theme":"asyncjs",
    "question":"Разница между синхронными и асинхронными функциями?",
    "answer":"Синхронные функции являются блокирующими - все дальнейшие операции блокируются, пока не будет выполнена данная функция. Асинхронные функции не блокируют дальнейшее выполнение скрипта. ",
    "codeexample":"",
    "images":[]
  },
  "j225":{
    "id":"08f36e247",
    "theme":"asyncjs",
    "question":"Что такое AJAX?",
    "answer":"AJAX (Asynchronous JavaScript and XML) - термин, который описывает подход использования нескольких существующих технологий вместе для работы на стороне клиента и для создания асинхронных web-приложений. С помощью AJAX  web-приложения могут отправлять данные на сервер и получать их с сервера асинхронно, таким образом происходит отделение логики представления (отрисовки UI) от логики обмена данными. В результате страницы могут динамически изменять содержимое без полной перезагрузки, поэтому они работают быстрее  и становятся более отзывчивыми к действиям пользователя. На практике для получения или передачи данных используют формат данных JSON вместо XML, из-за того, что JSON основан на JavaScript, а для работы с асинхронными запросами используют новый метод fetch вместо устаревшего XMLHttpRequest.",
    "codeexample":"// Updating a user\nfetch('https://jsonplaceholder.typicode.com/users/3', {\n\tmethod: 'PUT',\n\tbody: JSON.stringify({\n\t\tusername: 'Elon Musk',\n\t\temail: 'elonmusk@gmail.com',\n\t\tuserId: 1\n\t}),\n\theaders: { \"Content-Type\": \"application/json; charset=utf-8\"\n})",
    "images":["https://www.dropbox.com/scl/fi/noqnfvv8nuuinyfynqqs8/AJAX-how-works.png.webp?rlkey=amcthcx431r4b33bdymzj1gzj&st=1iv4gt2c&dl=1"]
  },
  "j226":{
    "id":"08f36e248",
    "theme":"asyncjs",
    "question":"Что такое same-origin policy в контексте JavaScript?",
    "answer":"Same-origin policy или принцип одинакового источника определяет как документ или скрипт, загруженный из одного источника, может взаимодействовать с ресурсом из другого источника.  Этот принцип не позволяет JavaScript выполнять запросы за границей домена. Источник определяется как комбинация схемы uri имени хоста и номера порта. Это помогает изолировать потенциально вредоносные документы и не дает вредоносному сценарию на одной странице  получить доступ к конфиденциальным данным на другой. Для того, чтобы разрешить запросы такие кроссдоменные запросы используются corse.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/aukasuv8ralfafxf9mvsd/0401e145c764718ca2276853ec9cbf9c.webp?rlkey=ak6e3fxer98nhewdzdpq1lz3v&st=9viu1f6n&dl=1"]
  },
  "j227":{
    "id":"08f36e249",
    "theme":"asyncjs",
    "question":"Что такое цикл событий (event loop) и как он работает?",
    "answer":"JavaScript является однопоточным, другими словами движок JavaScript  в одну единицу времени может выполнять только одну операцию. Для такого потока выделяется область памяти, которая называется Stack. В Stack хранятся frame - это локальные переменные и аргументы вызываемых функций. Список событий, которые должны обрабатываться формируют очередь событий. Когда Stack освобождается движок может обработать любое событие из этой очереди. Координирование этого процесса происходит в event loop, по сути это бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая движок браузера ждет когда поступит  новое событие, если не пустая, то первое событие из очереди извлекается и обработчик начинает его выполнять и так до бесконечности.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/xgcbve5hvlohjr9jbynt1/h2-xajggqa9vcloczh7owhqiffc.webp?rlkey=a8lm07w9pbxgt967571uz9ok6&st=2f3pi1jj&dl=1"]
  },
  "j228":{
    "id":"08f36e250",
    "theme":"asyncjs",
    "question":"Что такое CORS?",
    "answer":"В целях безопасности браузеры ограничивают кроссдоменные запросы, которые создаются скриптами, то есть XMLHttpRequest и fetch следуют политике одного источника или same-origin policy. Это значит что веб-приложения, которые используют такие API  могут запрашивать ресурсы только с того домена, с которого они были загружены. CORS (Cross-origin resource sharing) - это механизм, который использует дополнительные Http заголовки, чтобы дать возможность браузеру пользователя получать разрешение на доступ к  выбранным ресурсам сервера или домена, которые отличаются от того, что сайт использует в данный момент.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/aukasuv8ralfafxf9mvsd/0401e145c764718ca2276853ec9cbf9c.webp?rlkey=ak6e3fxer98nhewdzdpq1lz3v&st=9viu1f6n&dl=1"]
  },
  "j229":{
    "id":"08f36e251",
    "theme":"asyncjs",
    "question":"Что такое промисы (Promises)?",
    "answer":"Промисы - это один из приемов работы с асинхронным кодом в JS. Промис - это объект, который может вернуть одно значение в будущем, либо выполненное значение, либо причина, по которой промис не был выполнен, т.е. ошибку. \nПромис может находиться в одном из трех возможных состояний: \n1.выполнено (fulfilled); \n2.отклонено (rejected); \n3.ожидает выполнения (pending). \nПри использовании промисов можно добавлять callback-функции для обработки выполненного значения или причиной отказа. Для такого взаимодействия используются chaining или цепочка вызовов с методами .then() и .catch()",
    "codeexample":"\n// Callbacks\nconst done = () => {\n\tconsole.log(\"done\");\n};\nconst error = () => {\n\tconsole.error(\"error\");\n};\n\n// Promise creation\nconst promise = new Promise((resolve, reject) => {\n\tresolve();\n\treject();\n});\n\n// Work with promise\npromise\n\t.then (done)\n\t.catch(error);",
    "images":["https://www.dropbox.com/scl/fi/82ldswne2z3srvqgpbfik/3588ce49-a480-46fe-a229-9dafafa4c61d.webp?rlkey=2j4gzd1g95qwn9zqsiyhe18mr&st=a1v13c08&dl=1"]
  },
  "j230":{
    "id":"08f36e252",
    "theme":"asyncjs",
    "question":"Плюсы и минусы использовании Ajax?",
    "answer":"К плюсам можно отнести следующее:\n -повышение интерактивности - новые данные сервера могут быть добавлены динамически без перезагрузки всей страницы;\n -сокращение количества обращений к серверу - скрипты и таблицы стилей нужно запрашивать только один раз;\n -хранение состояния страницы - переменная JS и состояние DOM сохраняется, поскольку основная страница контейнера не перезагружается.\nМинусы:\n -проблемная реализация добавление динамической веб-страницы в закладке, так как данные добавляются динамически любые операции нужно хранить, например, в URL-адресе, чтобы при повторном открытии не начинать все с нуля.\n -Ajax не работает если в браузере отключен javascript;\n -некоторые поисковые роботы не выполняют javascript и не видят данные, загружающиеся при помощи javascript.",
    "codeexample":"",
    "images":[]
  },
  "j231":{
    "id":"08f36e253",
    "theme":"asyncjs",
    "question":"Подходы при работе с асинхронным кодом?",
    "answer":"Асинхронные код или асинхронные функции - это функции, которые не блокируют основной поток исполнения. Из-за такой особенности, если между функциями имеется зависимость, их нужно обрабатывать последовательно. Для этого можно воспользоваться следующими подходами:\n1.Callback - механизм достаточно прост. Внутри одной асинхронной функции записывается другая и так далее, до тех пор пока не получится многоуровневая вложенность. Стоит отметить, что данный механизм немного устарел и от него стараются отказываться из-за его Callback Hell, то есть из-за очень большой вложенности;\n2.Использование Promise. В данном случае асинхронная функция возвращает специальный объект, которая называется Promise, используя его, а также специальные методы then и catch можно обрабатывать получаемые данные и передавать их дальше по цепочке;\n3.Конструкция Async/Await . Для общей функции добавляется ключевое слово async(), а внутри каждая асинхронная операция помещается как await, таким образом исполнение асинхронного кода идет  наподобие синхронного.",
    "codeexample":"// Callback\nfs.readFile(\"./test.txt\", 'utf-8', (error, data) => {\n\tfs.mkdir(\"./files\", () => {\n\t\tfs.writeFile(\"./files/test2.txt\", `${data} New text!', (error) =>\n{});\n\t});\n});\n\n// Promice\nconst fetchUser = () => {\n\tfetch('https://randomuser.me/api/')\n\t\t.then(response => response.json())\n\t\t.then(data => { setUser(data.results[0]); })\n\t\t.catch(error) { console.log(error); }\n}\n\n// Async/Await\nconst fetchUser = async () => {\n\tconst response = await fetch('https://randomuser.me/api/');\n\tconst data = await response.json();\n\tsetUser(data.results[0]);\n}",
    "images":[]
  },
  "j232":{
    "id":"08f36e254",
    "theme":"asyncjs",
    "question":"Преимущества использовании промисов вместо колбэков?",
    "answer":"1.Помогает избежать Callback Hell, который может быть нечитаемым;\n2.Упрощает написание последовательного, читаемого, асинхронного кода с помощью then, а также обработку ошибок с помощью catch;\n3.Упрощает написание параллельного асинхронного кода с помощью Promise All;\n4.С использованием промисов можно избежать следующих проблем, которые возникают при использовании коллбэк-функции:\n-коллбэк-функция была вызвана слишком рано или поздно, либо слишком мало или много раз;\n-пропуск ошибок или исключений;\n-не удалось передать необходимую среду или параметр.",
    "codeexample":"",
    "images":[]
  },
  "j233":{
    "id":"08f36e255",
    "theme":"asyncjs",
    "question":"Что такое коллбэк-функция (Callback)? Что такое Callback Hell?",
    "answer":"Колбэк-функция или функция обратного вызова - это передача исполняемого кода в качестве одного из параметров в другой код. Другими словами - это передача одной функции в виде параметра в другую. Такой обратный вызов позволяет функции исполнять код, который задаётся в аргументах при её вызове. Колбек функции очень распространены и могут использоваться функциях высшего порядка таких как map, filter, reduce и так далее, в таймерах, в асинхронных функциях чтобы гарантировать правильный порядок вызовов, а также в браузерном javascript. Например, при добавлении события в случае использования функции обратного вызова в асинхронных функциях  может получиться случай так называемого callback Hell - это такая вложенность колбеков при которой получается несколько уровней, то есть первая функция вызывает вторую, вторая третью, третья четвёртую и так далее. В результате получается плохо читаемый код который трудно поддерживать. ",
    "codeexample":"// HOC\n[1, 2, 3, 4].forEach (element => console.log(element));\n\n// Timer\nsetTimeout(() => alert('Hello world'), 1000);\n\n// Even callback\nbtnAdd.addEventListener('click', function clickCallback(e) {\n\t// do something\n});\n\n// Callback Hell\nfs.readFile('somefile.txt', function (e, data) {\n\t// do something\n\t\fs.readdir('directory', function (e, files) {\n\t\t// do something\n\t\tfs.mkdir('directory', function (e) {\n\t\t\t// do something\n\t\t});\n\t});\n});",
    "images":[]
  },
  "j234":{
    "id":"08f36e256",
    "theme":"asyncjs",
    "question":"Что такое async/await?",
    "answer":"async/await - это новый способ написания асинхронного или не блокирующего кода в JavaScript. Он построен на основе промисов, и это делает написание асинхронного кода более читаемым и чистым, чем  промисы и функции обратного вызова или колбеки. async/await заставляет код, который работает асинхронно выглядеть как синхронный код. Это именно то, ради чего его используют. Ключевое слово async перед объявлением функции заставляет функцию неявно возвращать промис. Ключевое слово await можно использовать только внутри асинхронной функции, использование ключевого слова await в любой другой функции, которая не является синхронной, вызовет ошибку. Ключевое слово await ожидает возврата выражения из правой части, предположительно промис, перед выполнением следующей строки кода. Таким образом асинхронный код выполняется последовательно. Особенно это полезно, если один запрос зависит от результата другого. Используется async/await чаще с конструкцией try/catch, которая позволяет отлавливать ошибки в асинхронных запросах.",
    "codeexample":"async function callApi() {\n\ttry {\n\t\tconst resp = await fetch(\"url/to/api/endpoint\");\n\t\tconst data = await resp.json();\n\t\t//do something with \"data\"\n\t} catch (e) {\n\t\t//do something with \"err\"\n\t}\n}",
    "images":[]
  },
  "j235":{
    "id":"08f36e257",
    "theme":"asyncjs",
    "question":"Разница между Promise.all(), Promise.any() и Promise.race()?",
    "answer":"Все три метода предназначены для работы с промисами и в качестве аргумента они принимают массив промисов. Promise.all() - это промис, принимающий массив других промисов, в качестве аргумента и возвращающий результат выполнения промисов или ошибку при отклонении одного из них. Основное отличие - все промисы должны резолвнуться, тогда будет получен результат. Promise.race() возвращает результат первого выполненного или отклонённого промиса из переданных ему в виде массива промисов, то есть результат возвращается из первого резолвнутого или реджектнутого промиса.  Promise.any() - это комбинация двух ранее описанных вариантов. Вернёт результат первого резолвнутого промиса То есть отработает как race, но reject вернётся  только в том случае если упадут все переданные промисы.",
    "codeexample":"Promise.any([\n\tresolveIn(500, 'success'),\n\trejectIn(400, 'fail')\n])\n.then(console.log);\n\n\"success\"\n\n\nPromise.race([\n\tresolveIn(500, 'success'),\n\trejectIn(400, 'fail')\n])\n.catch(console.log);\n\"fail\"",
    "images":["https://www.dropbox.com/scl/fi/uo473d53g7z0oswrp5ele/5551b1f90818c86387e4457db2ad8179d6289721.webp?rlkey=oobyixrelmpxifs8z9xpfg71f&st=kwqkxqa7&dl=1"]
  },
  "j236":{
    "id":"08f36e258",
    "theme":"asyncjs",
    "question":"Расскажите про статический метод .allSettled()?",
    "answer":"Метод .allSettled() - это один из статических методов объекта promise, его используют, когда нужно запустить несколько промисов параллельно и дождаться их выполнения. Promise.allSettled() очень похож на Promise.all(), но работает немного по-другому. В отличие Promise.all(), Promise.allSettled() ждет выполнения всех промисов, при этом неважно, завершились они успешно или с ошибкой, следует помнить, что в случае с Promise.all() resolve возвращается только если все параллельные промисы завершились успешно, reject - если хоть один из промисов упал. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/1eb622b9mauk4v0oo9jhk/1-1.webp?rlkey=l0ywg5lbmqyx6l4vter2pivrx&st=pd4yjrno&dl=1"]
  },
  "j237":{
    "id":"08f36e259",
    "theme":"webh",
    "question":"Что такое прогрессивный SSR?",
    "answer":"Прогрессивный рендеринг на стороне сервера или progressive server side rendering основан на концепции потоковой передачи HTML, он разбивает страницы на осмысленные самостоятельные компоненты с помощью разделения кода. Эти части страницы управляются разными скриптами, в результате появляется возможность сделать гидрацию независимо. Основными этапами прогрессивного рендеринга можно назвать следующие: браузер запрашивает у сервера html-код, сервер делает API запросы и сначала рендерит критический контент, а затем отправляет его клиенту, браузер анализирует HTML и отображает его на экране, сервер рендерит не критический контент и передаёт его браузеру, браузер анализирует и отображает не критичный контент, параллельно JS бандлы загружаются и выполняются в фоновом режиме, а браузер передаёт интерактивность элементам DOM. Прогрессивный рендеринг повышает производительность WEB приложения извлекая или визуализируя компоненты страницы параллельно.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/ftovwm503whrtslso8xhu/1_i5WWiWt3t3rAS7hgxRTuBQ.webp?rlkey=yb3y85n4td3ga89p1qj688ub1&st=f7by1uvf&dl=1"]
  },
  "j238":{
    "id":"08f36e260",
    "theme":"webh",
    "question":"Что такое Progressive Web Application (PWA)?",
    "answer":"Progressive Web Application (PWA) или прогрессивное веб приложение - это веб-сайты, которые ведут себя подобно нативным приложениям. Они могут быть установлены на телефон или компьютер, а также, как правило, работают в оффлайн. Для последнего используется сервис worker и интерфейс кеширование. Преимуществом PWA перед мобильными приложениями является их размер и относительная лёгкость разработки, не нужно тратить ресурсы на создание двух версий приложений, то есть Web и мобильной, для одного сайта, при этом сохраняется хороший пользовательский опыт.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/iohq8nn1v4smfgy3x3gmb/1_UPn7pTCi81P6cMmh6EEXUQ.webp?rlkey=65r1aczoym1xpm6f2if0gjpfa&st=0spfvl2r&dl=1"]
  },
  "j239":{
    "id":"08f36e261",
    "theme":"webh",
    "question":"Что такое поток документа?",
    "answer":"Поток - это одно из важнейших базовых понятий в вёрстке. Это принцип организации элементов на странице при отсутствии стилей, т.е., если создать html-страницу и не стилизовать её с помощью CSS, то отображение в браузере будет предсказуемо. Благодаря тому, что мы точно знаем, как браузер располагает элементы в потоке, даже если к странице не подключено никаких стилей, каждому элементу всё равно будут применяться CSS правила, зашитые в движке браузера. Благодаря этим правилам заголовок h1 крупнее заголовка h2, а ссылки синие и подчеркнутые. Это дефолтные браузерные стили, на основании этих правил условно все элементы на странице можно разделить на две категории: блочные и строчные. Например, <div> будет блочным, а <span> и <strong> -  срочными, поменять стандартное поведение можно при помощи CSS свойства display. Если вообще не применять никаких стилей, браузер формирует из элементов нормальный поток также в CSS есть свойства которые вырывают элемент из нормального потока документа, к таким свойствам можно отнести float и position.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/ghdtp1y5uriuxcsqovg3l/flow2.webp?rlkey=wyw9hw954excdw5r04d8s8us3&st=zh0bldly&dl=1"]
  },
  "j240":{
    "id":"08f36e262",
    "theme":"webh",
    "question":"Что такое Веб-компоненты и какие технологии в них используются?",
    "answer":"Веб-компоненты это технология, которая позволяет создавать многократно используемые компоненты в веб-документах и приложениях. Они поддерживаются браузерами напрямую и не требуют дополнительных библиотек для работы. Веб-компоненты включают четыре технологии, каждая из которых может использоваться отдельно от других:\n1.customEvent() - IP для создания собственных HTML элементов;\n2.HTML <template> тэг позволяет реализовать изолированные DOM-элементы;\n3.shadowDOM изолирует DOM и стили в разных элементах;\n4.HTML import или импорт HTML-документа.",
    "codeexample":"",
    "images":[]
  },
  "j241":{
    "id":"08f36e263",
    "theme":"webh",
    "question":"Особенности разработки мультиязычных сайтов?",
    "answer":"Рассмотрим основные особенности: \n- использование lang-атрибута на HTML-страницах, причем зачастую это значение может изменяться динамически;\n- автоматическое перенаправление пользователя на нужную версию сайта, проверяя установленный его язык. В крайнем случае можно сделать небольшой компонент для выбора страны и языка;\n- следует учитывать разные направления чтения (слева-направо, сверху-вниз, справа-налево). Большинство кейсов может быть решено с помощью css свойств и специальных библиотек;\n- форматирование даты и валюты - для решения данных нюансов так же есть большое количество js-библиотек;\n- использование ограничения длинных слов и предложений, речь идет об обрезке текста или слов и выставления многоточия, либо дополнительных кнопок для чтения полного описания;\n- нужно стараться не склеивать результирующие строки, так как грамматическое расположение слов в разных языках может быть разное, вместо этого можно использовать шаблон для разных языков и динамически вставлять их значения.",
    "codeexample":"",
    "images":[]
  },
  "j242":{
    "id":"08f36e264",
    "theme":"webh",
    "question":"Что такое Flash Of Unstyled Content (FOUC)? Как его избежать?",
    "answer":"Flash Of Unstyled Content (FOUC) (вспышка нестилизированного контента) или появление неоформленного контента при загрузке. Например, при первом появлении страницы текст отображается одним шрифтом, а после подгрузки нужного шрифта происходит его изменение.\nИзбежать такое поведение можно следующим путем:\n-путем вставки критичного css в head-странице. Критичный css - это минимальный набор блокирующего css, требуемого для рендеринга первого экрана с контентом, по сути это часть сайта, которую в первую очередь видит пользователь.\n-показ preloader до полной загрузки.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/7218olfvoz9eqxmhfb7sr/https___dev-to-uploads.s3.amazonaws.com_i_yftc0s00303flkhl96nf.webp?rlkey=ofmr5axsxlm4vdvdxjkajr2qa&st=t3vzhk06&dl=1"]
  },
  "j243":{
    "id":"08f36e265",
    "theme":"webh",
    "question":"Что такое History API в браузере?",
    "answer":"History API даёт доступ к управлению истории браузера в рамках текущей сессии. Браузер создаёт новую сессию, когда пользователь открывает новую вкладку или новое окно браузера. С помощью history API можно переходить по истории вперёд, назад и управлять содержимым истории. Доступ к API осуществляется с помощью объекта window.history. Основные методы - это back - перемещает пользователя по истории на странице назад, forward - перемещает пользователя по истории на страницу вперёд, go - универсальный метод для перемещения по истории вперёд или назад, pushState добавляет новую запись в истории сессии, replaceState изменяет текущую запись в истории сессии. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/9mfnlz0i3iw2e6qnsxa38/arf-1147821-vi.webp?rlkey=xmy71p95qb6zp4kehj1ungrg4&st=8fhgwjew&dl=1"]
  },
  "j244":{
    "id":"08f36e266",
    "theme":"webh",
    "question":"Что такое веб-хранилище (web storage)?",
    "answer":"web storage или web-хранилище - это интерфейс, позволяющий хранить данные в виде пары ключ-значение локально, то есть в браузере пользователя причём делать это более удобным способом, чем при использовании куки. Веб-хранилище представляет два основных механизма хранения данных - это локальное хранилище или LocalStorage - предназначено для хранения данных текущего пользователя неограниченное количество времени и сессионное хранилище или SessionStorage - служит для хранения данных на протяжении текущей сессии, то есть при закрытии вкладки браузера данные будут потеряны.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/7854kxo27v44i8bn03an0/Difference-Between-localStorage-and-sessionStorage-Comparison-Summary-new.webp?rlkey=fqlez6tac3t7r34qj64d6rbim&st=rgkssdsv&dl=1"]
  },
  "j245":{
    "id":"08f36e267",
    "theme":"webh",
    "question":"Что такое BOM?",
    "answer":"BOM Browser Object Model или объектная модель браузера - это модель, которая позволяет JavaScript взаимодействовать с браузером. Данная модель включает в себя такие объекты как navigator, location, history, screen, xml, http request и так далее, другими словами BOM - это дополнительные объекты предоставляемые браузером чтобы работать со всем кроме документов. Также следует обратить внимание, что BOM не стандартизирована, поэтому её реализация может отличаться в разных браузерах.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/b04hfyubkmrac0khb8bn7/download-1.webp?rlkey=rgb11851ihbhnsy4spuy4z6ta&st=ujgogrx6&dl=1"]
  },
  "j246":{
    "id":"08f36e268",
    "theme":"webh",
    "question":"Разница между cookie, sessionStorage и localStorage?",
    "answer":"Все три технологии используется для хранения данных на клиенте. Сами данные хранятся в виде ключ-значение в формате строки. \nКритерии сравнения:\n 1.Инициатор:\n для всех инициатор - клиент, для cookie дополнительно может быть и сервер через заголовок Set-Cookie.\n 2.Длительность хранения:\nдля cookie установка идет вручную: может быть 1 час, может быть 1 месяц; для sessionStorage пока открыта вкладка браузера данные будут доступны; localStorage хранит информацию практически неограниченное время, пока хранилище не будет очищено клиентом самостоятельно.\n 3.Связь с доменом есть только у cookie.\n 4.Емкость для cookie 4 Kb, для sessionStorage и localStorage по 5 Mb.\n 5.Место откуда данные могут быть доступны:\n 6.Информация из cookie и localStorage  доступна из любого окна в браузере, из sessionStorage только для открытой вкладки.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/90467h242fsu6bk201e8e/session-local-storage-1.webp?rlkey=xr4l4k3hn4gmtf88ynus5p4b9&st=o2ql0yuz&dl=1"]
  },
  "j247":{
    "id":"08f36e269",
    "theme":"webh",
    "question":"Способы уменьшения времени загрузки веб-страницы?",
    "answer":"1.Минификация и конкатенация css и js файлов.\n2.Оптимизация или сжатие изображений. Для изображений иконок можно применять иконочные шрифты или создать css sprite.\n3.Использование CDN.Такие сети состоят из серверов в разлиных точках мира. При подключении сайта к сети пользователю отдают данные с ближайшего к нему сервера, что в итоге увеличивает скорость загрузки.\n4.Использование jsp метода компрессии. Данный способ сжатия подключается на сервере буквально в пару строк.\n5.Использование кэширования.",
    "codeexample":"",
    "images":[]
  },
  "j248":{
    "id":"08f36e270",
    "theme":"webh",
    "question":"Что такое HTTP?",
    "answer":"HTTP(Hypertext Transfer Protocol)- это прикладной протокол для передачи гипертекстовых документов по типу HTML. В настоящее время используется для передачи произвольных данных. Создан он для связи между web-браузерами и web-серверами. HTTP протокол без сохранения состояния, то есть сервер не сохраняет никаких данных между парами запрос-ответ, а также он следует классической клиент-серверной модели, когда клиент открывает соединение для создания запроса,а затем ждет ответа. Все программное обеспечение для работы протокола разделяется на три категории:\n1.Клиент или потребитель услуг;\n2.Сервер или поставщик услуг.\n3.Прокси или посредник,используется для выполнения транспортных услуг. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/lwxqbg07weq6oknet99tp/HTTP-Request-and-Response-Over-Web-1.webp?rlkey=cu1y0tw21o8hi690m5wiy3dwm&st=ghimis7o&dl=1"]
  },
  "j249":{
    "id":"08f36e271",
    "theme":"webh",
    "question":"Из чего состоит HTTP-запрос?",
    "answer":"HTTP-запрос содержить следующие элементы:\n1.HTTP-метод: get, post, put, delete и т.д. Метод помогает определить какой тип операции хочет выполнить пользователь.\nget - получение данных\npost - отправка\ndelete - удаление \nput - обновление данных\n2.Путь к ресурсу\n3.Версия HTTP протокола\n4.В дополнение могут идти различные заголовки, которые отправляют дополнительную информацию на сервер. Также в запросе может быть тело, которое содержит информацию, например, если используется запрос put , то в теле запроса могут быть указаны ключи и значения, которые должны быть обновлены.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/euieaazwm0uudcuupxwq1/http8.webp?rlkey=m2g7nox9xckwrqgr5kir7auns&st=qjn6tlpx&dl=1"]
  },
  "j250":{
    "id":"08f36e272",
    "theme":"webh",
    "question":"Какие методы может иметь HTTP-запрос?",
    "answer":"HTTP определяет множество видов запроса, которые указывают какое именно действие хочет произвести пользователь. Основных методов можно выделить 9, но на практике чаще используют первые 4.\n1. get запрос на получение данных. С использованием данного метода можно только извлекать данные;\n2. post используется для отправки данных на определенный ресурс, часто вызывает изменения состояния, т.е. добавление, либо какие-то побочные эффекты на сервере;\n3. delete запрос на удаление указанных данных;\n4. put заменяет все текущие представления ресурса данными запроса, используется для редактирования;\n5. head запрашивает ресурс аналогично get, но без тела ответа.\n6. connect устанавливает туннель к серверу или определенному ресурсу;\n7. trace выполняет вызов возвращаемого тестового сообщения с ресурса;\n8. patch используется для частичного изменения ресурса;\n9. options используется для описания параметров соединения с ресурсом.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/qoytvvme6ayvgk38s1w65/width_480_q70.webp?rlkey=t25cnr8fil36dbyepmp0men2o&st=509l4itn&dl=1"]
  },
  "j251":{
    "id":"08f36e273",
    "theme":"webh",
    "question":"Что такое HTTP cookie? Для чего они используются?",
    "answer":"HTTP - это протокол без сохранения состояния, а это значит что каждая пара “запрос-ответ” не связана с предыдущим запросом и ответом. На реальных проектах это не очень удобно, так как иногда нужно запомнить аутентификацию пользователя или, например, хранить данные пользователя с товаром. Для хранения такой информацию используются HTTP cookie.HTTP cookie - это небольшой фрагмент данных отправляемых сервером на браузер пользователя, который тот может сохранить и отсылать обратно с запросом к данному серверу.\nКуки могут использоваться для:\n1.управления сеансом (логины, корзины для виртуальных покупок);\n2.мониторинга (отслеживания поведения пользователя);\n3.персонализации (пользовательские предпочтения).\nПолучив HTTP-запрос вместе с ответом сервер может отправить заголовок Set-Cookie. Cookie обычно запоминаются браузером и посылается значение заголовка в HTTP Cookie с каждым новым запросом к одному и тому же серверу. Для них можно создать срок действия, после которого они будут перезапрошены или не будут отправляться, а также можно указать ограничения на путь и домен.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/20qkgoxb56k6j7xfw1fc7/cookie.webp?rlkey=zh4g6mw56wz36rtd7wk0xu43n&st=0uouc4r6&dl=1"]
  },
  "j252":{
    "id":"08f36e274",
    "theme":"webh",
    "question":"Разница между HTTP и HTTPS?",
    "answer":"HTTP - это наиболее широко используемый протокол в интернете. Он является стандартом для запросов и ответов клиентов и серверов. Он используется для передачи гипертекста с сервера в локальный браузер.\nHTTPS - это канал HTTP, цель которого безопасность, другими словами, это безопасное версия HTTP, то есть к HTTP добавляется уровень SSL. SSL требуется для деталей шифрования.\nОсновной функцией протокола HTTPS можно разделить на два типа:\n1.установить информационный канал для обеспечения безопасности данных;\n2.подтвердить подлинность веб-сайта.\nHTTP запрос не зашифрован, HTTPS в свою очередь зашифрован. \nHTTP порт - 80, а HTTPS - 443.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/druuf6x11n2vk2f4k4zl5/photo_2892.wide.webp?rlkey=ldlkiha8qimy2df5bhnp3w68h&st=pvdk9q1d&dl=1"]
  },  
  "j288":{
    "id":"08f36e376",
    "theme":"webh",
    "question":"Разница между HTTP/1 и HTTP/2?",
    "answer":"Отчасти данный вопрос можно назвать открытым, так как отвечать на него можно довольно долго, начиная от истории создания и заканчивая особенностями HTTP//3.  Но если подсуммировать, то можно выделить 6 основных различий:\n\n1.Performance\n\n2.Multiplexing\n\n3.Header Compression (using HPACK)\n\n4.Server Push (use PUSH_PROMISE)\n\n5.Prioritisation (sending PRIORITY frame)\n\n6.Security (transfer over TLS protocol)\n\nПроизводительность HTTP/2 обеспечивает более эффективное использование сети и повышенную производительность по сравнению с HTTP/1. Достигается это через множество улучшений, включая мультиплексирование, компрессию заголовков, серверные уведомления и приоритизацию запросов.\n\nМультиплексирование в HTTP/2 запросы и ответы могут быть разделены на фрагменты, называемые кадрами или фреймами, и отправляться параллельно по одному соединению. Это позволяет эффективно использовать сетевые ресурсы и избежать задержек, связанных с ожиданием завершения предыдущих запросов.\n\nКомпрессия заголовков в HTTP/2 использует бинарное кодирование заголовков с помощью алгоритма сжатия, что позволяет сократить объём передаваемых данных и уменьшить нагрузку на сеть.\n\nСерверное уведомление, так называемый сервер PUSH в HTTP/2 сервер может активно отправлять ресурсы клиенту, которые этот клиент может потенциально запросить даже до того как этот запрос выполнен явно. Это позволяет снизить задержку, связанную с дополнительными запросами.\n\nПриоритизация в HTTP/2 позволяет устанавливать приоритеты для различных запросов, что помогает оптимизировать поток данных и улучшает производительность при обработке параллельных запросов.\n\nБезопасность, в отличие от HTTP/1 протокола  HTTP/2 обязательно требует шифрования с помощью протокола TLS, что обеспечивает повышенную безопасность передачи данных.",
    "codeexample":"",
    "images":[]
  },
  "j289":{
    "id":"08f36e377",
    "theme":"webh",
    "question":"Как работает мультиплексирование в HTTP/2?",
    "answer":"Мультиплексирование в HTTP/2 позволяет отправлять несколько http запросов и ответов параллельно по одному соединению. Это достигается путём разбиения запросов и ответов на маленькие фрагменты, называемые кадрами, и передачи их независимо друг от друга. Работа мультиплексирования в HTTP/2 выполняется в 4 шага:\n\n1.Установление соединения. Клиент и сервер устанавливают соединение посредством протокола TLS или вне зашифрованном режиме. Это создаёт одно соединение.\n\n2.Разделение на кадры. Запросы и ответы разделяются на кадры, которые могут передаваться независимо друг от друга в любом порядке. Каждый кадр содержит определённую часть данных, такую как заголовки, тело запроса или ответа.\n\n3.Идентификация кадров. Каждый кадр имеет свой уникальный идентификатор, который позволяет получателю правильно собрать и восстановить запросы и ответы из кадров.\n\n4.Параллельная передача. Клиент и сервер могут параллельно  отправлять и принимать несколько кадров, что позволяет увеличить пропускную способность и эффективно использовать сетевые ресурсы. Это особенно полезно при загрузке больших ресурсов, а также при выполнении множества запросов одновременно.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/cl88yxajodur1jytneu9k/1_4vlxfOXFFYIjHzMNBirDag.webp?rlkey=nlqixgyyrh32yqq91nfgho8qp&st=dwcfm07u&dl=1"]
  },
  "j290":{
    "id":"08f36e378",
    "theme":"webh",
    "question":"Что такое “трехстороннее рукопожатие” (Triple handshake)?",
    "answer":"Трёхстороннее рукопожатие – это метод, используемый в сети TCP/IP для создания соединения между клиентом и сервером. Установленное соединение будет полнодуплексным, то есть оба канала могут передавать информацию одновременно. А также они синхронизируют SYN и подтверждают ACK друг друга. SYN – это sequence number или порядковый номер. ACK – это acknowledgment number или номер подтверждения.\n\nТрёхстороннее рукопожатие выполняется следующим образом в 3 шага:\n\n1.Клиент отправляет сегмент с установленным флагом  SYN. При этом сегменту присваивается произвольный порядковый номер в интервале от 1 до 232.\n\n2.Сервер получает этот запрос и отправляет ответный сегмент с одновременно установленными флагами SYN и ACK. При этом записывает в поле номер подтверждения и полученный порядковый номер, увеличенный на единицу, что по сути подтверждает получение первого сегмента. А также устанавливает свой порядковый номер, который как и в SYN сегменте выбирается произвольно.\n\nПосле получения клиентом сегмента с флагами SYN + ACK соединение считается установленным, поэтому клиент отправляет в ответ сегмент с флагами ACK или обновлёнными номерами последовательности. Следует отметить, что данный ответ не содержит полезные нагрузки и только после этого начинается передача данных.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/cskcuhn6nx61wdeq4g77q/10ZZ3JALyI.webp?rlkey=33irj4s5uf6ff0znlngud558j&st=ybzjsoat&dl=1"]
  },
  "j253":{
    "id":"08f36e275",
    "theme":"webh",
    "question":"Разница между PUT- и POST-запросами?",
    "answer":"PUT-запросы приводят либо к созданию ресурса, если он не существовал, либо к его обновлению, если он существует. Многократное повторение PUT-запроса с одними данными приводит к одному и тому же результату на сервере - это равносильно однократному выполнению такого запроса (идемпотентность).\n\nPOST-запросы приводят к специфической для ресурса обработке данных, передаваемых в запросе. Чаще всего они используются для создания новых ресурсов на сервере с новым уникальным id. При этом повторение POST-запроса приводит к разным результатам - например, к созданию нескольких ресурсов на сервере (не являются идемпотентными).",
    "codeexample":"",
    "images":[]
  },
  "j254":{
    "id":"08f36e276",
    "theme":"webh",
    "question":"Разница между протоколами TCP и UDP?",
    "answer":"При разработке веб-приложения важно учитывать множество факторов. Один из таких факторов - это то как приложение будет взаимодействовать браузером пользователя. Передача данных между сервером и браузером опирается на протоколы транспортного уровня, то есть TCP и UDP. Знание о том, как они работают позволяют оптимизировать передачу данных и улучшить пользовательский опыт, на практике TCP используется в случаях, когда необходимо гарантировать целостность и порядок приходящих данных в ущерб скорости их передачи, это важно для обмена файлами. Например запрос на получение файлов разметки HTML или CSS. UTP используется если скорость важнее соблюдения подобных требований, например доставка потокового аудио или видео. Гарантии доставки и порядка получения данных в этом случае нет. Таким образом можно сделать вывод, что тип используемого протокола в первую очередь будет зависеть от данных, которые нужно отправить.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/7onphfn14z3n2lqob9dqe/TCP_UDP.webp?rlkey=t2qpwkj0ya0xfj7tjoagqt1di&st=2ea02qxv&dl=1"]
  },
  "j255":{
    "id":"08f36e277",
    "theme":"webh",
    "question":"Что такое WebSocket? В чем принцип его работы?",
    "answer":"WebSocket - это протокол, который обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по этому соединению в обоих направлениях в виде пакетов без разрыва соединения и дополнительных HTTP-запросов. Чтобы открыть WebSocket-соединение нужно создать объект new WebSocket(), указав в url-адресе специальный протокол ws. Как только объект WebSocket создан на его событие можно подписаться и прослушивать их.\nСуществует основных четыре события:\n\t1.open - соединение установлено;\n\t2.message - получение данных;\n\t3.error - ошибка;\n\t4.close - соединение закрыто.",
    "codeexample":"const socket = new WebSocket(\"ws://just-test.com\");\n\nsocket.onopen = function() {\n\talert(\"[open] Connected!\");\n\tsocket.send(\"Hello world!\");\n};\n\nsocket.onmessage = function(e) {\n\talert('[message] Data is received from server: ${e.data}');\n};\n\nsocket.onclose = function(e) {\n\tevent.wasClean\n\t\t? alert('[close] Connection closed cleanly, code=${e.code}\nreason=${e.reason}');\n\t\t:alert('[close] Connection interrupted');\n};socket.onerror= function(e) {\n\talert('[error] ${e.message}`);\n};",
    "images":[]
  },
  "j256":{
    "id":"08f36e278",
    "theme":"webh",
    "question":"Разница между Long-Polling, Websockets и Server-Sent Events?",
    "answer":"Все три подхода начинаются одинаково. Клиент запрашивает веб-страницу с сервера, используя обычный HTTP. Далее происходит выполнение JavaScript. Клиент получает запрошенную веб-страницу и выполняет JavaScript на странице, которую запрашивает. Websockets, сервер и клиент после установки связи могут отправлять друг другу сообщения когда доступны новые данные, причем с обеих сторон.\nВ Long-Polling и  Server-Sent Events сервер не сразу отвечает запрошенной информации, а ждет пока не появится новая. Когда появляется новая информация сервер отвечает этой новой информации. Клиент получает ее и немедленно отправляет другой запрос на сервер, перезапуская процесс.\nС помощью Websockets можно подключаться к серверу из другого домена,  также можно использовать сторонний сервер веб-сокетов. Таким образом достаточно реализовать только клиентскую часть.\nВ Server-Sent Events траффик идет в реальном времени от сервера к клиенту, а соединение с сервером из других доменов  возможны только при правильных настройках cors.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/6lco3ibl7porou46upiwz/1_tb9gG_zb9O1Zol8TC5eTkQ.webp?rlkey=3ajxz46csdytpduslhypcjpmd&st=jr2aeev3&dl=1"]
  },
  "j257":{
    "id":"08f36e279",
    "theme":"webh",
    "question":"Как работает JSONP?",
    "answer":"JSONP - это способ часто используемый для обхода политики ограничения доменов браузеров потому что ajax запросы с текущей страницы к серверу находящемуся в другом домене запрещены. Это так называемая политика same origin policy. JSONP работает, отправляя запросы к серверу в другом домене через тег <script> и обычно с параметром запросов в виде колбек функции.  Затем сервер оборачивает данные внутри функции с именем printData и возвращает их клиенту у клиента должна быть своя функция printData в глобальной области видимости, и эта функция будет выполнена клиентом, когда будет получен ответ сервера из другого домена. Основной недостаток JSONP  - это то что он может быть небезопасным поэтому нужно быть уверенным поставщике данных JSONP.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/l3viuatnub5n8uvb3v5sq/2581899102-593d807054ddc_fix732.webp?rlkey=3fpbw7m4qd5ehno2htmf4nl8t&st=p2akz7g7&dl=1","https://www.dropbox.com/scl/fi/04mjxrt6fl47jhbq20ute/1_AAtbKMYYz5wgxed7Tu6tzw.webp?rlkey=tkkb7t6k16xg5food4flgmoq2&st=tb2uaxyv&dl=1"]
  },
  "j258":{
    "id":"08f36e280",
    "theme":"webh",
    "question":"Что такое IndexedDB в браузере? Преимущества IndexedDB?",
    "answer":"IndexedDB - это низкоуровневый API для хранения на клиенте значительного количества структурированных данных, а также немного более сложное и проработанное решение для хранения данных в браузере, чем, например, Local Storage или Session Storage. По своей сути это объектно ориентированная база данных основанная на JavaScript, которая позволяет легко сохранять и извлекать данные проиндексированные по ключу. Использование IndexedDB является более сложным в сравнении с остальными методами хранения данных в браузере. Перед тем как создавать, читать, обновлять, удалять какие-либо данные, нужно сначала открыть базу данных и создать хранилище аналогичное таблица в базе данных. Если говорить в общем, то это мини база данных в браузере. К преимуществам IndexedDB можно отнести следующее: могут обрабатывать более сложные структуры данных, могут работать с разными базами данных и таблицами внутри каждой базы данных, больше объём хранения больше контроля по взаимодействию с хранилищем.",
    "codeexample":"\nfunction OpenIDB() {\n\treturn idb.open('TestDB', 1, function(upgradeDb) {\n\t\tconst users = upgradeDb.createObjectStore('users', {\n\t\t\tkeyPath: 'name',\n\t\t});\n\t});\n}",
    "images":[]
  },
  "j259":{
    "id":"08f36e281",
    "theme":"webh",
    "question":"Что такое Service Workers?",
    "answer":"Service Workers по сути действует как прокси-серверы, которые находятся между веб-приложениями и сетью, если они доступны. Если говорить простыми словами - это сценарий, который запускается браузером в фоновом режиме, он никак не связан с веб-страницей или DOM и представляет функции из коробки, такие как обработка сетевых запросов, push-уведомлений и фоновая синхронизация. Service workers предназначены для обеспечения эффективного взаимодействия в автономном режиме, перехвата сетевых запросов и принятия соответствующих мер в зависимости от доступности сетей и наличия обновлённых данных на сервере. Если говорить просто, то service workers обеспечивает возможность работы оффлайн, также они являются посредником между клиентом и сервером и пропускают через себя все запросы к серверу. С их помощью можно перехватывать все запросы на лету service workers запускаются в контексте worker, поэтому не имеют доступа к DOM и работают в потоке отличном от основного потока javascript, на котором работает приложение. Поэтому они являются не блокирующими и полностью асинхронными. Работают service workers только по https из соображений безопасности.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/wtw92p9jtj3ma23i436m5/945346917bc859f89f4ccc97695a92f5.webp?rlkey=9jjj2una1ttcpwxrwnefl1mfd&st=3bnzorzm&dl=1"]
  },
  "j260":{
    "id":"08f36e281",
    "theme":"webh",
    "question":"Что такое Web Workers?",
    "answer":"Web Workers предоставляет простое средство для запуска скриптов в фоновом режиме или рабочим потоке. Рабочий поток может выполнять задачи не мешая пользовательскому интерфейсу. После создания worker может отправлять сообщения в JavaScript код, который его создал, отправляя сообщение через обработчик событий указанный этим кодом и наоборот. Worker - это объект созданный с помощью конструктора, который запускает именованный JavaScript файл, этот файл содержит код, который будет выполняться в рабочем потоке. Объекты workers не запускаются в другом глобальном контексте отличающемся от текущего. Данные между воркерами и главным потоком передаются через систему сообщений, обе стороны передают свои сообщения используя метод postMessage и отвечают на сообщения при помощи  обработчика событий onmessage, при этом сообщение хранится в атрибуте data события message, а данные копируются, а не делятся. В свою очередь объекты workers могут создавать новые объекты workers, и так до тех пор пока всё работает в рамках текущей страницы.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/8ne9nq9aza2zlqd68vnir/68747470733a2f2f636e746368656e2e6769746875622e696f2f696d672f776f726b65722d7265766965772f6e65772d776f726b65722d666c6f77636861742e6a7067.webp?rlkey=0rh1xzl453vrnt0fn8dqxmq7o&st=wfvkzcox&dl=1"]
  },
  "j261":{
    "id":"08f36e282",
    "theme":"webh",
    "question":"Что такое Web Worklet?",
    "answer":"Данный вопрос может звучать также в формулировке: Что такое web-воркеры, service-воркеры и web-ворклиты. Так как 3 этих понятия тесно связаны с основной идеей. Web-workers – это скрипты общего назначения, позволяющие разгрузить работу основного потока. Сервис-воркеры – это прокси между браузером и сетью. Перехватывая запросы, сделанные документом сервис-воркер, могут перенаправлять их позволяя работать автономно. Важно запомнить, что все три – это скрипты, запускаемые в отдельном потоке от основного потока браузера.\nWorklets – это очень лёгкие и специфичные воркеры. Они позволяют подключаться к различным частям процесса рендеринга браузера. Во время отрисовки страницы браузер проходит через ряд шагов, так называемый Critical Rendering Path. Однако есть 4 шага, которые вызывают беспокойство: вычисление стилей, расчёт макета, прорисовка и компоновка. С помощью Worklet можно вынести ресурсозатратные операции рендеринга в отдельный поток. Тем самым уменьшить нагрузку на машину пользователя, а также увеличить скорость отрисовки страницы.",
    "codeexample":"/ myWorklet.js */\nregisterPaint ('myGradient', class {\n\tpaint(ctx, size, properties) {\n\tlet gradient = ctx.createLinearGradient(0, 0, 0, size.height/ 3);\n\t\tgradient.addColorStop(0, \"black\");\n\t\tgradient.addColorStop (0.7, \"rgb(210, 210, 210)\");\n\t\tgradient.addColorStop (0.8, \"rgb(230, 230, 230)\");\n\t\tgradient.addColorStop (1, \"white\");\n\t\tctx.fillStyle = gradient;\n\t\tctx.fillRect(0, 0, size.width, size.height / 3);\n\t}\n});\n\n/main.js */\nCSS.paintworklet.addModule('myWorklet.js');",
    "images":[]
  },
  "j291":{
    "id":"08f36e378",
    "theme":"webh",
    "question":"Механизм установки сеанса между клиентом и сервером?",
    "answer":"Сеанс или сессия в контексте веб-разработки представляет собой период взаимодействия между клиентом и сервером. В течение сеанса клиент и сервер обмениваются данными и информацией. Установка сессии включает в себя следующие шаги: клиент отправляет запрос на сервер (это может быть обычный http-запрос на определенный url-адрес); сервер получает запрос от клиента и обрабатывает его. Он генерирует уникальный идентификатор сеанса, который будет использоваться для идентификации данного сеанса; сервер отправляет ответ клиенту, включая сгенерированный идентификатор сеанса; клиент получает ответ от сервера и сохраняет идентификатор сеанса. Данный идентификатор будет использоваться для дальнейших запросов для идентификации и сохранения состояния; далее сеанс может быть завершен при отправлении клиентом соответствующего запроса, либо сеанс завершается по истечению определенного времени.",
    "codeexample":"",
    "images":[]
  },
  "j293":{
    "id":"08f36e379",
    "theme":"webh",
    "question":"Что такое IP-адрес?",
    "answer":"IP-адрес - это уникальный сетевой адрес узла в компьютерной сети построенной на стыке протоколов TCP/IP. При определении IP адреса есть два основных момента: в сети Интернет требуется глобальная уникальность адреса, а в случае работы в локальной сети требуется уникальность адресов в пределах этой сети. В версии протокола Ipv4 адрес имеет длину 4 байта, а версии протокола ipv6 ip-адрес имеет длину 16 байт. Обычно ip-адрес версии протокола ipv4 записывают в виде четырёх десятичных чисел со значениями от нуля до 255 разделённых точкой, например 192.168 51 где каждое значение - это 8 бит что в сумме даёт 32 бита или 4 байта.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/uhp1qjs34j9veh41udo2o/1-struktura-ip-adresa-ipv4-1024x542.webp?rlkey=n3i6609rlkhkgvdyyh7c8ydwd&st=hthq1d41&dl=1"]
  },
  "j294":{
    "id":"08f36e380",
    "theme":"webh",
    "question":"Разница между host и domain?",
    "answer":"IP-адрес - это уникальный идентификатор компьютера в сети. Сервер - это тоже компьютер, однако его особенность заключается в том, что он предназначен для хранения данных. Если мы говорим о сайтах, то сервер, который содержит сайт называется хостом, у этого хоста есть уникальный IP-адрес в среде сервисов TCP/IP. Соответственно, если мы хотим послать запрос на сервер, нам нужно знать его IP. Проблема заключается в том, что адреса в таком формате трудно запоминать и помнить такое количество комбинаций для всех сайтов это неудобно. Вместо этого используется доменные имена. Домен - это адрес сайта или определённая зона, которая имеет своё имя непохожее ни на какое другое имя в системе доменных имён. Поэтому, когда в браузере вводится определённое доменное имя и отправляется запрос, то под капотом запрос идёт на хост с ip-адресом который ассоциирован с этим доменным именем.",
    "codeexample":"",
    "images":[]
  },
  "j264":{
    "id":"08f36e285",
    "theme":"webh",
    "question":"Разница между URI и URL?",
    "answer":"URI расшифровывается, как Uniform Resource Identifier и переводится, как унифицированный идентификатор ресурсов. URI - это последовательность символов, идентифицирующая абстрактный или физический ресурс. URL расшифровывается, как Uniform Resource Location то есть это некий унифицированный указательный ресурс однозначно определяющий его месторасположение. URL служит стандартизированным способом записи адреса ресурса в сети Интернет. Их отличие в том, что URI - это некоторые идентификаторы ресурсов, которые позволяют этот ресурс как-то идентифицировать, в то время как URL это указатель на ресурс, он даёт информацию о том, где именно ресурс находится. Таким образом URL - это URI который помимо идентификации ресурса даёт информацию о его местонахождении.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/jmq97j2w3ik24cx60p7o1/6c224f4a20a44623512e430f8822720e0df3d7f3.webp?rlkey=rjj7t61eokm6h8ox8yngyjplb&st=1b2l5qn5&dl=1"]
  },
  "j265":{
    "id":"08f36e286",
    "theme":"webh",
    "question":"Что такое MVC?",
    "answer":"\tMVC - это паттерн или шаблон проектирования. Данный паттерн помогает разбить монолитное приложение на независимые, сформированные структуры, каждая из которых отвечает за свою конкретную логику.  Это позволяет держать код модульно, увеличить его переиспользуемость, тестируемость, читаемость и  поддерживаемость.\n\tMVC - это аббревиатура которая описывает основные части паттерна, то есть Model или модель, View или представление и Controller.\n\tModel отвечает за расчеты, выборку и изменению информации в базе данных, описывает структуру данных и т.д. Модель можно представить как библиотеку различных функций, позволяющих реализовывать функционал приложения.\n\tView это часть, которая отвечает за вывод информации на экран, по сути это интерфейс, который предназначен для рендеринга, получаемых данных, и работы с ними.Controller - это блок, который получает данные от пользователя, обрабатывает, нормализует  их, а также выполняет проверку правильности ввода и передает эти обработанные данные в нужную модель.Он принимает данные от модели, затем выбирает нужно представление, наполняет его данными и отображает на экране браузера.  Controller  не должен содержать в себе  информацию о внешнем виде приложения. Controller  можно рассмотреть как посредника между представлением и моделью.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/jeh8d4i9r26h31i37od3e/MVC.webp?rlkey=lp6vblpxq1iqvl204p5xi9fkz&st=ekeu9onq&dl=1"]
  },
  "j266":{
    "id":"08f36e287",
    "theme":"webh",
    "question":"Недостатки паттерна MVW?",
    "answer":"",
    "codeexample":"MVW (Model View Whatever) или модель представление что-угодно. MVW  легко управлять в простом приложении, содержащем несколько моделей и контроллеров.\nПри росте приложения можно столкнуться со следующими проблемами:\n\t1.Модели и контроллеры взаимодействуют - эти модули меняют состояние друг друга и чем больше модулей, тем легче утратить контроль над тем, как  изменено состояние того или иного модуля.\n\t2.Асинхронные сетевые запросы добавляют элемент неожиданности в то, когда модель будет изменена или модифицирована. Достаточно представить кейс, что пользователь изменил UI до того как пришел ответ на асинхронный запрос.\n\t3.Изменение состояния, моделей добавляет еще один уровень сложности в мутацию. Требуется определить каким образом изменяется состояние или модель и какие инструменты необходимы для распознавания мутации.\n\t4.Код совместно используемого приложения, например, такого как в GoogleDocs, где множество данных меняются в режиме реального времени, будет огромным.\n\t5.Нет возможности отменять действия, возвращаться назад во времени без добавления большого количества дополнительного кода.",
    "images":[]
  },
  "j267":{
    "id":"08f36e288",
    "theme":"es",
    "question":"Что такое ECMAScript? В чём отличие от JavaScript?",
    "answer":"ECMAScript — это стандарт (спецификация), в котором описываются правила и рекомендации для скриптовых языков общего назначения. Он был создан, чтобы разные браузеры и платформы могли работать с одним и тем же языком.\n\nJavaScript — это реализация этого стандарта. Каждая версия JavaScript соответствует определённой версии ECMAScript. Например, версия ES6 (или ECMAScript 2015) привнесла много новых возможностей в JavaScript, таких как: let и const (вместо var), стрелочные функции, классы, promises, и многое другое.",
    "codeexample":"",
    "images":[]
  },
  "j268":{
    "id":"08f36e289",
    "theme":"es",
    "question":"Разница между let, const и var?",
    "answer":"В JavaScript есть три ключевых слова для объявления переменных: var, let и const. Они различаются по области видимости, возможностям переприсваивания и поведению при объявлении переменных.\n\n\tVAR\nОбласть видимости: Переменные, объявленные с помощью var, имеют функциональную область видимости. Это означает, что они доступны в пределах функции, в которой были объявлены. Если они объявлены вне функции, то становятся глобальными переменными.\nПоднятие (hoisting): Переменные var поднимаются в начало функции или глобальной области видимости. Но при поднятии переменной её значение остаётся неопределённым до тех пор, пока код не дойдёт до строки объявления.\nПереприсваивание: Переменные var можно переприсваивать.\n\n\tLET\nОбласть видимости: Переменные, объявленные с помощью let, имеют блочную область видимости. Это означает, что они доступны только внутри блока, в котором были объявлены.\nПоднятие (hoisting): Переменные let также поднимаются, но не инициализируются. Это означает, что к ним нельзя обращаться до строки объявления. Если попытаться использовать переменную до её объявления, произойдёт ошибка.\nПереприсваивание: Переменные let можно переприсваивать.\n\n\tCONST\nОбласть видимости: Переменные const имеют такую же блочную область видимости, как и let.\nПоднятие (hoisting): Как и let, переменные const поднимаются, но остаются неинициализированными до строки объявления.\nПереприсваивание: Переменные const нельзя переприсваивать. Они должны быть инициализированы при объявлении и остаются неизменными. Однако, если const используется для объектов или массивов, то их содержимое можно изменять (модифицировать), но саму переменную нельзя переприсвоить.",
    "codeexample":"\nconsole.log(a); // undefined\nvar a = 10;\nconsole.log(a); // 10\n\n{\nlet b = 20;\nconsole.log(b); // 20\n}\nconsole.log(b); // Ошибка, b не определена\n\nconst c = 30;\nс = 40; // Ошибка, переприсваивание невозможно\nconst obj - { name: 'John' };\nobj.name = \"Doe\"; // Работает, объект можно изменять\nconsole.log(obj.name); // Doe",
    "images":[]
  },
  "j269":{
    "id":"08f36e290",
    "theme":"es",
    "question":"Можно ли изменить значение определённое через const?",
    "answer":"Переменные, объявленные с помощью const, переприсваивать нельзя. Однако если переменная содержит объект или массив, то можно изменять содержимое этого объекта или массива.\nВ саму константу записывается не значение а ссылка на объект, а сам объект хранится в области оперативной памяти, где мы можем изменять что угодно, сохраняя ссылку, которую использует константа.",
    "codeexample":"",
    "images":[]
  },
  "j270":{
    "id":"08f36e291",
    "theme":"es",
    "question":"Что такое временная мёртвая зона (temporal dead zone)?",
    "answer":"\tВременная мёртвая зона (Temporal Dead Zone, TDZ) — это концепция в JavaScript, которая касается переменных, объявленных с помощью let и const. Она описывает период времени от начала выполнения блока кода до момента, когда переменная объявлена. В этот период времени любая попытка обратиться к переменной вызовет ошибку.\n\nКак это работает:\nПеременные let и const поднимаются (hoisting), как и переменные var. Это значит, что их объявления перемещаются в начало их области видимости (блока или функции).Однако в отличие от var, переменные let и const остаются неинициализированными до тех пор, пока выполнение кода не дойдет до строки их явного объявления.Любая попытка доступа к переменной до её объявления в коде вызывает ошибку. Этот период и называется временной мёртвой зоной.\nПопытка доступа к переменной до фактического объявления вызывает ReferenceError, в отличие от переменных var, которые в таком случае просто имеют значение undefined.\nВременная мёртвая зона помогает предотвратить использование переменных до их инициализации, что может привести к ошибкам или неожиданным результатам. И подчёркивает важность точного порядка кода, особенно при использовании let и const.",
    "codeexample":"{\nconsole.log(b); // ReferenceError\nlet b = 10;\nconsole.log(b); // 10\n}",
    "images":[]
  },
  "j271":{
    "id":"08f36e292",
    "theme":"es",
    "question":"Для чего используется цикл for…of?",
    "answer":"Данный оператор появился в версии ES6 он помогает выполнить цикл обхода итерируемых сущностей, вызывая на каждом шаге итерации операторы для каждого значения.\nВ ES5 был похожий цикл for...in основное отличие между ними, в том, что for...in оперирует c индексами перебираемых сущностей, в то время как for…of работает со значениями, так же for…of умеет работать с коллекциями по типу set и map.",
    "codeexample":"const names = ['Nika', 'Elina', 'Dasha'];\n\n// for...in\nfor(let index in names) {\n\tconsole.log(index);          // 0, 1, 2\n\tconsole.log(names [index]);  // 'Nika', 'Elina', 'Dasha'\n}\n\n// for...of\nfor(let name of names) {\n\tconsole.log(name);           // 'Nika', 'Elina', 'Dasha'\n}",
    "images":[]
  },
  "j272":{
    "id":"08f36e293",
    "theme":"es",
    "question":"Что такое шаблонные литералы (Template Literals)?",
    "answer":"Шаблонные литералы или шаблонные строки это новый способ создания строк в JS. Они создаются с помощью обратных кавычек (` `) и допускают использование строковой интерполяции или многострочных литералов, в них не нужно экранировать одинарные кавычки, использовать конкатенацию для сложения строк или спецсимволы для перевода строки.",
    "codeexample":"\nconst name = \"Nadia\";\n// ES5་\nvar greet = 'Hi I'm ' + name + '!'; // \"Hi I'm Nadia!\"\nvar job = '\n'\n\t+' I \n'\n\t+'am \n'\n\t+ 'Front-end developer \n';\n\n// ES6\nconst greet = Hi I'm ${name}!';     // \"Hi I'm Nadia!\"\nconst job = '\n\tI\n\tam\n\tFront-end developer\n';",
    "images":[]
  },
  "j273":{
    "id":"08f36e294",
    "theme":"es",
    "question":"Что такое Set, Map, WeakMap и WeakSet?",
    "answer":"В ES6 появились новые типы коллекций Set, Map, WeakMap и WeakSet.\nMap - это коллекция для хранения записей вида “ключ-значение”, в отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например, число или булевое значение.\nSet - это коллекция для хранения множества значений, причем каждое значение может встречаться лишь один раз, даже при попытке динамически добавить дубликат это не сработает все элементы внутри будут уникальны.\nWeakMap и WeakSet от оригинальных Map и Set они отличаются только тем, что не препятствуют сборщику мусора удалять свои элементы, т.е. если некий объект присутствует только в WeakSet или WeakMap он спокойно удаляется из памяти. \nЭто нужно для тех случаев когда место хранения объекта находится в другом месте, а в текущем используя коллекцию WeakMap или WeakSet мы храним только вспомогательные данные, которые должны существовать только пока существует объект, таким образом эти методы избавляют от необходимости удалять вспомогательные данные вручную.",
    "codeexample":"// Map\nlet map = new Map();\n// Adding elements in Map\nmap\n\t.set('str', 'string')   // key is string\n\t.set(1, 'number')       // key is number\n\t.set(true, 'boolean');  // key is boolean\n// Set\nlet users = new Set();\n// Data\nconst jack = { name: \"Lena\" };\nconst max = { name: \"Ira\" };\nconst leo = { name: \"Sveta\" };\nusers\n\t\t.add(lena)\n\t\t.add(ira)\n\t\t.add(sveta)\n\t\t.add(olga)            // Duplicate\n\t\t.add(masha);          // Duplicate\nconsole.log(users.size);  // 3 (no dubplicated values)",
    "images":[]
  },
  "j274":{
    "id":"08f36e295",
    "theme":"es",
    "question":"Разница между обычными функциями и стрелочными?",
    "answer":"1.Ключевое слово this. В обычных функциях это значение динамическое и завист от контекста исполнения. В стрелочных функцияч значение this всегда эквивалентна значению this внешней функции. Другими словами функция не создает свой контекст исполнения, а использует внешний, даже если вызвать стрелочную функцию с помощью call или apply это не сработает, и контекст функции не помеяются.\n2.Стрелочную функцию нельзя использовать как функцию конструктор. Такая попытка вызовет ошибку.\n3.При использовании обычной функции есть доступ к псевдомассиву arguments, у стрелочной функции такого псевдомассива нет.\n4.Для возрата значений из обыной функции используется ключевое слово return, в стрелочных функциях при сокращенной формой записи это значение можно не использовать.\n5.Стрелочную функцию, так же как и обычную, можно использовать внутри класса. тогда такая фукция называется методом и если такой метод попытаться использовать как callback, например, внутри таймера, то обычная функция  потеряет контекст, в то время как в стрелочной он всегда будет равен объекту класса. ",
    "codeexample":"// this\nconst myObject = {\n\tmyMethod(items) {\n\t\tconsole.log(this);      // myObject\n\t\tconst callback = () => {\n\t\t\tconsole.log(this);      //myObject\n\t\t};\n\t}\n};\n\n// constructor\nconst User = (name) => {\n\tthis.name = name;\n}\nconst admin = new User('Yauhen'); // => TypeError: User is not a constructor\n\n// arguments\nconst myFunc = () => {\n\tconsole.log(arguments);\n}\nmyFunc('a', 'b'); // => ReferenceError: arguments is not defined\n\n// return\nconst double = (num) => num * 2;\nconsole.log(double (2)); // 4\n\n// context\nclass Hero {\n\tconstructor (heroName) {\n\t\tthis.heroName = heroName;\n\t}\n\n\tlogName= () => {\n\t\tconsole.log(this.heroName);\n\t}\n}\nconst batman = new Hero ('Batman');\nsetTimeout (batman. logName, 1000);  // Batman",
    "images":[]
  },
  "j2675":{
    "id":"08f36e296",
    "theme":"es",
    "question":"Разница между методом Object.freeze() и const?",
    "answer":"Ключевое слово const и метод Object.freeze() это совершенно разные вещи.\nСonst  создает иммутабельную привязку, то есть к переменной объявленной с помощью const нельзя присвоить новое значение. При попытке это выполнить будет выброшено исключение TypeError.\nObject.freeze() работает с объектными значениями, которая принимает в качестве аргумента. Он делает объект иммутабельным, что защищает от изменения значений свойств этого объекта. При попытке это сделать в строгом режиме будет выброшено исключение RefferenceError, в обычном режиме операция просто не сработает.",
    "codeexample":"// const\nconst person = {\n\tname: \"Diana\",\n};\nperson = 'test';          // Uncaught TypeError: Assignment to constant variable\n\n// Object.freeze()\nconst person = {\n\tname: \"Diana\",\n});\n\n// freezing\nObject.freeze (person);\n\nperson.name = \"Elli\"; // Uncaught TypeError: Cannot assign to read only property\nconsole.log(person);        // { name: \"Diana\" }\n// Uncaught TypeError: Cannot assign to read only property",
    "images":[]
  },
  "j276":{
    "id":"08f36e297",
    "theme":"es",
    "question":"Что такое генераторы? Когда стоит использовать генераторы?",
    "answer":"Генераторы - это новый вид функции в JS. Их особенностью являются то, что  выполняясь они могут приостановить свое исполнение и возвращать промежуточное значение, а затем обратно продолжить выполняться.\nДля того, чтобы обычную функцию превратить в генератор нужно добавить *. Это можно сделать после слова function, между словом function и именем  функции, либо перед именем функции, Внутри функции используется ключевое слово yield. Такая функция при ее первом вызове не выполняет код, а возвращает особый объект-генератор, который позволяет управлять ее выполнением. Для получения очередного значения, выдаваемого генератором, нужно вызвать его метод .next().\nГлавное в генераторах это, то что получить следующее значение, возвращаемый генератором можно только тогда когда нужно в коде, использующем генератор. Генератор отвечает только за возврат, управление им осуществляется извне.\nТакже существуют асинхронные генераторы, которые позволяют работать с асинхронными потоками данных.",
    "codeexample":"function* makeRangeIterator(start = 0, end = 4, step = 1) {\n\tlet iterationCount = 0;\n\tfor (let i start; i < end; i += step) {\n\t\titerationCount++;\n\t\tyield i;\n\t}\n\treturn iterationCount;\n}\n\nconst iterator = makeRangeIterator();\n\niterator.next();  // { value: 0, done: false }\niterator.next();  // { value: 1, done: false }\niterator.next();  // { value: 2, done: false }\niterator.next();  // { value: 3, done: false }\niterator.next();  // { value: 4, done: true }",
    "images":[]
  },
  "j277":{
    "id":"08f36e298",
    "theme":"es",
    "question":"Что такое ES6 модули?",
    "answer":"Концепция модулей, как способа организации JS кода существовала давно. Когда приложение сложное и кода много лучшим решением будет разбиение его на небольшие файлы, выполняющие какую-то функциональность или группирующие какие-либо данные по определенному признаку. В каждом файле описывается какая-то небольшая структурная часть, а в дальнейшем это всё собирается воедино. Модули позволяют разделить базу кода на несколько файлов для большего удобства обслуживания. До появления ES6 модулей были две популярные модульные системы, которые использовались для поддержки кодов в JavaScript - это command.js в Node.js и AMD - определение асинхронного модуля в браузере. Синтаксис использования модулей простой - ключевое слово import используется для получения функциональностей из другого файла, в то время, как export используется для передачи функциональности из файла. Модули нужны для: повышения читаемости и облегчения поддержки кода, возможности повторного использования кода и сохранение чистоты глобального пространства имён.",
    "codeexample":"// Export primitive\nexport const one = 1;\n// Export function\nexport const isNull = (val) => val === null;\n// Default export\nclass Helpers {\n\tstatic isUndefined (val) {\n\t\treturn val === undefined;\n\t}\n}\nnull;\nexport default Helpers;\n// Multiple export\nlet two = 2; let three = 3;\nexport { two, three };\n\n// Import primitive\nimport { one } from './file.js';\n// Import primitive with renaming\nimport { one as num1 } from './file.js';\n// Import function\nimport { isNull } from './file.js';\n// Default import\nimport Helpers from './file.js'",
    "images":[]
  },
  "j278":{
    "id":"08f36e299",
    "theme":"es",
    "question":"Что такое символ (Symbol) в ES6?",
    "answer":"Symbol - это отдельный тип данных, который появился в стандарте EcmaScript 2015. В общем, symbol - это уникальное и неизменное значение, которое позволяет добавлять уникальные свойства объектов или идентификаторы, при этом не резервируя какие-нибудь строковые названия для этих свойств или идентификаторов. Создаются они с помощью специальной функции symbol() без использования ключевого слова new. У функции symbol() есть необязательный аргумент, с помощью него можно указать имя для символа. В последующем это имя можно использовать для описания символа. Для различных символов можно использовать одно и то же имя, однако символы с одинаковыми именами не будут равны, т.е. создать два одинаковых символа невозможно. В обычной разработке символы практически не используются, однако их можно использовать при написании какой-то библиотеки, для создания уникального пространства имен, которое 100% будет гарантировать уникальность и не приведет к конфликту имен при интеграции этой библиотеки в приложение.",
    "codeexample":"// Symbol creation\nconst symbol = Symbol();\nconsole.log(typeof symbol); // \"symbol\"\n\n// Creation symbol with name\nconst symbol1 = Symbol('mySymbol');\nconst symbol2 = Symbol('mySymbol');\nconsole.log(symboll === symbol2); // false",
    "images":[]
  },
  "j279":{
    "id":"08f36e300",
    "theme":"es",
    "question":"Для чего используется метод .includes()?",
    "answer":"Этот метод определён у массивов и строк. Для массивов он проверяет, есть ли искомый элемент в массиве, для строк проверяется есть ли исходная подстрока в строке, возвращает true если исходный элемент нашёлся и false если нет. Метод принимает два аргумента: первый - это значение, которое нужно проверить, второй является необязательным и определяет позицию в массиве с которой требуется начинать поиск элемента. По умолчанию это значение равно 0.",
    "codeexample":"const dead = [\"Joffrey\", \"Ned Stark\", \"Night king\"];\n\nconst isJonDead = dead. includes (\"Jon Snow\");\nconsole.log(isJonDead);       // false\n\nconst isJoffrey Dead = dead. includes (\"Joffrey\");\nconsole.log(isJoffrey Dead); // true\n\nconst text = \"Test Lorem ipsum\"\nconsole.log(text.includes (\"Lorem\"));  // true\nconsole.log(text.includes(\"string\"));  // false\nconsole.log(text.includes (\"lorem\"));  // false (register)",
    "images":[]
  },
  "j296":{
    "id":"08f36e383",
    "theme":"es",
    "question":"Расскажите о методах .keys(), .values(), .entries()?",
    "answer":"Для итерации по элементам объекта есть 3 основных метода:\n\t.keys() – возвращает собственные ключи, входящие в состав объекта\n\t.values() – возвращает все собственные значения объекта\n\t.entries() – возвращает массив собственных перечисляемых свойств объекта в формате ключ-значения. Здесь важно понимать, что если объект наследует какие-то свойства по цепочке прототипов, то эти свойства отражаться не будут. Также следует отметить, что структура данных, передаваемая в .entries() не содержит ключей, то на их место встанет индекс элемента массива. И ещё одной отличительной особенностью .entries() является то, что свойство, ключом которого является символ, будет проигнорирован.",
    "codeexample":"const user = {\n\tfirstName: \"Mary\",\n\tlastName: \"Ivanova\",\n);\nObject.keys(user); // ['firstName', 'lastName']\nObject.values (user); //['Mary', 'Ivanova']\nObject.entries(user); // [['firstName', 'Mary'], ['lastName', 'Ivanova']]\n\nconst name ['M', 'a', 'x'];\nObject.entries (name); //[[ '0', 'M' ], '1', 'a' ], [ '2', 'x' 1);\n\nconst admin = {\n\t[Symbol('password')]: '123pass',\n\tname: 'Mary',\n};\nObject.entries (admin); // [ ['name', 'Mary' ] };",
    "images":[]
  },
  "j297":{
    "id":"08f36e384",
    "theme":"es",
    "question":"Для чего используется метод .fromEntries()?",
    "answer":"Для работы с элементами объекта существует метод .entries(), который возвращает массив собственных перечисляемых свойств объекта в формат ключ-значения.\nА что делать, если требуется выполнить обратное и преобразовать список пар ключ-значения в объект? В некоторых языках программирования, например, Python, для этой цели есть функция dict. А underscore и lodash в своём распоряжении имеют метод frompares.  ECMAScript 2019 внёс аналогичную функциональность в JavaScript путём введения метода .fromEntries(). Данный статический метод позволяет преобразовать список пар ключ-значения в объект.",
    "codeexample":"1 const user = {\n\tfirstName: \"Mary\",\n\tlastName: \"Ivanova\",\n};\nObject.entries (user); // [['firstName', 'Mary'], ['lastName', 'Ivanova'}]\n\nconst arr1 = [['firstName', 'Mary'], ['lastName', 'Ivanova']];\nObject.fromEntries (arrl); // firstName: \"Mary\", lastName: \"Ivanova\")\n\nconst arr2 = [['one', 1], ['two', 2], ['three', 3]];\nObject.fromEntries (arr2); //[one: 1, two: 2, three: 3)",
    "images":[]
  },
  "j298":{
    "id":"08f36e385",
    "theme":"es",
    "question":"Для чего используются методы .flat() и .flatMap()?",
    "answer":"Метод flat() возвращает новый массив, в котором все элементы вложенные подмассивы, были рекурсивно подняты или раскрыты на указанный уровень. Этот метод может принимать аргумент - это число, которое определяет, сколько уровней вложенности должно быть раскрыто. Другими словами, передавая цифру 2, flat может раскрыть 2 вложенных уровня подмассивов, а при передаче цифры 3 этих уровней становится три. Также в качестве аргумента можно передавать ключевое слово infinity. В этом случае, количество уровней вложенности не имеет значения. Все многомерные массивы будут преобразованы в плоскую одноуровневую структуру. Следует отметить, что одна из особенностей данного метода – это удаление пустых слотов из массива.\n\nМетод flatMap – это практически смесь двух методов: уже давно существующего метода map и введенного метода flat. Метод flatMap сначала принимает функцию к каждому элементу, а затем преобразует полученный результат в плоскую структуру или раскрывает подмассивы и помещает их в новый массив. В качестве аргумента он принимает callback. В связи с чем у него появляется ограничение – это раскрытие многомерных массивов только на 1 уровень.",
    "codeexample":"const arrl [1, 2, [3, 4]];\narri.flat(); // [1, 2, 3, 4]\n\nconst arr2 [1, 2, [3, 4, [5, 6]]];\narr2.flat(); // [1, 2, 3, 4, 15, 6]]\n\nconst arr3 = [1, 2, [3, 4, [5, 6]]];\narr3. flat (2); // [1, 2, 3, 4, 5, 6]\n\nconst arr4 [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];\narr4.flat (Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nconst arr5 [1, 2, , 4, 5];\narr5.flat(); // [1, 2, 4, 5]\n\nconst arr6= [[1], [2], [3], [4]];\narr7.flatMap(x => [x2]); // [2, 4, 6, 8]",
    "images":[]
  },
  "j299":{
    "id":"08f36e386",
    "theme":"es",
    "question":"Для чего используются методы .padStart() и .padEnd()?",
    "answer":"В версии ECMAScript 2017 появились несколько дополнительных методов для работы со строками. Методы padStart и padEnd предназначены для того, чтобы дополнять строку до нужного размера. Метод padStart подставляет дополнительные символы перед началом строки, то есть слева. А padEnd – справа и после конца строки. Оба этих методы принимают 2 аргумента:\n\t1.Требуемая длина ( тип этого аргумента – число ).\n\t2.Символ, которым будет осуществляться дополнение строки до требуемой длины.\nТакже следует отметить, что второй аргумент является необязательным и в случае если он не указывается, то строка будет дополнена пробельными символами. Также стоит упомянуть, если исходная строка длиннее, чем заданный параметр, то строка останется неизменной.",
    "codeexample":"\nconst str = \"test\";\n\nstr.padStart(10,'~'); // '-------test'\nstr.padEnd (10,'~');  // 'test-------\n\nstr.padStart(10);     // '     test'\nstr.padEnd(10);       // 'test      '",
    "images":[]
  },
  "j300":{
    "id":"08f36e387",
    "theme":"es",
    "question":"Для чего используются методы .startsWith() и .endsWith()?",
    "answer":"В версии ECMAScript 2015 появились методы startsWith и endsWith, которые предназначены для работы со строками. Они определяют, начинается ли строка или заканчивается требуемыми символами. Другими словами, методы помогают определять соответствие в строках в начале и в конце. Данные методы принимают 2 аргумента:\n\t1.Это символы, которые будут искаться в строке\n\t2.Это длина.\nСледует отметить, что в обоих методах это разные значения. Когда используется метод startsWith, происходит поиск строки, которую в него передали строке, к которой он применяется. Если посмотреть на пример в первом случае, когда перелается ‘Hello’, результатом получаем ‘true’, так как строка действительно начинается этим символом. Во втором же случае получается ‘false’.\nАналогично с методом endsWith, только теперь поиск начинается именно с конца. То есть, базовая строка заканчивается словом ‘Yauhen’ и соответственно в первом случае получаем ‘true’. Во втором же – ‘false’. Что касается второго аргумента, то он является опциональным. Тип данных этого аргумента – число. И если в метод startsWith передать второй аргумент, то исходная строка обрежется и поиск начнётся с символа, порядковый номер которого соответствует переданному числу. Если же второй аргумент передать в метод endsWith, то исходная строка обрежется именно до заданного количества символов, то есть в строке остаётся столько символов, сколько передаётся в аргумент.",
    "codeexample":"const str = \"Hello, my name is Yauhen\";\n\nstr.startsWith(\"Hello\"); // true\nstr.startsWith(\"Hi\");    // false\n\nstr.endsWith(\"Alice\");   // true\nstr.endsWith(\"Nelli\");   // false\n\n// \"my name is Alice\";\nstr.startsWith(\"my\", 7); // true\n\n// \"my name is Alice\";\nstr.startsWith(\"name\", 7); // false",
    "images":[]
  },
  "j301":{
    "id":"08f36e388",
    "theme":"es",
    "question":"Как в JavaScript удалять пробельные символы в начале и в конце строки?",
    "answer":"Механизм обрезки чаще всего применяется для input-полей, куда пользователь вводит свою информацию, чтобы избежать возможных ошибок в полях с паролем, почтой, итд.\n\nВ JavaScript для удаления пробельных символов в начале и в конце строки можно использовать метод trim(). Этот метод удаляет все пробелы, табуляции, переносы строк и другие пробельные символы с начала и конца строки.\n\tМетод trim() - появился еще в ранних версиях стандарта.\n\nВ 2019 году появились также методы:\n\trimStart() -  удаление только пробелов в начале строки,\n\ttrimEnd() - удаление только пробелов в конце строки.",
    "codeexample":"",
    "images":[]
  },
  "j302":{
    "id":"08f36e389",
    "theme":"es",
    "question":"Расскажите об операторе Optional Chaining (?.)?",
    "answer":"При обращению к свойству, которое находится глубоко в древовидной системе, часто приходится добавлять проверки на существование промежуточных узлов.Оператор Optional Chaining (?.) в JavaScript — это новый синтаксис, который был добавлен в ECMAScript 2020 (ES11). Он позволяет безопасно обращаться к вложенным свойствам объектов, не проверяя каждый уровень объекта на наличие значения. Если значение не существует (например, undefined или null), оператор ?. возвращает undefined вместо выбрасывания ошибки.Таким образом мы получаем более понятный вложенный код.В примере, если user или user.address окажутся undefined или null, выражение user?.address?.city не вызовет ошибку, а просто вернет undefined.",
    "codeexample":"let user {\nname: \"Alice\",\n\taddress: {\n\t\tcity: \"New York\",\n\t\tzipCode: 10001\n\t}\n};\n\n// бeз Optional Chaining:\nlet city - user && user.address && user.address.city;\nconsole.log(city); // \"New York\"\n\n// C Optional Chaining:\nlet citywithOptionalChaining = user?.address?.city;\nconsole.log(cityWithOptionalChaining); // \"New York\"",
    "images":[]
  },
  "j303":{
    "id":"08f36e390",
    "theme":"es",
    "question":"Для чего используется метод .replaceAll()?",
    "answer":"Метод .replaceAll() в JavaScript используется для замены всех вхождений определенной строки или регулярного выражения в другой строке на новое значение. Он был добавлен в ECMAScript 2021 (ES12) и работает аналогично методу .replace(), но с той разницей, что заменяет все вхождения, а не только первое.\n\nstring.replaceAll(searchValue, newValue), где:\nsearchValue — строка или регулярное выражение, которое нужно заменить.\nnewValue — строка, на которую будет заменено вхождение searchValue.\n\nКак и другие методы работы со строками, .replaceAll() возвращает новую строку и не изменяет исходную.\nМожет также использоваться с регулярными выражениями.\nВ примере используется регулярное выражение /apple/g, которое ищет все вхождения \"apple\" и заменяет их на \"orange\".",
    "codeexample":"let str = \"apple banana apple\";\nlet result = str.replaceAll(/apple/g, \"orange\");\n\nconsole.log(result); //\"orange banana orange\"",
    "images":[]
  },
  "j304":{
    "id":"08f36e391",
    "theme":"es",
    "question":"Что такое оператор логического присваивания?",
    "answer":"Операторы логического присваивания в JavaScript — это комбинации логических операторов и оператора присваивания, которые позволяют одновременно выполнять логическую операцию и присваивать результат этой операции переменной. Они были добавлены в ECMAScript 2021 (ES12) и упрощают код, делая его более компактным.\nВ JavaScript существует три основных оператора логического присваивания:\n\nЛогическое И с присваиванием (&&=)\nОператор &&= присваивает значение переменной только в том случае, если текущие значения переменной и правой части выражения оба истиноподобны.\nЭквивалент: x &&= y аналогично x = x && y.\n\nЛогическое ИЛИ с присваиванием (||=)\nОператор ||= присваивает значение переменной только в том случае, если текущее значение переменной ложно (false).\nЭквивалент: x ||= y аналогично x = x || y.\n\nЛогическое \"nullish\" нулевое присваивание (??=)\nОператор ??= присваивает значение переменной только в том случае, если текущее значение переменной равно null или undefined.\nЭквивалент: x ??= y аналогично x = x ?? y.",
    "codeexample":"\n//Логическое И с присваиванием (&&=)\nlet x = true;\nlet y = false;\n\nx &&= y; // x = x && y\n\nconsole.log(x); // false (так как x=true и y=false)\n\n\n//Логическое ИЛИ с присваиванием (||=)\nlet x = false;\nlet y = true;\n\nx ||= y; // x = x || y\n\nconsole.log(x); // true (так как x-false и y=true)\n\n\n//Логическое \"nullish\" нулевое присваивание (??=)\nlet x = null;\nlet y = \"default value\":\n\nx ??= y; // x = x ?? y\n\nconsole.log(x); // \"default value\" (Taк как x=null)",
    "images":[]
  },
  "j305":{
    "id":"08f36e392",
    "theme":"es",
    "question":"Разница между ES6-классами и конструкторами функций?",
    "answer":"В JavaScript есть два основных способа создания объектов и организации кода: с помощью ES6-классов и конструкторов функций. Оба подхода имеют схожую функциональность, основное отличие - принцип наследования.\n\nES6-классы\n\tСинтаксис: Синтаксис классов был добавлен в ECMAScript 2015 (ES6) и выглядит более современно и структурировано.  Хотя под капотом это все еще функции, классы делают код более читаемым\n\tНаследование: Для наследования используется ключевое слово extends. Внутри подклассов используется super() для вызова конструктора родительского класса.\n\nКонструкторы функций\n\tСинтаксис: Это более старый способ определения объектов, существующий с ранних версий JavaScript. Код может казаться более низкоуровневым и сложным для понимания.\n\tНаследование: Создается базовый (родительский) конструктор, затем дочерний в котором идет вызов родительского конструктора для наследования его свойств, затем через Object.create наследуются методы родительского конструктора. После уже создаются экземпляры дочернего элемента.",
    "codeexample":"\n//ES6-классы\n\nclass Animal {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t}\n\tspeak() {\n\t\tconsole.log('${this.name} makes a noise.`);\n\t}\n}\n\nclass Dog extends Animal {\n\tspeak() {\n\t\tconsole.log(${this.name} barks.`);\n\t}\n}\n\nconst dog = new Dog('Rex');\ndog.speak(); // Rex barks.\n\n\n//Конструкторы функций\nfunction Animal(name) {\n\tthis.name = name;\n}\n\nAnimal.prototype.speak = function() {\n\tconsole.log('${this.name} makes a noise.`);\n};\n\nfunction Dog(name) {\n\tAnimal.call(this, name); // Haследуем свойства\n}\n\nDog.prototype = Object.create(Animal.prototype); // наследуем методы\nDog.prototype.constructor = Dog;\n\nDog.prototype.speak = function() {\n\tconsole.log('${this.name} barks.`);\n};\n\nconst dog = new Dog('Rex');\ndog.speak(); // Rex barks.",
    "images":[]
  },
  "j306":{
    "id":"08f36e393",
    "theme":"es",
    "question":"Что такое оператор нулевого слияния (??)?",
    "answer":"Оператор нулевого слияния ??= присваивает значение переменной только в том случае, если текущее значение переменной равно null или undefined. Эквивалент: x ??= y аналогично x = x ?? y.",
    "codeexample":"let x = null;\nlet y = \"default value\":\n\nx ??= y; // x = x ?? y\n\nconsole.log(x); // \"default value\" (Taк как x=null)",
    "images":[]
  },
  "j311":{
    "id":"08f36e398",
    "theme":"es",
    "question":"В чём отличие оператора нулевого слияния (??) и оператора “ИЛИ” (||)?",
    "answer":"Оператор нулевого слияния можно рассматривать как частный случай логического оператора ИЛИ (||), который возвращает правый операнд, если в левом операнде хранится любое ложноподобное значение.\nОператор нулевого значения возвращает правый операнд, только если в левом null или undefined.",
    "codeexample":"",
    "images":[]
  },
  "j307":{
    "id":"08f36e394",
    "theme":"es",
    "question":"Назовите основные методы и свойства работы с коллекцией Map?",
    "answer":"В JavaScript Map — это встроенная структура данных, представляющая собой коллекцию ключ-значение. В отличие от объектов, где ключи должны быть строками или символами, в Map ключами могут быть любые типы данных, включая объекты и функции. Map сохраняет порядок элементов в том порядке, в котором они были добавлены, что делает его полезным для ситуаций, когда порядок важен.",
    "codeexample":"//Основные методы Map:\n\n//1.set(key, value) - Добавляет новый элемент с указанными ключом и значением в коллекцию Map. Если ключ уже существует, то значение обновляется.\n\n\tconst map = new Map();\n\tmap.set('name', 'Alice');\n\tmap.set(1, 'one');\n\n//2.get(key) - Возвращает значение, связанное с ключом. Если ключ отсутствует, возвращает undefined.\n\n\tconsole.log(map.get('name')); // Alice\n\tconsole.log(map.get('age')); // undefined\n\n//3.has(key) - Проверяет наличие элемента с указанным ключом. Возвращает true, если элемент с таким ключом существует, и false в противном случае.\n\n\tconsole.log(map.has('name')); // true\n\tconsole.log(map.has('age')); // false\n\n//4.delete(key) - Удаляет элемент по указанному ключу. Возвращает true, если элемент был успешно удален, и false, если такого ключа не существовало.\n\n\tmap.delete('name'); // true\n\n//5.clear() - Удаляет все элементы из коллекции Map.\n\n\tmap.clear();\n\tconsole.log(map.size); // 0\n\n6.size (свойство) - Возвращает количество элементов в коллекции Map.\n\n\tconst map = new Map();\n\tmap.set('name', 'Alice');\n\tmap.set(1, 'one');\n\tconsole.log(map.size); // 2",
    "images":[]
  },
  "j308":{
    "id":"08f36e395",
    "theme":"es",
    "question":"Назовите основные методы и свойства работы с коллекцией Set?",
    "answer":"В JavaScript Set — это встроенная структура данных, представляющая собой коллекцию уникальных значений. Это делает Set полезным для удаления дубликатов из массивов и других коллекций. Set сохраняет порядок добавления элементов, так что при итерации по Set элементы будут возвращаться в том порядке, в котором они были добавлены.",
    "codeexample":"//Основные методы Set\n\n//1.add(value) - Добавляет новый элемент в коллекцию Set. Если элемент уже существует, он не будет добавлен повторно. Возвращает сам объект Set, что позволяет использовать цепочку вызовов.\n\n\tconst set = new Set();\n\tset.add(1);\n\tset.add(2);\n\tset.add(1); // Не добавится, так как 1 уже существует\n\tconsole.log(set); // Set { 1, 2 }\n\n//2.delete(value) - Удаляет элемент из коллекции Set по его значению. Возвращает true, если элемент был удален, и false, если такого элемента не существовало.\n\n\tset.delete(2); // true\n\tconsole.log(set); // Set { 1 }\n\n//3.has(value) - Проверяет наличие элемента в коллекции Set. Возвращает true, если элемент существует, и false в противном случае.\n\n\tconsole.log(set.has(1)); // true\n\tconsole.log(set.has(3)); // false\n\n//4.clear() - Удаляет все элементы из коллекции Set.\n\n\tset.clear();\n\tconsole.log(set.size); // 0\n\n//5.size (свойство) - Возвращает количество элементов в коллекции Set.\n\n\tconst set = new Set([1, 2, 3]);\n\tconsole.log(set.size); // 3",
    "images":[]
  },
  "j309":{
    "id":"08f36e396",
    "theme":"es",
    "question":"Как осуществить перебор элементов в коллекциях Map и Set?",
    "answer":"Коллекции Map и Set можно перебирать. Есть 3 основных метода, с помощью которых, к элементам коллекции можно получить доступ (которые в свою очередь, кстати, идентичны методам обычного объекта). Это .values(), .keys() и .entries(). Только данные, которые они возвращают, отличаются в зависимости от типа коллекции.\n\nЕсли говорить о Map, то .keys() возвращает итерируемый объект по ключам, .values()- возвращает итерируемый объект по значениям , .entries() возвращает итерируемый объект по парам ключ-значение. И кстати, этот вариант используется по умолчанию в цикле for…of.\n\nЧто же касается коллекции Set, то .values() и.keys() возвращают и итерируемые объекты по значениям, а .entries() возвращает итерируемый объект по парам ключ-значение.\n\nДанные методы присутствуют просто для обратной совместимости с Map, также перебор коллекции можно осуществлять с помощью метода forEach() или цикла for…of",
    "codeexample":"",
    "images":[]
  },
  "j310":{
    "id":"08f36e397",
    "theme":"es",
    "question":"Как работают дефолтные параметры в ES6?",
    "answer":"В ES6 и последующих версиях стандарта ecmascript появилась возможность устанавливать значение по умолчанию для параметров функций. Это означает, что если при вызове функции определенный параметр не будет передан, он получить значение по умолчанию. На примере ниже: если вызвать greet(“John”), то второй параметр не будет перед, и в данном случае он получит значение по умолчанию hello. В консоль будет выведено “Hello, John!”. Если же вызвать greet(“John”, “Hi”), функция получить оба параметра, и значение по умолчанию будет проигнорировано. В этом случае будет выведено “Hi, John!”. Использование значений по умолчанию для параметров позволяет сделать функции более гибкими и устойчивыми к ошибкам, так как функция будет использовать некоторое разумное значение даже в случае если ей не передан нужный параметр.",
    "codeexample":"",
    "images":[]
  },
  "j312":{
    "id":"08f36e399",
    "theme":"es",
    "question":"Какие нововведения были представлены в ECMAScript 2021 (ES12)?",
    "answer":"Это открытый вопрос, который помогает понять следите ли вы с важными обновлениями языка, на котором пишете код. Вот некоторые из нововведений:\n\t1)метод replaceAll(). Этот метод был добавлен для замены всех вложений подстроки к строке, а не только первого, как это делает метод replace(), который выходит из выполнения при нахождении первого подходящего элемента;\n\t2)Promise.any- принимает итерируемый объект (например массив промисов) и возвращает промис, который исполняется при выполнении любого из промисов. Это отличается Promise.all, который ожидает выполнения всех промисов;\n\t3)логическое присваивание.  ES12 ввел новый оператор логического присваивания- это и равно,  или равно, нулевое cлияние равно\n\t4)numeric separators. В ES12 появилась возможность использования символов нижнего подчеркивания числовых литералов для улучшения читаемости.\nЭто лишь некоторые из нововведений ES12, которое можно перечислить.   Подробнее можно почитать дополнительно.",
    "codeexample":"",
    "images":[]
  },
  "r1":{
    "id":"08f36e301",
    "theme":"r",
    "question":"Что такое React?",
    "answer":"React - это JavaScript библиотека с открытым исходным кодом, разработанная компанией Facebook. Он предназначен для создания пользовательских интерфейсов. React отвечает за слой представление, то есть vue, в мобильных и веб-приложениях. Основная философия - это компонентный подход, то есть весь интерфейс может быть разбит на минимальные функционирующие единицы -компоненты. Переиспользуя такие компоненты в других местах приложения можно в разы ускорить разработку.",
    "codeexample":"",
    "images":[]
  },
  "r2":{
    "id":"08f36e302",
    "theme":"r",
    "question":"Перечислите особенности React?",
    "answer":"К основным особенностям библиотеки React можно отнести следующие:\n\t1.Использование виртуального DOM (Virtual DOM) вместо реального. Делается это потому что манипуляции с реальным DOM-деревом тяжеловесное, а Virtual DOM - это по сути объект на основании которого строится реальный DOM, поэтому все операции перерисовки происходят намного быстрее.\n\t2.SSR (Server-Side Rendering) или поддержка рендеринга на стороне сервера. Идея в том, что используя React вся разметка отрисовывается внутри одного корневого div элемента,что не очень хорошо для SEO. В связи с чем в React была добавлена поддержка SSR. В этом случае первоначальная разметка строится на сервере и полностью передается и отрисовывается на клиенте.\n\t3.Принцип однонаправленного потока данных, другими словами все данные передаются от корневых компонентов во вложенные, но не в обратном направлении.\n\t4.Использование переиспользуемых компонентов для построения пользовательского интерфейса.",
    "codeexample":"",
    "images":[]
  },
  "r3":{
    "id":"08f36e303",
    "theme":"r",
    "question":"\tЧто такое Virtual DOM? Как он работает с React?",
    "answer":"Главная проблема DOM - это то, что он никогда не был рассчитан для создания динамического пользовательского интерфейса. Даже на небольших веб-страницах располагается тысячи DOM-узлов, поэтому любая операция будто поиск элемента или его динамическая вставка занимает длительный временной интервал, и соответственно если на странице содержится много динамической логики, то перфоманс будет оседать.\n\tReact предложил альтернативный путь работы с DOM-деревом - это виртуальное дерево. Представляет оно из себя обычный объект, который по сути является легковесной копией реального DOM-дерева, поэтому если в компоненте происходят какие-то изменения, которые ведут к перерисовке, то сначала происходит сравнение старой версии Virtual DOM и новой. После нахождения разницы, изменение применяется в реальному DOM-дереву, этот процесс называется согласование. В результате перерисовывается не вся страница, а лишь часть элементов которых затронуло изменение.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/7kai7wcsp0d59z0c8jh4e/1_BcD-GDllCyyF58C4LEJVVw.webp?rlkey=h733a4u1w0e6faxvky4ov047w&st=wqawqs5i&dl=1"]
  },
  "r4":{
    "id":"08f36e304",
    "theme":"r",
    "question":"Для чего нужен атрибут key при рендере списков?",
    "answer":"Ключи или keys помогают React определять какие элементы были изменены, добавлены или удалены.  Их необходимо указывать, чтобы React смог сопоставлять элемента массива с течением времени и помочь библиотеке  точно определить то место, где произошло изменение. Чаще всего ключи применяются при рендеринге однотипных списков.\nЛучший способ выбрать ключ - это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего для данных целей используется уникальный идентификатор или id из данных, если такого  id  нет, то в крайнем случае можно использовать индекс элемента как ключ. Но нужно иметь в виду, что при таком подходе в консоль будет выброшено предупреждение о том,  что это не оптимальный вариант и лучше использовать какой-либо уникальный идентификатор.",
    "codeexample":"const numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =>\n\t// adding key for each element\n\t<li key={number.toString()}>\n\t\t{number}\n\t</li>\n);\n\nconst todos = [\n\t{ id: 1, text: 'Learn React' },\n\t{ id: 2, text: 'Subscribe' },\n\t{ id: 3, text: 'Put like' },\n];\nconst todoItems = todos.map(({ id, text }) =>\n\t// use 'id' as a key\n\t<li key={id}>\n\t\t{text}\n\t</li>\n);",
    "images":[]
  },
  "r5":{
    "id":"08f36e305",
    "theme":"r",
    "question":"Что такое PureComponent?",
    "answer":"React PureComponent похож на стандартный React Component. Их отличие заключается в том, что React Component не реализует ShouldComponentUpdate, в то время как  React PureComponent реализует его поверхностным сравнением  пропсов и состояния. Если метод рендер React Component всегда рендерит одинаковый результат при одних и тех же промисах и состояниях, то для повышения производительности в некоторых случаях используется PureComponent.\nМетод ShouldComponentUpdate внутри PureComponent делает только поверхностное сравнение объектов и если пропсы или состояние не изменяются, то дополнительный перерендеринг компонента не произойдет. Однако PureComponent не подойдет если пропсы или состояние имеют сложную структуру. В этом случае при поверхностной проверке рендер может не произойти в тот момент, когда он нужен.",
    "codeexample":"class Count extends PureComponent {\n\tstate = {\n\t\tcount: 10,\n\t}\n\nhandleClick = () => {\n\t\tthis.setState(({ counter }) => ({\n\t\t\tcounter: ++counter,\n\t\t}))\n\t}\n\trender() {\n\t\treturn (\n\t\t<div className=\"count\">\n\t\t\t<h1>Count: {this.state.count}</h1>\n\t\t\t<button onClick={this.handleClick}>+1</button>\n\t\t</div>\n\t\t);\n\t}\n}\nexport default Count;",
    "images":[]
  },
  "r6":{
    "id":"08f36e306",
    "theme":"r",
    "question":"Что такое Компонент высшего порядка (Higher-Order Component/HOC)?",
    "answer":"HOC или компоненты высшего порядка - это продвинутая техника переиспользования компонентной логики. Как указано в самой документации - это не часть API, а всего лишь паттерн. Другими словами компонент высшего порядка - это функция, которая принимает другой компонент, расширяет его функциональность, не изменяя исходный код и  возвращает новый компонент.На примере LoadingHOC на входе пропсы и оборачивает компонент. На выходе он возвращает расширенный компонент, который в случае отсутствия пропсов будет отображать лоадер. При этом при добавления такой логики внутренняя реализация  передаваемого компонента не изменилось.",
    "codeexample":"const isEmpty = (prop) => (\n\tprop === null ||\n\tprop === undefined ||\n\t(prop.hasOwnProperty ('length') && prop.length === 0) ||\n\t(prop.constructor === Object && Object.keys(prop).length === 0)\n);\n\nconst LoadingHOC = (loadingProp) => (WrappedComponent) => {\n\treturn class LoadingHOC extends Component {\n\t\trender() {\n\t\t\treturn isEmpty(this.props [loadingProp]) ?\n\t\t\t<div className=\"loader\"/>\n\t\t\t: <WrappedComponent {... this.props} />;\n\t\t}\n\t}\n}\n\nexport default LoadingHOC;",
    "images":[]
  },
  "r7":{
    "id":"08f36e307",
    "theme":"r",
    "question":"Разница между управляемыми (controlled) и неуправляемыми (uncontrolled) компонентами?",
    "answer":"В HTML такие элементы как input, textarea и select обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React изменяемое состояние обычно содержится в свойстве  компонента State и обновляются через вызов setStatе, либо при использовании хука useState.\n\nНеуправляемые (uncontrolled) компоненты опираются на DOM в качестве источника данных. Другими словами это обычные HTML-элементы, которые обновляются динамически, инкапсулируют данные внутри себя и никак не связаны с React.\n\nВ управляемом (controlled) компоненте с каждым изменением состояния связана функция-обработчик, а  сами обновляемые данные хранятся внутри свойства компонента state.  Благодаря этому механизму данные, которые хранятся внутри управляемых элементов, могут быть доступны за их пределами и с ними легко взаимодействовать.",
    "codeexample":"",
    "images":[]
  },
  "r8":{
    "id":"08f36e308",
    "theme":"r",
    "question":"Методы жизненного цикла компонента в React?",
    "answer":"\tconstructor - это конструктор компонента, который вызывается до того как компонент будет смонтирован;\n\tcomponentDidMount - вызывается сразу после монтирования компонента. Это отличное место для создания сетевых запросов  и настройки подписок компонента на различные события, а также в этом методе должны происходить действия, для работы которых требуется наличие DOM-узлов;\n\tcomponentDidUpdate - вызывается сразу после обновления. Метод позволяет работать с DOM при обновлении компонента, также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими;\n\tcomponentWillUnmount - вызывается непосредственно перед размонтированием компонента, в нем выполняются необходимые сбросы (отмена таймера, сетевых запросов и подписок, созданных в componentDidMount);\n\tshouldComponentUpdate - вызывается перед рендером, когда получает новые пропсы или состояния, используется для повышения производительности, чтобы избежать лишних перерисовок;\n\trender - это единственный обязательный метод в компоненте, предназначен он для возврата разметки;\n\tgetDerivedStateFromProps - вызывается непосредственно перед вызовом  метода render, возвращает объект для обновления состояния или null, чтобы ничего не обновлять. Метод существует для редких случаев когда состояние зависит от изменений в пропсах;\n\tgetSnapshotBeforeUpdate - позволяет компоненту брать некоторую информацию из DOM перед ее возможным изменением;\n\tgetDriveStateFromError - метод жизненного цикла, которые вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращение значение для обновления состояния;\n\tcomponentDidCatch - используется для логирования ошибок, вызывается  после возникновения ошибки у компонента-потомка.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/9vv5m6t37j6wfx1xu4b71/bCoYZgIDd.webp?rlkey=4478pfub9liwic2gk7xbvlpvj&st=9dxnxw20&dl=1"]
  },
  "r9":{
    "id":"08f36e309",
    "theme":"r",
    "question":"Стадии жизненного цикла компонента в React?",
    "answer":"Жизненный цикл компонента состоит из 3 основных стадий:\n1.Монтирование - компонент готов к встраиванию в браузерный DOM. Эта стадия охватывает инициализацию в конструктор, а также методы жизненного цикла getDerivedStateFromProps, render и componentDidMount.\n2.Обновление - на данной стадии компонент обновляется либо из-за получения новых пропсов, либо из-за обновления состояния. Эта стадия охватывает такие методы жизненного цикла как, getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate и componentDidUpdate,.\n3.Размонтирование - на этой стадии компонент удаляется из браузерного DOM. Включает метод жизненного цикла componentWillUnmount.Следует отметить, что в React также  имеются особая стадия применения изменения DOM:\n - рендеринг  - компонент рендерится без каких-либо побочных эффектов. На данной стадии React может приостанавливать, прерывать или перезапускать рендеринг;\n - recommit - перед обновлением компонента есть момент когда React читает через DOM через getSnapshotBeforeUpdate.\n - commit - React изменяет DOM и выполняет завершающие методы жизненного цикла, такие как componentDidMount (при монтировании), componentDidUpdate (при обновлении), componentWillUnmount (при размонтировании).",
    "codeexample":"",
    "images":[]
  },
  "r10":{
    "id":"08f36e310",
    "theme":"r",
    "question":"Что такое React Reconciliation?",
    "answer":"React Reconciliation - это механизм сверки, посредством которого React обновляет DOM-дерево. Когда состояние компонента изменяется React должен рассчитать необходимость обновления DOM. Это делается путем создания Virtual DOM и сравнением его с текущим. В этом контексте Virtual DOM будет содержать новое состояние компонента, при сравнении двух деревьев первым делом React  сравнивает два корневых элемента. Всякий раз когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих и сохраняет лежащих в основе этих элементов DOM-узел и обновляет только измененные атрибуты. По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React  проходит по обоим спискам потомков одновременно и создает мутацию когда находит отличие. Когда у дочерних элементов есть ключи React  использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/7kai7wcsp0d59z0c8jh4e/1_BcD-GDllCyyF58C4LEJVVw.webp?rlkey=h733a4u1w0e6faxvky4ov047w&st=uusyi4w5&dl=1"]
  },
  "r11":{
    "id":"08f36e311",
    "theme":"r",
    "question":"Что такое портал (Portal)?",
    "answer":"Portal - это компонент, который рендерит свое содержимое в произвольную часть DOM-дерева. Такое поведение позволяет отображать элементы за пределами блоков, например, со свойством overflow: hidden, и при этом минимально менять дерево компонентов.\n\nКейсы использования порталов: модальные или диалоговые окна, а также различные tool-типы. В большинстве своем они не зависят от текущей разметки и появляются поверх любого layout. Создается портал с помощью метода createPortal. Метод принимает два аргумента:\n\t1.children или разметка, которая будет принимать компонент портала,\n\t2.созданный DOM-элемент.",
    "codeexample":"const modal Root = document.getElementById('modal-root');\n\nclass Modal extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.el = document.createElement('div');\n\t}\n\tcomponentDidMount() {\n\t\tmodal Root.appendChild(this.el);\n\t}\n\tcomponentwillUnmount() {\n\t\tmodal Root.removeChild(this.el);\n\t}\n\trender() {\n\t\t// Portal creation\n\t\treturn ReactDOM.createPortal(\n\t\t\tthis.props.children,\n\t\t\tthis.el,\n\t\t);\n\t}\n}",
    "images":[]
  }, 
  "r67":{
    "id":"08f36e367",
    "theme":"r",
    "question":"Что такое контекст (Context)?",
    "answer":"Context - способ передачи данных через дерево компонентов без необходимости передавать свойство вручную на каждом уровне.\nВ стандартном  React-приложении данные передаются сверху вниз по иерархии элементов, или проще говоря, от родителя к потомку через свойство props. Если представить, что свойство, определенное на верхнем уровне, используется на нижнем, предположим через два-три уровня вложенности, то пробрасывать такое свойство через React-компонентов довольно проблематично. Так же ситуация может усугубиться тем, что пробрасывать нужно сразу несколько свойств, и таким образом, количество пропсов у компонентов верхнего уровня может быть огромным. Обычно когда такие ситуации возникают, то подключаются  Redux. И часть ответственности он берет на себя.\nС версии React 16.3 был представлен механизм Context. В этом случае используя метод createContext создаются данные, которые нужно передать через несколько уровней. Это может быть строка, функция, а может быть объект, которая сразу будет содержать несколько элементов. Далее эти данные с помощь специальных оберток  Consumer и Provider можно получить и использовать в целевом компоненте.\nС версии 16.8 для аналогичной задачи используется хук useContext",
    "codeexample":"// (1) File context.js\nimport React from 'react';\nexport const Theme Context = React.createContext('main-theme');\n\n// (2) File App.js\n// Importing ThemeContext\nimport { ThemeContext } from './context';\n// Importing useContext hook\nimport React, { useContext } from 'react';\n\nexport const App = () => {\n\t// Assign the result of the hook work to a variable\n\tconst theme = useContext (ThemeContext);\n\n\treturn <App theme ={theme} />;\n};",
    "images":[]
  },
  "r12":{
    "id":"08f36e312",
    "theme":"r",
    "question":"Что такое React хуки (Hooks)?",
    "answer":"Хуки - это нововведение в React 16.8, которая позволяет использовать состояние и другие возможности Reactе без написания классов. По сути хуки - это функции, с помощью которых можно подцепиться к состоянию и методам жизненного цикла React из функционального компонента. Они не работают внутри классов и дают возможность использовать React без классовых компонентов.\n\nК основным хукам можно отнести:\n\t1.useContext - позволяет использовать Context;\n\t2.useState - дает возможность на использование state;\n\t3.useEffect - по сути это аналог всех методов жизненного цикла;\n\t4.useRef - позволяет использовать ссылки;\n\t5.useReducer - хук для использования Reducer;\n\t6.useLayoutEffect - аналогичен useEffect, который запускается асинхронного после изменений в DOM-дереве;\n\t7.useCallback - используется для возврата мемоизированного сallback. Предначен для повышения перфоманса и является аналогом shouldComponentUpdate;\n\t8.useMemo - используется для возврата сохраненного значения, так же предназначен для повышения перфоманса;\n\t9.useImperativeHandle - кастомизирует значение instanсe, которая предоставляется родителям при использовании ref;\n\t10.useDebugValue - создает лейбл для пользовательских хуков.\nСледует отметить, помимо стандартных хуков, которые предоставляются самой библиотекой, можно создать и пользовательские хуки.",
    "codeexample":"const Search ({ value, onChange, onClick, onkeypress }) => (\n\t// JSX syntax\n\t<div className={styles.search}>\n\t\t<input\n\t\t\tclassName={styles.input}\n\t\t\ttype=\"text\"\n\t\t\tonChange={onChange}\n\t\t\tonkeypress={onKeyPress}\n\t\t\tvalue={value}\n\t\t/>\n\t<Icon className={styles.searchSubmit} flag=\"fa\" name=\"search\"\nonClick={onClick} />\n\t</div>\n);",
    "images":[]
  },
  "r13":{
    "id":"08f36e313",
    "theme":"r",
    "question":"Что Такое JSX?",
    "answer":"JSX (JavaScript XML) - это новый диалект языка JavaScript, который внедряет необработанный HTML-шаблон внутрь кода JavaScript.\nReact JS использует этот формат для того, чтобы сделать HTML более простым для чтения и записи. В нем есть некоторые несущественные ограничения, например,  он не поддерживает конструкцию if…else или прямые комментарии, а также особенности по типу инлайновых функций, специфичного наименования HTML атрибутов или уникальный тэг для фрагмента.\nJSX-код сам по себе не может быть прочитан браузером, поэтому изначально он должен быть переведен в JavaScript с помощью babel и webpack.",
    "codeexample":"",
    "images":[]
  },
  "r14":{
    "id":"08f36e314",
    "theme":"r",
    "question":"Разница между состоянием(state) и пропсами(props)?",
    "answer":"Состояние - это объект содержащий некоторую информацию, которая может измениться с течением жизненного цикла компонента.\nСостояние похоже на пропс, но оно является приватным и полностью контролируется компонентом, то есть оно недоступно для других компонентов, кроме того, которому оно принадлежит, и который его определяет.\nПропсы - это входные данные для компонента, то есть те, которые он получает снаружи. Основное предназначение пропсов в React заключается в предоставлении компоненту следующего функционала: передача данных компоненту, вызов изменения состояния, использование внутри метода render.\nПропс и  state являются обычными js объектами. Несмотря на то, что они содержат информацию, которая при рендеринге компонента функционал у них разный. Пропсы передаются компоненту подобно аргументам, передаваемым функции, а состояние управляется компонентом как переменная, объявленная внутри функции.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/0r11ax1y29me1z9dh3ze5/qtv1ex4jequcrlpjntgx.webp?rlkey=9pokba9oi5t4psmzr2jtrd9s7&st=nbg7x0ns&dl=1"]
  },
  "r15":{
    "id":"08f36e315",
    "theme":"r",
    "question":"Что такое React Fiber?",
    "answer":"React Fiber - это новый движок согласования изменения основного алгоритма в React 16 цель React Fiber - это повысить его производительность для таких областей, как анимация, макет и жесты. Его главная особенностью является инкрементный рендеринг - это возможность разделить работу рендеринга на куски и распределить их по нескольким кадрам, по сути это то, что описывается в документации но дополнительно к целям React Fiber можно отнести возможность разбить прерываемую работу на куски, возможность расставлять приоритеты, перебазировать и повторно использовать незавершённую работу, возможность переключения между родителями и детьми для поддержки loyout в React, возможность возврата нескольких элементов из render и улучшенная поддержка ошибок или error boundary.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/e4gobnuqlnwy6jb3wlbmq/fiber_structure_of_react_js_1_cd9b031713.webp?rlkey=sv8w0ju61yxkj2yhtcuufj9fh&st=07c4shvc&dl=1"]
  },
  "r16":{
    "id":"08f36e316",
    "theme":"r",
    "question":"Что такое фрагмент (Fragment)? Почему фрагмент лучше, чем div?",
    "answer":"Фрагмент - это распространенный паттерн в React , который используется в компонентах, возвращающих несколько элементов.\nФрагмент позволяет группировать дочерние элементы без создания лишних DOM-узлов. Другими словами, это специальный тэг jsx, который не отрисовывается внутри реального DOM-дерева.\nИспользование фрагмента вместо пустого оборачивающего элемента, наподобие div, лучше по нескольким причинам:\n\t1.фрагменты немного быстрее и используют меньше памяти. Реальная польза от этого ощущается в очень больших и глубоких деревьях элементов;\n\t2.некоторые механизмы css, например, flexbox и grid используют связь родитель-ребенок, поэтому добавление дополнительных div может сломать макет страницы;\n\t3.удобнее пользоваться инспектором DOM, так как обрачивающий фрагмент никак не отображается.",
    "codeexample":"// Old syntax\nreturn (\n\t<Fragment>\n\t\t<ChildA />\n\t\t<ChildB />\n\t\t<ChildC />\n\t</Fragment>\n);\n\n// New syntax\nreturn (\n\t<>\n\t\t<ChildA />\n\t\t<ChildB />\n\t\t<ChildC />\n\t</>\n);",
    "images":[]
  },
  "r17":{
    "id":"08f36e317",
    "theme":"r",
    "question":"Что такое React-ссылка (ref)? Как создать ссылку?",
    "answer":"Ссылки или ref используются для получения ссылки на узел DOM-дерево или экземпляр компонента в React.\nRef возвращает ссылку на элемент, можно сказать, что это аналог метода getElementById.\nВ самой документации  React говорится о том, что в большинстве случаев использование ссылок следует избегать, так как структура компонентов, их вложенность и передача данных между ними должны быть максимально простыми для понимания. Для того, чтобы создать ссылки существует 2 варианта:\n1.использование хука useRef;\n2.применение метода createRef.",
    "codeexample":"",
    "images":[]
  },
  "r18":{
    "id":"08f36e318",
    "theme":"r",
    "question":"Разница между теневым (Shadow) и виртуальным (Virtual) DOM?",
    "answer":"Для начала следует отметить, что оба варианта решают одну и ту же проблему - это оптимизация перформанса или скорость загрузки страницы, а также оба создают отдельный instance реального DOM-дерева.  Помимо этого оба концепции абсолютно различны.\n\nVirtual DOM - создает копию всего объекта DOM, а Shadow DOM создает небольшие части объекта DOM, имеющая собственную изолированную область действия для элемента, который они представляют. \n\nShadow DOM - это браузерная технология, спроектированная для ограничения области видимости переменных и css веб-компонентов. В то время как Virtual DOM - это концепция, реализуемая некоторыми библиотеками js, поверх браузерных API и по сути это представление реального DOM-дерева, хранимая в оперативной памяти.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/bqp1ymek6b6lypqsxa2ta/333333.webp?rlkey=al7bo9j05xq7e7btij1ebgwvt&st=cqgi4bu2&dl=1","https://www.dropbox.com/scl/fi/8jsm0vc7t2yqo6wa19xbf/1_-Zc9vWOG-JYhEfcG3cCrWw.webp?rlkey=ppyzzn9i75h5oz1xqckg5hfxn&st=w9ybq2vg&dl=1"]
  },
  "r19":{
    "id":"08f36e319",
    "theme":"r",
    "question":"Назовите преимущества использования React?",
    "answer":"1.повышение производительности благодаря Virtual DOM;\n2.JSX облегчает написание и чтение кода;\n3.возможность рендеринга на стороне клиента или сервера;\n4.простая интеграция с фреймворками, поскольку React - это всего лишь библиотека;\n5.возможность быстрого unit и интеграционного тестирования, с помощью таких инструментов как Jest или React Testing Library;\n6.декларативность;\n7.универсальность;\n8.компонентный подход;\n9.небольшой порог вхождения;\n10.огромное комьюнити и куча библиотек уже с готовой реализацией решений.",
    "codeexample":"",
    "images":[]
  },
  "r20":{
    "id":"08f36e320",
    "theme":"r",
    "question":"Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?",
    "answer":"Условный рендеринг или Conditional Rendering - это возможность отрисовки элементов разметки или компонентов на основании входного условия. Другими словами - это своеобразная if…else условие, которое помогает отрендерить варианты интерфейса. Указывается условный рендеринг внутри метода render и из-за того, что JSX не поддерживает конструкцию if…elsе выполнить его можно 2 доступными вариантами:1.Использование &&;2.Применение тернарного оператора.",
    "codeexample":"const Component = ({ name, address }) => (\n\t<>\n\t\t<h2>{name}</h2>\n\t\t{address && <p>{address}</p>}\n\t</>\n);\n\nconst Component = ({ name, address }) => (\n\t<>\n\t\t<h2>{name}</h2>\n\t\t{address\n\t\t\t? <p> {address}</p>\n\t\t\t: <p>{'Address is not available'}</p>\n\t\t}\n\t</>\n);",
    "images":[]
  },
  "r21":{
    "id":"08f36e321",
    "theme":"r",
    "question":"Что такое компонент-переключатель (Switching Component)?",
    "answer":"Компонент-переключатель или Switching Component - это компонент, который рендерит один из нескольких компонентов. Это своеобразный реакт-паттерн, который позволяет реализовать удобный механизм отрисовки нескольких компонентов на основании какого-нибудь условия.\nОсновная идея - это структура в виде объекта, которая содержит ключи и соответствующие им компоненты. Получая пропсы компонент-переключатель вытягивает из них значение ключа, после чего по этому значению возвращает нужный компонент, которому с помощью spread-оператора передаются все пропсы.",
    "codeexample":"",
    "images":[]
  },
  "r22":{
    "id":"08f36e322",
    "theme":"r",
    "question":"Разница между React и ReactDOM?",
    "answer":"Библиотека React содержит createElementComponent, children  и другие  вспомогательные функции, связанные с элементами и компонентами, по сути это изоморфные или универсальные элементы предназначенные именно  для создания компонентов.\nReactDOM- это пакет, предоставляющие специальные для браузера методы, которые могут быть использованы на верхнем уровне приложения для эффективного управления DOM-элементами, имеющимися на странице. Он  содержит такие методы как render, findDOMMode, createPortal и т.д.\nИзначально две эти библиотеки были вместе, однако, для обеспечения рендеринга в разных средах команда React разделила основной пакет React  с версии 0.14 на две независимые части React и ReactDOM. Теперь это позволяет создавать компоненты, которые могут использоваться как в веб, так и в мобильных версия приложения.",
    "codeexample":"",
    "images":[]
  },
  "r23":{
    "id":"08f36e323",
    "theme":"r",
    "question":"Разница между компонентом и контейнером?",
    "answer":"Component - это классовый или функциональный компонент, описывающий визуальное представление приложения.\nКонтейнер - это неофициальный термин для описания компонента, подключенного к хранилищу Redux. Контейнеры подписываются на обновление состояния Redux и диспатчат операции. По сути они являются посредниками и отвечают за взаимодействие хранилища  и компонентов отвечающих за отрисовку интерфейса. Поэтому в большинстве своем они не рендерят DOM-элементы, а делегируют рендеринг дочерним компонентам, задача которых визуализация данных.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/y49ocpyp4q10xpu661cmj/8DCRV-rWS.webp?rlkey=cq1wvavt8w6o543lxzzrxpn6g&st=c48pztwp&dl=1"]
  },
  "r24":{
    "id":"08f36e324",
    "theme":"r",
    "question":"Как React обрабатывает, или ограничивает использование пропсов определенного типа?",
    "answer":"PropTypes - это один из вариантов перехвата ошибок с неправильными типами пропсов. С помощью ключевого слова isRequered он позволяет помечать пропсы как обязательные, а компонент с помощью defaultProps определяет их значение по умолчанию.\nPropTypes - определяет тип пропса, каждый раз когда через пропс передается какое-либо значение он проверяется на правильный тип, если будет обнаружен неправильный тип, то в консоль будет выведено сообщение об ошибке. Это позволяет гарантировать, что компоненты получают пропсы с верными типами. Аналогами проверки типов React можно назвать Flow или TypeScript.",
    "codeexample":"import React from 'react';\nimport PropTypes from 'prop-types';\n\nexport const Person = ({ firstName, lastName, country }) => (\n\t<>\n\t\t<h2>{firstName} {lastName}</h2>\n\t\t{country && <p>Country: {country}</p>}\n\t</>\n);\n\nPerson.propTypes = {\n\tfirstName: PropTypes.string.isRequered,\n\tlastName: PropTypes.string.isRequered,\n\tcountry: PropTypes.string,\n};\n\nPerson.defaultProps = {\n\tcountry:'',\n};",
    "images":[]
  },
  "r25":{
    "id":"08f36e325",
    "theme":"r",
    "question":"Что такое строгий режим в React? Его преимущества?",
    "answer":"StrictMode - это инструмент для определения потенциальных проблем приложения. Как и фрагмент StrictMode ничего не рендерит. Он активирует дополнительные проверки и предупреждения для дочерних компонентов. Проверки выполняются только в Developer Mode или в режиме разработки. Также они не влияют на продакшн-сборку.\nВ примере проверки не выполняются для компонентов Header и Footer, ComponentOne и ComponentTwo, которые являются потомками StrictMode  будут проверены.\nК преимуществам строго режима можно отнести:\n\t1.Предупреждении об использовании устаревшего API строковых ссылок (String Ref);\n\t2.Предупреждение об использовании устаревшего метода findDOMMode;\n\t3.Определение компонентов с небезопасными методами жизненного цикла;\n\t4.Определение неожиданных побочных эффектов;\n\t5.Определение использования устаревшего API-контекста.",
    "codeexample":"\nimport React from 'react';\n\nexport const Component = () => (\n\t<>\n\t\t<Header />\n\t\t<React.StrictMode>\n\t\t\t<>\n\t\t\t\t<ComponentOne />\n\t\t\t\t<ComponentTwo />\n\t\t\t</>\n\t\t</React.StrictMode>\n\t\t<Footer />\n\t</>\n);",
    "images":[]
  },
  "r26":{
    "id":"08f36e326",
    "theme":"r",
    "question":"Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?",
    "answer":"В  React пропсы передаются в одном направлении сверху-вниз от родительского компонента к дочернему. При наличии незначительного количества пропсов или потомков это не является проблемой.\nПри росте приложения для того, чтобы передать пропсы с верхнего уровня приложения в компоненты, находящиеся, например, на третьем или четвертом уровне вложенности, приходится передавать одни и те же пропсы  на каждом уровне дерево-компонентов.  Также ситуация может усугубиться тем, что пробрасывать нужно сразу несколько свойств. Таким образом, количество пропсов у компонентов верхнего уровня может быть огромное количество. Данный механизм или  антипаттерт, называется Prop Drilling.\nДля того, чтобы его избежать существует два подхода:\nИспользование Redux Store или любого другого state-менеджера;\nВоспользоваться Context и хуком useContext.",
    "codeexample":"// Props drilling:\nconst Component = () => (\n<LevelOne title=\"simple title\" />\n);\n\nconst LevelThree = ({ title }) => <h1>{title}</h1>;\nconst LevelTwo = ({ title }) => <LevelThree title={title} />;\nconst LevelOne = ({ title }) => <LevelTwo title={title} />;\n\n// Using hook & context:\n// (1) File context.js\nexport const titleContext = React.createContext('simple title');\n\n// (2) File Level Three.js\nimport { titleContext } from './context';\nimport React, { useContext } from 'react';\n\nexport const LevelThree = () => {\n\tconst title = useContext(titleContext);\n\treturn <h1>{title}</h1>;\n};",
    "images":[]
  },
  "r27":{
    "id":"08f36e327",
    "theme":"r",
    "question":"Что такое «опрос» (Polling)? Как его реализовать в React?",
    "answer":"Механизм  Polling или «опрос» - это распространенный подход редопдля регулярных асинхронных запросов.\nПредположим, у нас есть компонент и сервер, у которого мы должны запрашивать данные. Чтобы не блокировать работу пользователя с компонентом или приложением асинхронные запросы могут идти либо отложено, либо в фоновом режиме. Таким образом, можно наладить опрос сервисов через определенные промежутки времени. В React такой механизм реализуется с помощью метода setInterval и хука useEffect. При первом рендеринге компонента запускается таймер, который каждую секунду делает запрос на сервер. Также чтобы этот таймер остановить при размонтировании компонента из useEffect возвращается метод clearInterval. Дополнительно такой же можно добавить  и условие получения данных это поможет остановить таймер запросов еще до размонтирования компонента при выполнении какого-то определенного условия.",
    "codeexample":"import React, { useState, useEffect } from 'react'\n\nconst IntervalExample = () => {\n\tconst [data, setData] = useState(null);\n\n\tconst getItems = () => {\n\t\tfetch('api-url')\n\t\t\t.then(result => result.json())\n\t\t\t.then(result => setData(result));\n\t};\n\tuseEffect(() => {\n\t\tconst interval = setInterval(() => getItems(), 1000);\n\t\treturn () => clear Interval(interval);\n\t}, []);\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Component data={data} />\n\t\t</div>\n\t);\n};",
    "images":[]
  },
  "r28":{
    "id":"08f36e328",
    "theme":"r",
    "question":"Разница между элементом и компонентом?",
    "answer":"Компонент - это шаблон, проект или схема. Он может быть функцией или классом с методами жизненного цикла или хуками.\nЭлемент - это то, что возвращается из компонента, это объект описывающий виртуальное представление  определенного DOM-узла, содержащегося в компоненте.\nВ случае с функциональными компонентами указанный объект возвращается функцией, в классовых компонентах объект возвращается методом render. Элементы React - это не то, что отображается в браузере, это всего лишь объекты хранящиеся в памяти , которые напрямую невозможно изменять.\nЭлемент - это обычный JS объект с определенными методами. Он имеет 4 свойства:\n\t- type - строковое представление HTML тэга или ссылка на Rect компонент;\n\t- key - строка-идентификатор React элемента;\n\t- ref - ссылка на узел DOM или экземпляр компонента React;\n\t- props - объект со свойствами.\nЭлемент, описывающий компонент не знает в каком DOM-узле произойдет render. Эта связь абстрагирована и определяется в процессе рендера.\nКомпоненты - строительные блоки приложения. Они могут иметь состояние или получать данные с помощью пропсов, а также им доступны методы жизненного цикла. Если компонент функциональный, то он может воспользоваться хуками и он обязательно должен иметь метод render, возвращающий элемент React или дерево элементов.",
    "codeexample":"",
    "images":[]
  },
  "r29":{
    "id":"08f36e329",
    "theme":"r",
    "question":"Что такое ReactDOMServer?",
    "answer":"Объект  ReactDOMServer позволяет рендерить компоненты в виде статической разметки. Обычно данные объекты используется на Node-серверах.  Рендеринг на стороне сервера или Server Side Rendering (SSR)  - это техника позволяющая клиентские одностраничные приложения на сервере и отправлять их клиенту в виде готовой разметки. Это делает динамические компоненты статичными.\nПлюсы данного подхода:\n\t - повышение скорости рендеринга страниц, что улучшает UIX,\n\t - улучшает поисковую оптимизацию или SEO, облегчая индексацию страниц поисковыми роботами;\n\t - повышает доступность метаданных (изображения, заголовки, описания и т.д.), что позволяет пользователям легко делиться контентом приложения.",
    "codeexample":"",
    "images":[]
  },
  "r30":{
    "id":"08f36e330",
    "theme":"r",
    "question":"Что такое предохранители (Error Boundaries)?",
    "answer":"Error Boundaries или предохранители - это React компоненты, которые перехватывают любые ошибки, возникающие в дереве потомков. После чего выводит сообщение об ошибке в консоль или отображает резервный UI вместо сломанного.\nПредохранители перехватывают ошибки во время render, в методах жизненного цикла и в конструкторах  любых дочерних компонентов. Классовый компонент становится предохранителем когда в нем определяются методы жизненного цикла getDerivedStateFromError или componentDidCatch, хоть оба метода служат для обработки ошибок, задачи, которые они выполняют, немного отличаются.\ngetDerivedStateFromError  используется для рендеринга запасного UI после возникновения ошибки, а componentDidCatch используется для вывода сообщения об ошибке в консоль.\nПредохранители не перехватывают ошибки в следующих случаях:\n\t - обработчиках событий;\n\t - асинхронном коде;\n\t - при серверном рендеринге;\n\t - при выбрасывании исключения в самом предохранителе.",
    "codeexample":"import React, { Component } from 'react';\n\nclass CatchError extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = { hasError: false };\n\t}\n\n\tstatic getDerivedStateFromError(error) {\n\t\t// if something happens this will update state so the next render will show our fallback UI.\n\t\treturn { hasError: true };\n\t}\n\trender() {\n\t\tconst { hasError } = this.state;\n\t\tconst { children } = this.props;\n\t\tif (hasError) {\n\t\t\t// render anything you want for fallback UI.\n\t\t\treturn <h1>Something went wrong.</h1>;\n\t\t}\n\t\treturn children;\n\t}\n};",
    "images":[]
  },
  "r31":{
    "id":"08f36e331",
    "theme":"r",
    "question":"Что такое «ленивая» (Lazy) функция?",
    "answer":"Это метод из нового API React Sespends.\nReact Lazy или ленивая функция - это функция, которая позволяет создавать компоненты, загружаемые с помощью динамического импорта, которые рендерятся как обычные компоненты . Это позволяет уменьшить размеры bundle, поскольку загружается только те компоненты, которые реально отрисовываются на UI в текущий момент.\nReact Lazy в качестве аргумента принимает функцию. Эта функция возвращает промис в результате вызова импорта для загрузки компонента.",
    "codeexample":"import { lazy } from 'react';\n\nconst MyComponent = lazy (() => import('./MyComponent'));\n\nconst App = () => {\n\t>\n\t\tMyComponent />\n\t/>\n};",
    "images":[]
  },
  "r32":{
    "id":"08f36e332",
    "theme":"r",
    "question":"Разница между рендерингом и монтированием?",
    "answer":"Рендеринг - это функция или метод render, вызываемый компонентом и возвращающий инструкции для создания DOM. Метод render вызывается при каждом рендеринге компонента. Обновление компонента происходит при изменении его состояния или пропсов.\nМонтирование - это первый рендеринг компонента и построение первоначальной объектной модели документа. Монтирование компонента означает встраивание создаваемых им элементов в браузерный DOM. Повторный рендеринг - это повторный вызов функции для получения информации об уже смонтированном компоненте.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/9vv5m6t37j6wfx1xu4b71/bCoYZgIDd.webp?rlkey=4478pfub9liwic2gk7xbvlpvj&st=8a8kb02r&dl=1"]
  },
  "r33":{
    "id":"08f36e333",
    "theme":"r",
    "question":"Что такое сhildren?",
    "answer":"Children или потомки (дети) - это prop, позволяющие передавать одни компоненты другим, как и любые другие пропсы. Дерево компонентов, размещаемые между открывающим и закрывающим тегами передаются компоненту в качестве пропса children. Children ссылается на контейнер, содержимое которого неизвестно до передачи данных из родительского компонента.\nОтличительной особенностью children является то, что React предоставляет его поддержку через React Element API и JSX, а также для работы с этим типов пропсов в  React API существуют такие методы как: childrenMap(), childrenForEach(), childrenCount(), childrenOnly() и childrenToArray().",
    "codeexample":"const Picture = ({ src, children }) => (\n\t<>\n\t\t<img src={src} />\n\t\t{children}\n\t</>\n);\n\n// App.js\nreturn (\n\t<div className=\"container\">\n\t\t<Picture key={picture.id} src={picture.src}>\n\t\t\t// Here go components, passed as a 'props.children'\n\t\t</Picture>\n\t</div>\n);",
    "images":[]
  },
  "r34":{
    "id":"08f36e334",
    "theme":"r",
    "question":"Что такое события указателя (Pointer Events)?",
    "answer":"Pointer Events предоставляет унифицированный способ обработки всех событий ввода. События указателя похожи на события мыши mousedown, mouseup и т.д., однако, не зависит от устройства, так что это может быть мышь, стилус или даже прикосновение. Это позволяет избежать реализации функционала для каждого устройства.\nРассматриваемый API работает также, как и существующие обработчики событий. События указателя добавляются к React компонентам в качестве атрибутов с коллбэками, принимающими события. Внутри callback происходит обработка события.\nВ React DOM доступны следующие типы события указателя: onpointerdown, onpointermove, onpointerup, onpointercancel и т.д. Полный список представлен на картине.\nВажно помнить, что эти события работают только в тех браузерах, которые поддерживают Pointer Events.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/4hpp37t65mtkz0ag4k48o/161865638-29436950-cf63-45bd-bd6c-2ac56f4f37c0.webp?rlkey=5mapno6aqjlimw44l2ro9ufgk&st=7e1fc9zw&dl=1"]
  },
  "r35":{
    "id":"08f36e335",
    "theme":"r",
    "question":"Что такое инверсия наследования (Inheritance Inversion)?",
    "answer":"Инверсия наследования - это hook или компонент высшего порядка. В нем возвращается класс, расширяющий WrapperComponent. Данная техника называется инверсией наследования, поскольку вместо расширения некоторого класса-усилителя с помощью WrapperComponent, последний сам пассивно расширяется. Отношения между ними напоминает инверсию.\nИнверсия наследования предоставляет hook доступ к экземпляру WrapperComponent, а это означает что можно использовать state, props, методы жизненного цикла и даже render данного компонента.\nСуществует два случая когда hook можно использовать:\n\t - перехват рендеринга;\n\t - управление состоянием.",
    "codeexample":"const inheritanceInversionHOC = (WrappedComponent) => {\n\treturn class extens WrappedComponent {\n\t\trender() {\n\t\t\treturn super.render()\n\t\t}\n\t}\n}",
    "images":[]
  },
  "r36":{
    "id":"08f36e336",
    "theme":"r",
    "question":"Как в React реализовать двустороннее связывание данных?",
    "answer":"Двустороннее связывание данных означает следующее: данные, которые изменяются в представлении обновляют состояние, данные в состоянии обновляют представление. Компоненты или даже элементы, в которых реализована такая связь называются управляемыми. Выполнить такую связку можно с помощью setState в классовом компоненте, или хука useState в функциональном, а также обработчика, который добавляется, например, на input-элемент. Таким образом, данные вводимые на UI попадают в state и обновляют его, а обновление state  в свою очередь вызывает обновление на UI.",
    "codeexample":"import React, { useState } \"react\";\n\nexport const App = () => {\n\tconst [name, setName] = useState('');\n\n\tconst handleChange({ target }) => {\n\t\tsetName (target.value);\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t<input onChange={handleChange} value={name} />\n\t\t\t<h1>{name}</h1>\n\t\t</>\n\t)\n};",
    "images":["https://www.dropbox.com/scl/fi/01uj6qn8elnz97cdhy78c/react_triggers.webp?rlkey=ok2xg54m7g2h6su1gbfpx6h4a&st=bend105y&dl=1"]
  },
  "r37":{
    "id":"08f36e337",
    "theme":"r",
    "question":"Разница между классовым и функциональным компонентами?",
    "answer":"В современном React используются компоненты как основные строительные блоки при создании гибких и отзывчивых веб-интерфейсов или можно сказать страниц веб-браузеров. Сами компоненты разделяются на два типа: классовые и функциональные.\nВ настоящее время классовые компоненты используется реже функциональных. Классовые компоненты используется когда необходимо отследить состояние. Использование функционального компонента является более простым и распространенным вариантом в приложениях на React.\n\t1.В классовых компонентах обязательно присутствует код с обращением к методу render, который возвращает готовый код на HTML.\n\t2.В функциональных компонентах метод рендеринга не используется, а вместо него такой компонент как функция либо напрямую возвращается код HTML, либо не возвращает ничего.\n\t3.Классовые компоненты содержат информацию о текущих состояниях его элементов, а функциональные компоненты не хранят информацию о состоянии.\n\t4.Классовые компоненты по умолчанию содержат методы жизненного цикла, поэтому для классовых компонентов есть возможность управления данными внутри  компонента на различных этапах его существования. В функциональных компонентах жизненные циклы отсутствуют, тем не менее начиная с версии React 16.8 для функциональных компонентов были добавлены захваты или хуки, которые расширяют возможности функциональных компонентов и с помощью хуков можно можно управлять состоянием.\n\t5.Использование функционального компонента облегчает реализацию композиционного подхода и такой подход считается лучше практикой, позволяет более гибко настраивать приложения, а также писать большие приложения, теряя меньше времени на его отладку.",
    "codeexample":"",
    "images":[]
  },
  "r68":{
    "id":"08f36e400",
    "theme":"r",
    "question":"Разница между useEffect() и componentDidMount()?",
    "answer":"\tcomponentDidMount() используется в классовых компонентах и выполняется один раз после первого рендера.\n\tuseEffect() используется в функциональных компонентах, выполняется после каждого рендера, но его можно настроить так, чтобы он выполнялся один раз, аналогично componentDidMount() (поставив вторым аргументом пустой массив []). Он также поддерживает зависимости, что делает его более гибким для управления побочными эффектами.",
    "codeexample":"",
    "images":[]
  },
  "r38":{
    "id":"08f36e338",
    "theme":"r",
    "question":"Преимущества хуков?",
    "answer":"\t1.С ними легче работать и легче тестировать как отдельные функции компонентов.\n\t2.Хуки делают код чище, улучшают читаемость, так как сложна логика может быть вынесен в кастомный хух.\n\t3.Позволяет разделять сложную логику на маленькие функции, используемые внутри  компонентов.\n\t4.Повышает уровень переиспользуемости кода.\n\t5.Позволяет распределять логику между компонентами через пользовательские хуки.\n\t6.Являются более податливыми перемещениям в дереве компонентов.\n\t7.Благодаря переиспользованию отдельных кусков логики нет необходимости использовать хоки, которые зачастую только усложняют понимание работы компонента.",
    "codeexample":"",
    "images":[]
  },
  "r69":{
    "id":"08f36e401",
    "theme":"r",
    "question":"Недостатки хуков?",
    "answer":"Хуки позволяют использовать Реакт без классовых компонентов. Но у них есть несколько минусов:\n\t- Ограничения их использования: хуки нельзя вызывать внутри условий, циклов или вложенных функций. Они должны вызываться только на верхнем уровне функциональных компонентов или других хуков;\n\t- Хуки не предоставляют прямого аналога для всех методов жизненного цикла классовых компонентов. Например, нет хуков для getSnapshotBeforeUpdate и componentDidCatch, которые используются для работы с ошибками и снимками состояния компонента перед обновлением;\n\t- Есть хуки, которые должны оптимизировать работу реакт-компонента (напр., useMemo useCallback), однако их неправильное использование может наоборот привести к замедлению.\n\t- Если хуки неправильно используются, например, если сложные вычисления производятся внутри хука без учета оптимизации, это может привести к проблемам с производительностью;\n\t- Неоптимизированные ререндеры: Неправильное управление состоянием в хуках, таких как useState, может привести к ненужным ререндерам компонентов.",
    "codeexample":"",
    "images":[]
  },
  "r39":{
    "id":"08f36e339",
    "theme":"r",
    "question":"Правила (ограничения) использования хуков?",
    "answer":"\n1.Выполнять хуки следует в самом верху иерархии функции;\n2.Вызывать хуки можно только в функциях или функциональных компонентах, либо пользовательских хуках.",
    "codeexample":"",
    "images":[]
  },
  "r40":{
    "id":"08f36e340",
    "theme":"r",
    "question":"Что такое поднятие состояния вверх (Lifting State Up)?",
    "answer":"Поднятие состояния вверх (англ. Lifting State Up) — это паттерн в React, который предполагает перемещение состояния из дочерних компонентов в их ближайший общий родительский компонент. Этот подход используется, когда несколько компонентов нуждаются в доступе к одному и тому же фрагменту данных или должны реагировать на его изменения. Подняв состояние вверх, вы обеспечиваете единое место хранения и управления данными, что способствует более предсказуемому и управляемому поведению приложения.",
    "codeexample":"",
    "images":[]
  },
  "r41":{
    "id":"08f36e341",
    "theme":"r",
    "question":"Что делает метод shouldComponentUpdate?",
    "answer":"Метод shouldComponentUpdate — это один из методов жизненного цикла классового компонента в React. Он используется для оптимизации производительности, позволяя контролировать, будет ли компонент перерендерен при обновлении состояния или пропсов.\nОсновные особенности:\n\tВозвращаемое значение:\n\t\tМетод должен вернуть true или false.\n\t\tЕсли возвращается true, компонент перерендерится.\n\t\tЕсли возвращается false, компонент не будет перерендерен.\n\tАргументы:\n\t\tnextProps: объект с новыми значениями пропсов, которые компонент получит.\n\t\tnextState: объект с новым состоянием компонента.\nВ функциональных компонентах аналогичную функцию выполняет React.memo(), который предотвращает перерендеринг, если пропсы не изменились.",
    "codeexample":"",
    "images":[]
  },
  "r42":{
    "id":"08f36e342",
    "theme":"r",
    "question":"Разница между createElement() и cloneElement()?",
    "answer":"React.createElement():\n\nЭто функция, которая создает и возвращает новый React-элемент заданного типа. Она принимает три аргумента:\n\tТип элемента (строка для HTML-элемента или компонент).\n\tПропсы (объект с атрибутами и значениями).\n\tДочерние элементы (могут быть переданы как одно значение или как массив).\nЭтот метод является базовым для создания элементов в React, хотя чаще он используется за кулисами, когда JSX синтаксис компилируется в вызовы createElement().\n\nReact.cloneElement():\n\nЭта функция возвращает клон указанного React-элемента. Она может принимать дополнительные пропсы и/или дочерние элементы, которые будут объединены с теми, что уже есть у клонируемого элемента. Полезна, когда нужно создать модифицированную копию элемента (например, передать дополнительные пропсы или переопределить существующие). Клонирует элемент вместе с его типом, ключом, рефами и дочерними элементами, но при этом позволяет изменять или добавлять новые пропсы.\n\nТаким образом, React.createElement() используется для создания новых React-элементов, а React.cloneElement() — для создания модифицированных копий существующих элементов.",
    "codeexample":"",
    "images":[]
  },
  "r43":{
    "id":"08f36e343",
    "theme":"r",
    "question":"Что такое useReducer()?",
    "answer":"Это хук, принимающий функцию reduser и начальное состояние приложения в качестве аргументов и возвращающий текущее состояние и диспетчер для отправки операций. Этот хук - примитив, который может использоваться во всех случаях использования useState,  т.к. useState реализован с помощью useReduser. Хук можно использовать столько раз, сколько это требуется.\nПринцип работы useReduser: определяется начальное состояние и reduser, которые передаются в хук useReduser, хук возвращает текущее значение состояния и диспетчер, который используется для обновления состояния.\nВ примере: когда пользователь нажимает на кнопку, происходит отправка операции в редьюсер, который обновляет счетчик на основе операции.",
    "codeexample":"import React, { useReducer } from 'react';\n\n// Store\nconst initialState = { count: 0 };\n\n// Reducer\nconst reducer = ({ count }, { type }) => {\n\tswitch (type) {\n\t\tcase 'increment': return { count: count + 1 };\n\t\tcase 'decrement': return { count: count - 1 };\n\t\tdefault: return {};\n\t}\n};\n\nconst Counter = () => {\n\tconst [state, dispatch] = useReducer (reducer, initialState);\n\n\treturn(\n\t\t<>\n\t\t\t<div>{state.count}</div>\n\t\t\t{/* Actions */}\n\t\t\t<button onClick={() => dispatch({type: 'increment' })}>+1</button>\n\t\t\t<button onClick={() => dispatch({type: 'decrement'})}>-1</button>\n\t\t</>\n\t);\n};",
    "images":[]
  },
  "r44":{
    "id":"08f36e344",
    "theme":"r",
    "question":"Как реализовать однократное выполнение операции при начальном рендеринге?",
    "answer":"При работе с классовым компонентом: использовать метод жизненного цикла componentDidMount любые операции определённые в этом методе будут выполнены только 1 раз при монтировании компонента.\nДля функционального компонента: с помощью хука useEffect с пустым массивом зависимостей. Хук принимает 2 параметра: функция обратного вызова, которая должна выполниться и массив зависимостей (содержащий отслеживаемые переменные). Если массив пустой, то функция выполнится только один раз, что будет эквивалентно методу componentDidMount, но использование хуков в функциональных компонентах является более гибким и современным.",
    "codeexample":"// componentDidMount\nclass App extends Component {\n\tcomponentDidMount() {\n\t\ttrackPageView('Homepage');\n\t}\n\n\trender() {\n\t\treturn <h1>Hello world</h1>\n\t}\n}\n\n// useEffect\nconst App = () => {\n\tuseEffect(() => {\n\t\ttrackPageView('Homepage');\n\t}, []);\n\n\treturn <h1>Hello world</h1>\n}",
    "images":[]
  },
  "r45":{
    "id":"08f36e345",
    "theme":"r",
    "question":"Что такое распределенный компонент?",
    "answer":"Это разновидность компонента, который управляет своим внутренним состоянием, а логику рендеринга делегирует другому компоненту, т.е. место определения компонента отделяется от места его реализации, что позволяет защитить специфическую логику от остального приложения, предоставляя чистый и выразительный API для использования его компонентом. Они конструируются таким образом, чтобы оперировать набором данных, которые передаются через дочерние компоненты вместо пропсов. “Под капотом” используется низкоуровневый API, такой как React Children Map и React cloneElement. В примере ниже компонент menu содержит совместное состояние, а вложенные компоненты имеют доступ к этому состоянию, в результате все манипуляции осуществляются в явном виде.",
    "codeexample":"const Menu = () => (\n\t<Menu>\n\t\t<MenuButton>\n\t\t\tOperation <span aria-hidden></span>\n\t\t</MenuButton>\n\t\t<MenuList>\n\t\t\t<MenuItem onSelect={() => alert('Download')}>Download</MenuItem>\n\t\t\t<MenuItem onSelect={() => alert('Copy')}>Copy</MenuItem>\n\t\t\t<MenuItem onSelect={() => alert('Delete')}>Delete</MenuItem>\n\t\t</MenuList>\n\t</Menu>\n);",
    "images":[]
  },
  "r46":{
    "id":"08f36e346",
    "theme":"r",
    "question":"Расскажите о хуках useCallback(), useMemo(), useImperativeHandle(), useLayoutEffect()?",
    "answer":"useCallBack() - используют для оптимизации рендеринга функциональных компонентов, возвращает мемоизированную версию коллбэка, такой коллбек обновляется только при изменении его зависимостей, что может быть полезным при передаче коллбеков оптимизированным дочерним компонентам.\nuseMemo() - используется для оптимизации вычислений, производимых в функциональных компонентах. Похож на useCallBack() за исключением того, что принимает любые значения, а не только функции. Обычно он принимает функцию, возвращающую значение и массив зависимостей. Значение, возвращаемое функцией вычисляется повторно только при изменении зависимостей.\nuseImperativeHandle() - позволяет кастомизировать значение, передаваемое родительскому компоненту с помощью ref. Императивный код, в котором используются ссылки является плохой практикой, этот хук должен использоваться совместно с forwardRef.\nuseLayoutEffect() - запускается после всех манипуляций с DOM но до его отрисовки браузером. Полезен для получения дополнительной информации из DOM (величина прокрутки или стили элемента) и использование этой информации для корректировки DOM или запуска повторного рендеринга путём обновления состояния. Выполняет те же задачи, которые выполняет ComponentDidMount и ComponentDidUpdate.",
    "codeexample":"",
    "images":[]
  },
  "r47":{
    "id":"08f36e343",
    "theme":"r",
    "question":"Как отрендерить HTML код в React-компоненте?",
    "answer":"Использование InnerHTML в React. Если при запросе на сервер вернулась разметка, которую нужно отрисовать внутри компонента, в React используют атрибут dangerouslySetInnerHTML, который по сути является альтернативой стандартного InnerHTML. Использование этих атрибутов представляет собой угрозу межсайтового скриптинга или XSS. Атрибут принимает два значения: объект с ключом HTML и HTML разметкой в качестве значения, после чего разметка рендерится на страницею",
    "codeexample":"const createMarkup = () => ({ __html: 'First &middot; Second' });\n\nconst MyComponent = () =>\n<div dangerouslySetInnerHTML={createMarkup()} />;",
    "images":[]
  },
  "r48":{
    "id":"08f36e343",
    "theme":"r",
    "question":"Зачем в setState() нужно передавать функцию?",
    "answer":"setState - это асинхронная операция. Т.к. реакт откладывает обновление состояния по причинам производительности, состояние может обновиться не сразу после вызова setState и нельзя с уверенностью сказать какое текущее состояние. Для решение проблемы обновления текущего состояния, в setState передаётся функция с предыдущим состоянием в качестве аргумента.",
    "codeexample":"// his.state.count === 0\nthis.setState({ count: this.state.count + 1 });\nthis.setState({ count: this.state.count + 1 });\nthis.setState({ count: this.state.count + 1 });\n// this.state.count === 1\n\nthis.setState((prevState, props) => ({\n\tcount: prevState.count + props.increment, 9 }));\n// this.state.count === 3",
    "images":[]
  },
  "r49":{
    "id":"08f36e349",
    "theme":"r",
    "question":"Для чего предназначен метод registerServiceWorker() в React? ",
    "answer":"Это web API позволяющий записывать файлы приложения в кеш и возвращать их из него при отсутствии подключения к сети или медленном соединении, что очень сильно улучшает пользовательский опыт. По умолчанию интегрирован в createReactApp",
    "codeexample":"",
    "images":[]
  },
  "r50":{
    "id":"08f36e350",
    "theme":"r",
    "question":"Чем React Router отличается от обычной маршрутизации?",
    "answer":"При взаимодействии пользователя с приложением, роутер возвращает компоненты внутри единственного HTML файла index.html при этом он обращается к history каждого компонента и при наличии изменений в истории компонент перерисовывается. Начиная с React Router версии 4 history не нужно вводить в ручную, большая часть работы, связанная с маршрутизацией выполняется автоматически на стороне клиента с помощью компонента browserRouter",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/5bgv0ihkrlm6xmz1zbtg8/react-routing-dbcc202381ba5277686dd7f970529994.webp?rlkey=ghpgl9wyuxzi9he6gdyieesab&st=uw9cb5lb&dl=1"]
  },
  "r51":{
    "id":"08f36e351",
    "theme":"r",
    "question":"Какие хуки были добавлены в React Router версии 5?",
    "answer":"useHistory - предоставляет доступ к пропсу history в ReactRouter ссылается на зависимость history используемую роутером. Основное назначение  - программный роутинг.\n\nuseLocation - предоставляет доступ к пропсу location похож на windowLocation, но доступен в любом месте, т.к. является представлением состояния и локации роутера. Основное назначение в доступе к параметрам строки запроса или query Params и полному адресу.\n\nuseParams - предоставляет доступ к параметрам поисковой строки в URL. Раньше это было возможно только с помощью match.params.\n\nuseRouteMatch - предоставляет доступ к объекту Match. Если используется без аргументов, возвращает ближайшее совпадение в компоненте или его предках. Основное назначение в построении вложенных маршрутов.",
    "codeexample":"// useHistory();\nconst history = useHistory();\nhistory.push('/profile');\n\n// useLocation();\nconst location = useLocation();\nconst currentPath = location.pathname;\nconst searchParams = new URLSearchParams (location.search);\n\n// useParams();\nconst {name} = useParams();\n\n// useRouteMatch();\nconst match = useRouteMatch();\n<Route path={`${match.url}/login`}></Route>;",
    "images":[]
  },
  "r52":{
    "id":"08f36e352",
    "theme":"r",
    "question":"Как передавать пропсы в React Router?",
    "answer":"Компонент Routr с пропсом render принимает функцию, возвращающую react элемент, после чего вызывает её вместо реализации собственной логики рендеринга. Данная техника используется для распределения кода между компонентами с помощью пропса, значением которого является функция. В реакт это называется RenderProps.",
    "codeexample":"import React from \"react\";\nimport { render } from \"react-dom\";\n\nconst RouterExample = () => (\n\t<Router>\n\t\t<Route exact path=\"/\" component={App} />\n\t\t<Route\n\t\t\tpath=\"/greeting/:name\"\n\t\t\t// Passing props\n\t\t\trender={(props) => <Greeting text=\"Hello, \" {...props}/>}\n\t\t/>\n\t</Router>\n);\n\nrender (<Router Example />, document.getElementById(\"root\"));",
    "images":[]
  },
  "r53":{
    "id":"08f36e353",
    "theme":"r",
    "question":"Что такое Reselect и как он работает?",
    "answer":"reselect- это простая библиотека для создания мемоизированных комбинируемых функций - селекторов. Селекторы используются для эффективного вычисления производных данных из redux хранилища, селекторы позволяют хранить минимально возможное состояние, а также селектор вычисляется повторно только при изменении его аргументов, при изменении не связанных с селектрором частей дерева компонентов, повторное вычисление селектора не осуществляется. Таким образом из redux store можно вытягивать данные из разных мест и комбинировать их специально для компонентов. Эти комбинированные данные мемоизируются и если ничего не изменилось, то не вызывают лишний перерендеринг компонента. ",
    "codeexample":"import { createSelector } from 'reselect';\n\nconst todoSelector= state => state.todo.todos;\nconst searchTermSelector = state => state.todo.searchTerm;\n\nexport const filteredTodos = createSelector(\n\t[todoSelector, searchTermSelector],\n\t(todos, searchTerm) =>\n\t\ttodos.filter(todo => todo.title.match(new RegExp(searchTerm, 'i')));\n);",
    "images":["https://www.dropbox.com/scl/fi/w6qyj9311mz7jshc52i7k/rdmzgqgrj_mjin5jjmsalnxmljm.webp?rlkey=8vh7p54cddd4npzd54ur9az5i&st=5q0s1hsr&dl=1"]
  },
  "r54":{
    "id":"08f36e354",
    "theme":"r",
    "question":"Какие типы данных может возвращать render?",
    "answer":"Обычно render возвращает какой-то блок разметки который описывается в компоненте, особенностью метода является то, что он может возвращать только один корневой элемент, а если элементов несколько, то они опять же, должны быть обёрнуты в одного родителя. Но рендер всё-таки способен возвращать не только разметку, полный список выглядит следующим образом: реакт элементы - элементы, которые дают возможность реакту отображать узел DOM, они включают в себя стандартные HTML элементы, такие как <div> например, а также пользовательские элементы: массивы и фрагменты; возврат нескольких элементов для отображения их в виде массивов, а также фрагментов для группировки нескольких элементов; порталы - рендеринг дочерних элементов в другое поддерево DOM; строка и число: рендеринг строк, чисел, как текстовых узлов в DOM; и в заключении - булево значение или null, на UI в этом случае ничего не отображается, но это типы используются для условного рендеринга содержимого.",
    "codeexample":"class HelloMessage extends React.Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\tHello {this.props.name}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nReactDOM.render(\n\t<HelloMessage name=\"Taylor\" />,\n\tmountNode\n);",
    "images":[]
  },
  "r55":{
    "id":"08f36e355",
    "theme":"r",
    "question":"Разница между memo и useMemo?",
    "answer":"memo - это компонент высшего порядка, он нужен для повышения производительности и подходит для случаев, когда компонент рендерит одинаковый результат при одних и тех же значениях пропсов. В этом случае результат будет мемоизирован, т.е. реакт будет использовать результат последнего рендера избегая повторного рендеринга. При использовании memo по умолчанию происходит поверхностное сравнение пропсов. Также, в качестве второго аргумента, если нужно контролировать сравнение, можно передать свою функцию сравнения, что касается useMemo, то это хук, который возвращает мемоизированное значение функции, которое делает долгое вычисление. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере и useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо и зависимости изменилось. Сами созависимости передаются вторым аргументом внуттри квадратных скобок.",
    "codeexample":"import React from 'react';\n\nexport default React.memo((props)=>{\n\tconsole.log(\" React Memo -- \", props.data)\n\treturn (<div>Render : {props.data}</div>)\n})\nfunction TodoList({ todos, query }) {\n\t// Recalculated on every render\n\tconst filtered = filterTodos (todos, query);\n\t// Recalculated only when inputs change\n\tconst filtered = useMemo (\n\t\t() => filterTodos (todos, query),\n\t\t[todos, query]\n\t);\n\t// ...\n}",
    "images":[]
  },
  "r56":{
    "id":"08f36e356",
    "theme":"r",
    "question":"Что такое синтетические события (SyntheticEvent) в React?",
    "answer":"Синтетические события или Synthetic Event - это обёртка над нативными событиями JavaScript. Synthetic Event является частью системы событий react, если говорить просто, то это кроссбраузерная обертка над нативным экземпляром события, у неё такой же интерфейс, как и у нативного события включая методы stopPropagation, preventDefault и так далее. Это обёртка помогает событиям работать одинаково во всех браузерах, если же всё-таки нужно получить нативное браузерное событие, следует обратиться к атрибуту nativeEvent, который находится внутри синтетического события. Синтетические события отличаются от нативных событий браузера и непосредственно не связаны с ними. Однако, с точки зрения работы с ними в коде они практически идентичны.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/qrqdse3h0m8x6bbg4x25a/3c5072ad-a836-4a4e-8a41-2109cd5c5b62.webp?rlkey=o0o1y0jpirjkg2d8b1xf4zsym&st=wyodlkgc&dl=1"]
  },
  "r70":{
    "id":"08f36e402",
    "theme":"r",
    "question":"Техники оптимизации перфоманса React?",
    "answer":"Использование немутабельных (неизменяемых) структур данных.\n\tНемутабельность данных означает, что при изменении состояния создаются новые объекты вместо изменения существующих. Это позволяет легко отслеживать изменения и использовать поверхностные сравнения (shallow comparisons) для оптимизации рендеров, например, в PureComponent или React.memo. Библиотеки, такие как Immer или Immutable.js, помогают реализовать эту концепцию.\n\tПрименение функциональных stateless компонентов и React.PureComponent.\n\tФункциональные компоненты без состояния (stateless) проще и быстрее, так как не имеют собственного состояния или методов жизненного цикла. React.PureComponent автоматически реализует shouldComponentUpdate с поверхностным сравнением пропсов и состояния, что предотвращает ненужные рендеры.\n\tИспользовать React.Fragments, чтобы избежать дополнительных оберток html-элементов и не создавать лишних DOM-узлов.\n\tИспользовать key с уникальными и стабильными значениями для отрисовки элементов массива.\nИспользование уникальных ключей для элементов массива позволяет React эффективно обновлять и перерисовывать только изменившиеся элементы. Уникальные и стабильные ключи (например, идентификаторы из базы данных) помогают избежать ошибок и улучшить производительность.\n\tИспользование библиотеки для управления состоянием, например, Redux Toolkit, которая предлагает оптимизированные механизмы управления состоянием и избегает лишних ререндеров.\n\tМемоизация компонентов (memo, useMemo, useCallback)\nМемоизация позволяет кэшировать результаты вычислений и предотвращает повторное выполнение функций или рендеринг компонентов, если их входные данные не изменились.\nReact.memo: предотвращает ререндер функционального компонента, если его пропсы не изменились.\nuseMemo: мемоизирует вычисленное значение, чтобы избежать повторных дорогостоящих операций.\nuseCallback: мемоизирует функции, чтобы избежать их создания на каждом рендере.",
    "codeexample":"",
    "images":[]
  },
  "r71":{
    "id":"08f36e403",
    "theme":"r",
    "question":"Лучшие практики безопасности в React?",
    "answer":"- React по умолчанию экранирует значения при рендеринге JSX, что защищает от XSS, но это не избавляет от необходимости тщательно проверять данные, особенно при использовании HTML напрямую.\n\t- Следует избегать использования dangerouslySetInnerHTML с непроверенными данными: Это открывает дверь для XSS-атак. Этот метод можно использовать только если нет других вариантов и с предобработанными данными.\n\t- Очистка пользовательского ввода: Всегда очищайте пользовательский ввод с помощью библиотек вроде DOMPurify, чтобы удалить потенциально опасные элементы (санитайзинг).\n\t- Избегание опасных URL-адресов и внедрения скриптов на основе URL-адресов. Использование проверки для URL.\n\t- Проверка уязвимостей в зависимостях\nМожно использовать такие инструменты, как npm audit или yarn audit, для поиска и устранения известных уязвимостей в зависимостях проекта. Также необходимо регулярно обновлять зависимости до последних стабильных версий, чтобы включить исправления безопасности и улучшения.\n\t- JSON.stringify: использование JSON.stringify для преобразования данных в строковый формат перед их передачей или хранением. Это помогает избежать проблем с некорректными форматами данных.\n\t- Проверка данных с помощью RegEx: следует применять регулярные выражения для проверки и фильтрации данных, которые вводят пользователи, или данных, которые поступают в приложение. Например, использование RegEx для проверки форматов email-адресов, номеров телефонов и других данных.\n\t- Очистка пользовательского ввода: следует применять регулярные выражения для удаления или экранирования потенциально опасных символов из пользовательского ввода перед использованием данных в приложении.",
    "codeexample":"",
    "images":[]
  },
  "r57":{
    "id":"08f36e357",
    "theme":"r",
    "question":"Является ли React реактивным?",
    "answer":"Начнём с того, что реакт компоненты - это функции, которые не вызываются напрямую. Эти функции в некоторые моменты времени возвращают описание того, что нужно отрендерить, причём эти функции вызывает сам реакт, в те самые некоторые моменты, также он способен отложить этот вызов. Реакт рекурсивно обходит дерево компонентов и может применять оптимизации и задерживать рендеры, чтобы избежать потерю кадров. Так как данные могут поступать быстрее, чем скорость обновления кадров, есть смысл объединять обновления в пакеты и обновлять всё пакетами, а следовательно react - это скорее планировщик и реактивность не проявляется в react в чистом виде.",
    "codeexample":"",
    "images":[]
  },
  "r58":{
    "id":"08f36e358",
    "theme":"sm",
    "question":"Что такое flux?",
    "answer":"Flux - это архитектурный подход или набор шаблонов программирования для построения пользовательского интерфейса веб-приложений, сочетающийся с реальным программированием и построенный на однонаправленных потоках данных. Основной отличительной особенностью flux является односторонняя направленность передачи данных. Архитектура накладывает ограничения на поток данных, а в частности исключая возможность обновления состояния компонентов самими собой.\nFlux-архитектура может содержать несколько основных слоев:\n\tactions - это событие. Действие поступает асинхронно, но их диспетчеризация является синхронным процессом, кроме имени действия могут иметь полезную нагрузку или payload. Она содержит относящиеся к действию данные;\n\tdispatcher - предназначен для передачи действия хранилищу, в нем одни хранилища регистрируют свои коллбэки и зависимости между другими хранилищами;\n\tstore (хранилище) - являются местом, где сосредоточен state или состояние приложения. Изменение состояния хранилища происходит строго на основании данных в action и старого состояния хранилища при помощи чистых функций;\n\tview (представление) - компонент обычно отвечающий за вывод информации пользователю. По Flux-архитектуре - это конечная точка потока данных. ",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/r9pav4nypjgoj1efb5lqz/flux-2-14d11c885e2e99938a6ffcc45705cad8.webp?rlkey=xyfg781x66h3vg6f4sq4ef1vi&st=evptk96g&dl=1"]
  },
  "r59":{
    "id":"08f36e359",
    "theme":"sm",
    "question":"Что такое Redux? Ключевые принципы Redux? ",
    "answer":"Redux - это стабильный, предсказуемый контейнер для хранения состояния js-приложений, основанный на паттерне проектирования flux. Redux предназначен для управления состоянием приложения и базируется на трех фундаментальных принципах:\n\t1.единственный источник истины;\n\t2.состояние доступно только для чтения;\n\t3.изменение производится с помощью чистых функций.\nДля определения того как изменяются состояния в зависимости от операций создаются reducer.  Reducer - это чистая функция, принимающая предыдущее состояние в качестве аргумента и возвращающая новые.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/1mt0yqsfm9xzuf43szmfa/1_Nt814ZypzBevBk74lNr4SA.webp?rlkey=46ouwu3mfekhyqr4a3af82nnc&st=hkobus9j&dl=1"]
  },
  "r60":{
    "id":"08f36e360",
    "theme":"sm",
    "question":"Разница между Redux и Flux? ",
    "answer":"Разницу между Redux и Flux можно описать с помощью основных пунктов:\n\t1. Недопустимость мутаций. Во Flux состояние может быть изменяемым, а Redux требует, чтобы состояние было неизменяемым или иммутабельным. Также многие библиотеки для Redux  исходят из предположения, что состояние никогда не будет изменяться напрямую.\n\t2. Отсутствие интеграции с flow. Flux  позволяет осуществлять очень выразительную статическую проверку типов, а Redux  пока такой возможности не поддерживает.\n\t3. Источники истины. Flux  предполагает, что хранилища данных или store может быть несколько, в то время как Redux Store может быть только один.\n\t4.Наличие диспетчера. В архитектуре Flux диспетчер предназначается для передачи действий store, в нем хранилища регистрируют свои callback и зависимости между другими store, в Redux  диспетчер отсутствует.\n\t5.Flux не пытается решать такие проблемы как повторное выполнение или отмена выполнения, постоянство кода или проблема, связанная с обработкой формы явно. В свою очередь Redux имеет возможность к расширению с помощью промежуточного программного обеспечения или так называемых Middleware.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/vat1kaytivg53dd4zousb/109767292-aa2dae80-7c3a-11eb-8b03-3fb8c41fc800.webp?rlkey=aopdmwm6qhopehzrlux2hwsyi&st=90mz3two&dl=1"]
  },
  "r61":{
    "id":"08f36e361",
    "theme":"sm",
    "question":"Ключевые концепции Redux?",
    "answer":"В этом вопросе речь идет обо всех составляющих, которые входят в состав библиотеки Redux.\n\tОперация или action - это статическое информация о событии, инициализирующий изменение состояния. Операция - это объекты содержащие обязательное свойство type и опциональное свойство payload. Вызывается с помощью метода storeDispatсh() и создются с помощью создателя операции или actionCreater.\n\tReducer - это чистая функция, которая принимает текущее состояние приложения, после чего выполняет над ним операции и возвращает новое состояние.\n\tСостояние или state - это объект, содержащий состояние приложения, при обновления состояния обновляются все подписанные на него компоненты.\n\tStore или хранилище отвечает за запись, чтение и обновление состояния.\n\tОтправка или Dispatch - это передача операции с типом и полезная нагрузка reducerу.\n\tПодписка или subscribe - это метод, используемый для подписки на состояние хранилища.\n\tПровайдер - это компонент содержащий ссылку на хранилище и передающий данные из хранилища дочерним компонентам.\n\tПодключение или connect - это функция взаимодействующая с провайдером.\n\tMiddleware или промежуточное программное обеспечение - это способ расширения Redux дополнительным функционалом. Они используются для отправки асинхронных операций и они не настаиваются в момент создания хранилища.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/x87yom0gburrxlzrizhxr/React-Redux-structure.webp?rlkey=cwpalb1tt6t9r21igfapu529s&st=mwzzrzpb&dl=1"]
  },
  "r62":{
    "id":"08f36e362",
    "theme":"sm",
    "question":"Что такое “единственный источник истины” (Single Surce of Truth)?",
    "answer":"Единственный источник истины - это состояние, которое не перезаписывается и структура которого является постоянной. Это позволяет получать информацию за постоянное время и поддерживать четкую структуру состояния приложения. В React Redux приложениях, где единственным способом изменить состояние UI является отправка операции в reducer, обновляющий состояние приложения, а компоненты подписанные на хранилища обновляются вслед за ним. Это не относится к state или локальному состоянию компонентов.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/7c7wzj1akzdx8trzbtzdz/redux-state-eca9478d3c83391fefdb692d0f6439eb.webp?rlkey=q4fc82qomie8qclfqp43mlx3c&st=9f6gpl64&dl=1"]
  },
  "r63":{
    "id":"08f36e363",
    "theme":"sm",
    "question":"Что такое редьюсер (Reducer)?",
    "answer":"Reducer - это чистая функция, определяющая изменение состояния приложения. Она использует операции для определения характера изменений.\nRedux управляет состоянием приложения с помощью единственного хранилища, так что они действуют согласовано. Изменение состояния зависит от действий пользователя или сетевых запросов. Если состоянием приложения управляется Redux изменение происходит в Reducer - это единственное место, в котором происходит изменение состояния.  Reducer использует текущее состояние приложения и операцию для определения нового состояния. Принимает данная функция два аргумента:\n\t1.текущее состояние;\n\t2.action.  Action представляет собой объект, который с помощью типа описывает происходящие изменения., а с помощью свойства payload, если такой есть, передает в  Reducer  дополнительные данные, которые можно использовать для изменения состояния.",
    "codeexample":"// initial state\nconst TASKS = {\n\ttasks: [],\n}\n\n// reducer (1st argument - initial state, 2nd argument - action)\nexport const tasks = (state = TASKS. tasks, { id, text, isCompleted, type }) => {\n\tswitch (type) {\n\t\t// reducer case\n\t\tcase ADD TASK:\n\t\t\t// return new state in each case\n\t\t\treturn [...state, { id, text, isCompleted } ];\n\t\tcase REMOVE_TASK:\n\t\t\treturn [...state].filter(task=> task.id !== id);\n\t\tcase COMPLETE_TASK:\n\t\treturn [...state].map(task=> {\n\t\t\tif (task.id === id) {\n\t\t\t\ttask.isCompleted = Itask.isCompleted;\n\t\t\t}\n\t\t\treturn task;\n\t\t});\n\t\tdefault:\n\t\treturn state:\n\t}",
    "images":[]
  },
  "r64":{
    "id":"08f36e364",
    "theme":"sm",
    "question":"Разница между React State и Redux State (или в чем разница между локальным и глобальными state или состояниями)?",
    "answer":"Состояние React хранится локально внутри компонента. При необходимости его между компонентами оно передается через props. На практике это означает, что  самый верхний компонент приложения, которое нуждается в некотором значении  будет хранить это значение в своем состоянии, если состояние должно быть изменено в дочернем компоненте, то можно передать callback для обработки изменений состояния  в этот компонент.\nПри использовании Redux состояние хранится глобально в store или хранилище. Любой компонент которому требуется доступ к состоянию  может подписаться на хранилище. Обычно это реализуется с помощью компонентов-контейнеров, но произвести изменение глобального состояния можно через action или действия, которая также пробрасывается в компонент через Redux Connect.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/kl7nibdwyb1kj0gn2z7w5/What-is-Redux.webp?rlkey=5q2bi2zc2ccsjm5z1s650h68c&st=puu007ks&dl=1"]
  },
  "r65":{
    "id":"08f36e343",
    "theme":"sm",
    "question":"Как выглядит поток данных в Redux-приложении?",
    "answer":"Redux представляет собой способ распределения данных между компонентами с помощью единого состояния хранилища (единственный источник истины). Компоненты, которым нужен доступ к состоянию подписываются на хранилища и получают состояние при его обновлении.\nRedux базируется на 5 столпах:\n\t1.создателя операции;\n\t2.функция отправки;\n\t3.reducer;\n\t4.состояния;\n\t5.хранилища.\nКак правило операция отправляется в ответ на действия пользователя. Корневой reducer вызывается с текущим состоянием и отправленной операцией. Он может разделять задачи между другими reducer, который возвращает новое состояние. Хранилище уведомляет подписчиков об изменении состояния, запуская их callback. Представление или интерфейс извлекает обновленное состояние и выполняет повторный рендеринг.",
    "codeexample":"",
    "images":["https://www.dropbox.com/scl/fi/rkcvj0mg2wtm9vzbop4q1/redux-data-flow-a64daf9a1e595dde09b49b9aece2cb0c.gif?rlkey=orl1t0omnlp0oympz4400asqg&st=l47qry73&dl=1"]
  },
  "r66":{
    "id":"08f36e366",
    "theme":"sm",
    "question":"Плюсы и минусы Redux?",
    "answer":"К преимуществам Redux можно отнести:\t\n1.хранилище позволяет любому компоненту получать состояние без передачи пропсов, что позволяет избежать prop drilling;\t\n2.состояние сохраняется даже при размонтировании компонента;\t\n3.предотвращает ненужные повторные рендеринги благодаря поверхностному сравнению нового и старого состояния;\t\n4.разделение UI и управления данными облегчает тестирование, сохраняются истории изменения состояния, что позволяет легко проверять или отменять операции.\t\n5.К недостаткам можно отнести:\n\t6.отсутствует инкапсуляция, любой компонент имеет доступ к данным, что может привести к проблемам с безопасностью;\t\n7.много шаблонного кода, ограниченный дизайн;\t\n8.поскольку состояние является иммутабельным reducer обновляет его каждый раз возвращая новое состояние. что влечет дополнительные расходы памяти. ",
    "codeexample":"",
    "images":[]
  }
}