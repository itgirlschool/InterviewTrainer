{
  "w1":{
    "theme":"w",
    "question":"Что такое прогрессивный рендеринг?",
    "answer":"Обобщенное название технологии, которое используется для ускорения отрисовки web-страниц. Основная идея - это как можно раньше указать пользователю визуальный контент. Основная задача - уменьшение времени загрузки.\nК технологиям прогрессивного рендеринга можно отнести: \n\n\t1.Линейную загрузку картинок. При отрисовке страницы отображаются только те картинки, которые находятся в видимой области экрана;\n\n\t 2.Приоритизация видимого контента. При этом подходе минимизируют и инкапсулируют стили, разметку и скрипты для той части страницы, которую пользователь увидит первой. Для реализации можно использовать события DOMContentLoaded и load, либо применять отложенные скрипты, чтобы догрузить остальные ресурсы.\n\n\t3.Асинхронные фрагменты HTML. Идея похожа на SSR (Server Side Rendering). В браузер отправляются HTML страницы, созданные на backend.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w2":{
    "theme":"w",
    "question":"Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?",
    "answer":"Адаптивный (adaptive) и отзывчивый (responsive) дизайн — это два подхода к созданию веб-сайтов и приложений, которые могут эффективно работать на устройствах с разными размерами экранов. Несмотря на то, что оба подхода имеют одну цель — улучшить пользовательский опыт на различных устройствах, они достигают этой цели по-разному. \n\nАдаптивный дизайн (Adaptive Design). \n\tСтруктура: В адаптивном дизайне создаются несколько фиксированных макетов для различных размеров экранов. Например, один макет для мобильных устройств, другой для планшетов, третий для десктопов. \n\tКак работает: Когда пользователь открывает сайт, адаптивный дизайн определяет размер экрана и загружает соответствующий макет. \n\tГибкость: Адаптивный дизайн менее гибок, поскольку макеты создаются заранее и адаптируются только к определённым размерам экранов. \n\tЧаще используется в проектах, где требуется более точный контроль над отображением контента на различных устройствах. \n\nОтзывчивый дизайн (Responsive Design) \n\n\tСтруктура: В отзывчивом дизайне используется единый гибкий макет, который адаптируется к любому размеру экрана. Это достигается с помощью медиа-запросов, гибких сеток (flexbox, grid) и относительных единиц измерения (проценты, em, rem). \n\n\tКак работает: Макет автоматически подстраивается под размер экрана в реальном времени, меняя свою структуру и элементы в зависимости от доступного пространства. \n\n\tГибкость: Отзывчивый дизайн более гибок, так как он не ограничивается фиксированными макетами и плавно адаптируется к любому экрану.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w3":{
    "theme":"w",
    "question":"Разница между Progressive Enhancement и Graceful Degradation?",
    "answer":"Оба подхода используются для создания кросс-платформенных и кросс-браузерных интерфейсов. Progressive Enhancement предполагает создание веб-интерфейса от простого к сложному (как вариант сначала создание приложения на мобильном устройстве, потом под планшет, потом десктоп). Graceful Degradation это создание в обратном порядке - от наиболее сложного к более простому (от десктопа к мобильному, или от более современных браузеров к более слабым)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w15":{
    "theme":"w",
    "question":"Что такое кроссбраузерность?",
    "answer":"Это корректная адаптивная верстка для правильного отображения сайта в разных браузерах и на разных устройствах.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w16":{
    "theme":"w",
    "question":"Что такое Babel? Для чего он используется?",
    "answer":"Babel - это транспайлер, который переписывает код современного стандарта JavaScript на более поздний. Транспайлер - это программа позволяющая менять исходный код одной программы на эквивалентный исходный код на другом языке. Обычно Babel работает на сервере в составе системы сборки JS-кода, например, Webpack. Основная идея использования  Babel, в том, что Ecma International каждый год выпускает обновление для  JavaScript. Однако эти обновления в браузер внедряются  постепенно, чтобы не терять время, а сразу начать использовать новый функционал, который зачастую упрощают разработку используются Babel, которая осуществлять траспиляцию новых конструкций в старые варианты для лучше кроссбраузерности. Конфигураци Babel прописывается в файле babel.config, либо .babelrc для настроек одного пакета, а также указывается в package.json.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w17":{
    "theme":"w",
    "question":"Разница между feature detection, feature inference и анализом строки user-agent?",
    "answer":"Все три подхода обозначены для определения браузерных возможностей пользователя. Feature detection или определения возможностей браузера заключается в определении поддерживает ли браузер определенный блок кода и если блок не поддерживается, то будет выполнен аналог или полифил. Такой подход помогает обеспечить работоспособность и предотвратить сбои и ошибки. Пример такого подхода - это библиотека Modernizr. Feature inference или определение возможностей - это проверка на наличие определенных возможностей. Подход примеряет функцию, которая предполагает, что определенная возможность уже существует. User-agent - это строка сообщаемая браузером, которая позволяет определить тип приложения, операционную систему, поставщика программного обеспечения. Доступ к ней можно получить через navigator.userAgent. Следует отметить, что два последних подхода не рекомендовано использовать, так как самым надежным является feature detection.",
    "codeexample":"//Feature detection \nif('geolocation' in navigator) {\n//use navigator.geolocation\n} else {\n//another code\n}\n\n//Feature inference\nif (document.getElementsByTagName) {\nelement = document.getElementById(id);\n}\n\n// User Agent\nconsole.log(navigator.userAgent);\n \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebkit/537.36 (KHTML, like Geco) Chrome/91.0.4472.106 Safari/537.36\"",
    "images":[],
    "checked":""
  },
  "w4":{
    "theme":"w",
    "question":"Разница между layout, painting и compositing?",
    "answer":"Все три этапа относятся к отрисовке веб-страницы. \n\nLayout или раскладка - это расчет места для объекта на основе css правил. Painting или отрисовка - это рисование пикселей для отображения визуальных элементов. \n\nСompositing или композиция - это отрисовка слоев в определенном порядке, то есть правильное наложение.",
    "codeexample":"",
    "images":["https://www.researchgate.net/publication/336377602/figure/fig2/AS:812437553037313@1570711615245/The-construction-process-of-render-tree.png"],
    "checked":""
  },
  "w5":{
    "theme":"w",
    "question":"Что такое безопасные (Secure) и HttpOnly cookies?",
    "answer":"Безопасные куки отсылаются на сервер только если запросы выполняется по протоколу SSL и HTTPS, однако важные данные никогда не следует передавать или хранить в cookies, поскольку сам их механизм весьма уязвим в отношении безопасности по flag secure никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с 52 версии в Chrome и FireFox не защищённые сайты с протоколом http не могут создавать куки с флагом secure. Куки HTTP Only недоступны из javascrip через свойство document.cookie и через xml http request, а также request API, что помогает избежать межсайтового скриптинга или XSS. Устанавливать этот флаг можно для тех cookie к которым не требуется обращаться через javascrip в частности если куки используются только для поддержки сеанса то в javascrip они не нужны. Так что в этом случае следует устанавливать флаг http only.",
    "codeexample":"",
    "images":["https://itsecforu.ru/wp-content/uploads/2017/11/1-16.png"],
    "checked":""
  },
  "w6":{
    "theme":"w",
    "question":"Что такое Content Security Policy (CSP)?",
    "answer":"CSP - политика безопасности контента. CSP - это http header который позволяет операторам сайта детально контролировать откуда могут быть загружены ресурсы на их сайт. Использование данного заголовка - это лучший способ предотвратить уязвимость межсайтового скриптинга или xss и атаки внедрения данных. CSP является обязательным для всех новых веб-сайтов и настоятельно рекомендуется для всех существующих сайтов с высоким уровнем риска. В случае, если сайт не предоставляет CSP заголовки браузер в свою очередь будет использовать стандартные правила по ограничению домена. Настройка CSP включает в себя добавление на страницу http-заголовка Content Security Policy и его настройку в соответствии со списком доверенных источников из которых пользователь может получать контент.",
    "codeexample":"",
    "images":["https://www.rahulpnath.com/content/images/size/w1384/content-security-policy.png"],
    "checked":""
  },
  "w7":{
    "theme":"w",
    "question":"Что такое межсайтовый скриптинг (XSS)?",
    "answer":"Межсайтовый скриптинг или XSS - это довольно распространённая уязвимость которую можно обнаружить на множестве web приложений. Суть довольно проста: злоумышленнику удаётся внедрить на страницу JS код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда пользователи будут заходить на страницу приложения, куда этот код был добавлен. Страница, предоставляемая сервером, когда кто-то её запрашивает при этом не изменяется, вместо этого XSS атака использует уязвимость на странице, которая включает переменную отправленную в запрос для отображения в необработанном виде в ответе. Специфика подобных атак заключается в том, что вредоносный код может использовать авторизацию пользователя в веб-системе для получения к ней расширенного доступа или для получения авторизационных данных пользователя.",
    "codeexample":"",
    "images":["https://telegra.ph/file/91d2b78d5464ef6a6e6cb.gif"],
    "checked":""
  },
  "w8":{
    "theme":"w",
    "question":"Что Такое API?",
    "answer":"API (Application programming interface) - это интерфейс для взаимодействия между различными программными компонентами. API предоставляет набор функций и протоколов, которые позволяют приложениям общаться друг с другом. Проще говоря, API позволяет одному приложению запрашивать и манипулировать данными или функциями другого приложения или сервиса, что облегчает интеграцию и расширение функциональности без необходимости глубокого понимания внутренней логики других приложений. API часто используется для выполнения базовых операций с данными — создания (Create), чтения (Read), обновления (Update) и удаления (Delete) данных (CRUD-операции). Эти операции реализуются через HTTP-запросы, такие как POST, GET, PUT и DELETE, направленные на определенные URL-адреса.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w9":{
    "theme":"w",
    "question":"Что такое CDN?",
    "answer":"CDN (Content delivery network) - это сеть распределенных серверов, которые совместно работают для обеспечения быстрой и надежной доставки контента пользователям. Серверы в CDN расположены в различных географических точках по всему миру и содержат копии статических ресурсов, таких как изображения, видео, стили, скрипты и другие данные. Когда пользователь запрашивает ресурс, CDN перенаправляет запрос на ближайший сервер к пользователю. Это минимизирует задержку и ускоряет время загрузки страницы. Децентрализованная структура позволяет избежать перегрузок и снижает риски отказа в случае выхода из строя одного из серверов.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w10":{
    "theme":"w",
    "question":"Что такое REST?",
    "answer":"REpresentational State Transfer то есть передача состояния представления - это архитектурный стиль взаимодействия компонентов распределённого приложения. В сети rest представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиасистемы. В определённых случаях, такие как например интернет-магазины, поисковые системы и прочие системы, основанные на данных, это приводит к повышению производительности и упрощению архитектуры. В общем случае rest является очень простым интерфейсом управления информацией без использования каких-то дополнительных внутренних прослоек. Каждая единица информации однозначно определяется глобальным идентификатором таким как URL, а каждый URL свою очередь имеет строго заданный формат. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w11":{
    "theme":"w",
    "question":"Назовите критические этапы рендеринга?",
    "answer":"Критические этапы рендеринга или critical rendering pass - это последовательность шагов, которую выполняет браузер, когда HTML, CSS и JavaScript преобразуются в пиксели, которые видны на экране. Самый полный и последовательный список основных шагов выглядит следующим образом: Document Object Model - ответ в виде HTML превращается в токены, которые в свою очередь превращаются в узлы и в последующем формируют DOM дерево. Css Object Mode или CSSOM: если html документ содержит стили, то припасинге они запрашиваются и участвуют в построении CSSOM, который содержит все стили страницы, то есть данные о том, как стилизовать DOM.  JavaScript - если html-документ содержит тег script, то происходит либо исполнение этого скрипта, либо запрос и исполнение сторонних подключенных скриптов. JavaScript в свою очередь может модифицировать DOM дерево. Следующий шаг - это Accessibility Tree при парсинге HTML анализируются специальное атрибуты по типу roll и area, в результате чего происходит построение так называемого дерева доступности, которое в последующем может использоваться скринридерами. Render Tree: на данном этапе происходит объединение DOM и CSSOM или объектной модели документа и ассоциированных стилей каждого элемента. Для построения дерева рендера браузер проверяет каждый узел DOM, начиная от корневого, и определяет, какие CSS правила нужно присоединить к этому узлу. Дерево рендера охватывает только видимое содержимое. Layout/Reflow - в тот момент, когда дерево рендера построено, становится возможным этап компоновки или layout. Этот этап определяет, где и как на странице будут позиционированы элементы, и каковы связи между элементами. Другими словами на основании размеров элемента определяется его положение. Первый шаг, как уже было сказано, называется layout, все последующие шаги, связанные с пересчётами размеров называются reflow. Paint/Repaint: когда дерево рендера создано, компоновка произошла, пиксели могут быть отрисованы. Если говорить просто, то на этом этапе происходит покраска веб-страницы согласно заданным стилям, первая покраска называется paint все последующие перекраски называются repaint. Compositing: заключительный шаг, когда готовые спозиционированные элементы выстраиваются друг относительно друга по уровням или потокам по умолчанию все элементы на странице идут в главном или в основном потоке, однако задание определённых CSS свойств может вырвать их из основного потока и сформировать новый. На этапе compositing элементы в разных потоках выстраиваются друг относительно друга.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w12":{
    "theme":"w",
    "question":"Разница между композицией и наследованием?",
    "answer":"Наследование - это концепция ООП, когда один класс наследует поля и методы другого класса, что обеспечивает возможность повторного использования кода. Предполагает тесную взаимосвязь между компонентами: производные компоненты должны наследовать свойства базового компонента, что сильно усложняет модификацию конкретного компонента. Композиция - это ещё одна концепция ООП, но в отличии от наследования, расширяемый класс ссылается на экземпляры другого класса. Предполагает наследование поведения,а не свойств, что существенно облегчает добавление новых свойств в конкретный компонент. Компоненты по возможности должны быть переиспользуемыми. Тесная связь наследующих компонентов делает их зависимыми от специфики реализации приложения в котором они используются. Композиция делает связи между компонентами слабыми, что повышает их автономность.",
    "codeexample":"",
    "images":["https://habrastorage.org/webt/-t/cv/aa/-tcvaa8gtnipg_ridjunpf9b1tu.gif","https://habrastorage.org/webt/qj/jo/mg/qjjomgocinjckd5kxjmubl1gzqc.gif"],
    "checked":""
  },
  "w13":{
    "theme":"w",
    "question":"Какие принципы можно использовать вместе с наследованием?",
    "answer":"Есть ещё три важных принципа ООП которые можно использовать совместно с наследованием - это делегация, или поручение задачи от внешнего объекта к внутреннему, композиция- включение объектом контейнером объекта содержимого и управление его поведением, причём последний не может существовать вне первого и агрегация - включение объектом контейнером ссылки на объект содержимое при уничтожении первого последний продолжает существование.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "w14":{
    "theme":"w",
    "question":"Основные принципы ООП?",
    "answer":"ООП (объектно-ориентированный подход программирования) базируется на 4 основных принципах: \n\n\tАбстракция - это отделение концепции от реализации. Основная идея состоит в том, чтобы представить объект минимальным объемом полей и методов для решения поставленной задачи. \n\n\tНаследование - это способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода, т.е при наследовании класса поток получает все методы и свойства класса родителя, при условии, что данные методы и свойство не являются приватными. \n\n\tИнкапсуляция - это размещение одного объекта или класса внутри другого для разграничения доступа к ним. \n\n\tПолиморфизм - это реализация задач одной и той же идеи разными способами.",
    "codeexample":"",
    "images":["https://static.tildacdn.com/tild6365-3832-4464-b861-623030313631/scale_1200.png"],
    "checked":""
  },
  "h19":{
    "theme":"h",
    "question":"Что такое HTML и для чего он нужен?",
    "answer":"Это язык гипертекстовой разметки (HyperText Markup Language). Это стандартизированный язык, позволяющий создавать веб-страницы. Он интерпретируется браузером и отображается в виде структуры и содержания на веб-странице.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h20":{
    "theme":"h",
    "question":"Какие глобальные атрибуты есть в HTML?",
    "answer":"В HTML есть категория атрибутов, которые можно применять практически к любому тегу. Самый яркий пример глобального атрибута - это class, с помощью него можно осуществлять поиск или стилизацию элемента. В качестве значения он принимает строку. class может быть задан абсолютно любому тегу. contenteditable делает любой элемент на странице  редактируемым, в качестве значения для атрибута используются булевы значения true или false. data* - это группа атрибутов, позволяющая перекидывать данные между HTML и DOM часто используется для взаимодействия с HTML при помощи javascript. hidden не требует явного указания значения, наличие атрибута само по себе означает состояние true. Прячет на странице любой HTML-элемент, причём элемент не виден не только для глаз пользователя, но и для скридеров. spellcheck - с помощью этого атрибута можно указать браузеру, что в элементе, которому он задан, нужно проверить правописание. tabindex указывает браузеру нужно ли видеть этот элемент при навигации по странице с помощью клавиатуры, часто используется для не интерактивных элементов, значение - отрицательное или положительное целое число.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h21":{
    "theme":"h",
    "question":"Что такое категории контента в HTML5?",
    "answer":"Каждый элемент HTML принадлежит к некоторому количеству категорий контента которые объединяют элементы с общим набором характеристик. Такая группировка является свободной, то есть на самом деле не задаёт отношения между элементами таких типов, а помогает определить и описать их поведения и правила, которым они должны следовать, особенно когда дело доходит до сложных деталейю Также возможна ситуация когда элемент не входит ни в одну из этих категорий. Существует три основных типа категорий контента - это основные категории контента описывающие общие для многих элементов правила, категории контента для элементов форм описывающие общее правило для элементов форм, особые категории контента описывающие редкие категории актуальные только для нескольких элементов, возможно лишь в особом контексте.",
    "codeexample":"",
    "images":["https://html5book.ru/wp-content/uploads/2017/02/html5_content-model.png"],
    "checked":""
  },
  "h22":{
    "theme":"h",
    "question":"Какие категории считаются основными категориями контента?",
    "answer":"К основным категориям контента относятся: Метаданные - это элементы, принадлежащие категории метаданных. Они изменяют отображение или поведение HTML документа, связывают его с другими документами и предоставляют другую дополнительную информацию; Потоковый контент - это элементы основного потока который обычно содержит текст и встроенный контент; Секционный контент - подобные элементы создают глобальные секции в текущей структуре документа, определяющие область действия заголовочного контента и элементов header и footer; Заголовочный контент - определяет заголовок секции явно отмеченной структурным элементом или не явно самим заголовочным элементом; Фразовый контент - определяет текст и его формат серии фразового контента образуют параграфы; Встроенный контент - импортирует документ в другой ресурс или вставляет содержимое на другом языке разметки или принадлежащее другому пространству имён; Интерактивный контент - это элементы которые специально разработаны для взаимодействия с пользователем; Явный контент - это контент который считается явным, когда он не скрыт и не является пустым, это контент который непосредственно отображён на странице. У элементов потокового или фразового контента должен быть хотя бы один явный узел. Контент форм - он включает в себя элементы, владельцем которых обычно является форма или тег форм.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h23":{
    "theme":"h",
    "question":"Что такое doctype? И для чего он используется?",
    "answer":"Doctype используется для указания типа документа. Добавляется он первой строкой любого html-документа, служит для того, чтобы браузер мог понять как ему интерпретировать страницу.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h24":{
    "theme":"h",
    "question":"Опишите базовую структуру HTML-страницы?",
    "answer":"В самом верху обязательно идет doctype, затем идет тег html, внутри него два основных тега - head (содержит вспомогательные данные о документе, данные внутри этого тега не отрисовываются на странице), body (тег, который содержит всю разметку html-документа)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h25":{
    "theme":"h",
    "question":"Что такое валидация? И какие типы проверок HTML документа вы знаете?",
    "answer":"Валидация - это проверка документа специальной программой валидатором на соответствие установленным веб-стандартам и обнаружение ошибок. Стандарты называются спецификациями, разработаны они консорциумом world wide web - W3C. Работа валидатора состоит из следующего: определяется тип документа (который указан при помощи doctype), проверяется html-код на правильность, также проверяется правильность использования тегов и их вложенность. 4 типа проверки: проверка синтаксиса, проверка вложенности, проверка dtd (Document Type Definition ), проверка на наличие посторонних элементов. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h26":{
    "theme":"h",
    "question":"Основные этапы проверок валидности HTML-документа?",
    "answer":"Валидация - это проверка документов специальной программой валидатором на соответствие установленным веб-стандартам и обнаружения существующих ошибок. Валидным считается документ, который проходит следующие этапы: валидация DTD (Document Type Definition) любой HTML-документ должет содержать doctype для того, чтобы браузер  и валидатор могли понять какая версия стандарта используется, и в соответвие с этим применять определенные правила проверки; валидация синтаксиса на основании DTD валидации происходит  анализа синтаксиса на используемые тэги; проверка вложенности. Все используемые в HTML разметке тэги формируют вложенные структуры. Валидатор проверяет правильно ли выполнен данный механизм; проверка на посторонние элементы.  Если одна из проверка не успешна, то HTML-документа считается не валидным.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h27":{
    "theme":"h",
    "question":"Если представить HTML5 как открытую веб-платформу, из каких блоков он состоит?",
    "answer":"Можно перечислить 8 основных пунктов: Семантика - позволяет более точно описать из чего состоит контент; Стилизация - позволяет создать сложные темы оформления; Доступ к устройствам - позволяет взаимодействовать с различными устройствами ввода и вывода; Связанность - позволяет общаться с сервером; Оффлайн хранилище - позволяет страницам хранить данные локально на клиентской стороне и более эффективно работать оффлайн; Мультимедиа - создание и подключение видео и аудио; 2D/3D графика - позволяют расширить возможности презентации; Производительность и интеграция - обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h28":{
    "theme":"h",
    "question":"Какой тэг использовать для того, чтобы сверстать кнопку?",
    "answer":"Зависит от того, какую именно кнопку. Обычная кнопка, функциональность которой добавлена через JS - тогда тег button. Второй случай кнопка отправки формы - либо <button type=’submit’>, либо <input type=’submit’, value=’button’>. Третий вариант это кнопка-ссылка, здесь нужно использовать тег <a>, который стилизирован под кнопку при помощи CSS.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h29":{
    "theme":"h",
    "question":"Что такое инлайновый стиль? Можно ли его переопределить?",
    "answer":"inline - когда стиль прописан не в отдельном файле/блоке, а непосредственно в коде. То есть инлайновый стиль применяется к определенному элементу в html и указывается прямо в html-файле при помощи атрибута style внутри тега. Inline стиль имеет самый высокий приоритет, игнорируя CSS правила, распространяющиеся на родителя и одноименные элементы/классы. Поэтому переопределить его можно только при помощи атрибута !important, который добавляется на CSS-свойство. Обычно инлайн стили не используют в современной разработке.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h30":{
    "theme":"h",
    "question":"Есть ли у HTML элементов свои дефолтные специфичные стили?",
    "answer":"Да, практически каждый html-элемент обладает набором индивидуальных стилей. Это могут быть паддинги, марджины, размер шрифта, декорация текста и тд Проблема, что в разных браузерах разные дефолтные стили. Для их нивелирования используется normalize.css",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h31":{
    "theme":"h",
    "question":"Что такое семантика? Какие семантичные тэги вы знаете?",
    "answer":"Семантика - это использование правильных тегов, описывающих содержание контента внутри себя. Семантический тег описывает смысл элемента. (текст в теге p, заголовок в теге h, шапку в header и тп)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h32":{
    "theme":"h",
    "question":"Как семантически правильно сверстать картинку с подписью?",
    "answer":"Внутрь тега figure помещается два тега - img и figcaption, в который помещается подпись к картинке",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h33":{
    "theme":"h",
    "question":"Типы списков в HTML?",
    "answer":"В HTML существуют три основных типа списков: Нумерованный список (Ordered List): Используется для отображения элементов в определенном порядке. Каждый элемент списка пронумерован автоматически. Создается с помощью тега <ol>, а элементы списка обозначаются тегом <li>. Ненумерованный список (Unordered List): Используется для отображения элементов без определенного порядка. Каждый элемент списка обозначен буллетом или маркером. Создается с помощью тега <ul>, а элементы списка обозначаются тегом <li>. Список определений (Definition List): Используется для отображения пар \"термин-описание\". Создается с помощью тега <dl>, термины обозначаются тегом <dt>, а описания — тегом <dd>. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h34":{
    "theme":"h",
    "question":"Для какого тэга используется атрибут alt и зачем он нужен?",
    "answer":"Это значит “альтернативный текст”, добавляется для тега img, то есть для картинки. В случае если картинка не отображается на странице, то вместо нее будет отображаться альтернативный текст. Этот атрибут обязателен при разработке. Его наличие улучшает доступность, так как прочитывается скринридерами.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h35":{
    "theme":"h",
    "question":"Какая разница между тэгами <strong><em> и <b><i>?",
    "answer":"Если посмотреть на результат в браузере, то теги <strong> и <b> делают текст жирным, а теги <em> и <i> делают его курсивным, однако теги <strong> и <em> предназначены для добавления обернутому элементу логического выделения - то есть при чтении страницы скринридерами или поисковыми системами на данном тексте будет сделан акцент, а теги <b> и <i> такого акцента не добавляют.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h36":{
    "theme":"h",
    "question":"Типы <input> элементов в HTML?",
    "answer":"В HTML для коммуникации с пользователем есть элемент input у него есть атрибут type. Некоторые примеры типов (их гораздо больше): text(для ввода букв, цифр и специальных символов), password (для ввода паролей, отображаются ***), e-mail (некоторые браузеры предлагают нужные символы и проверяют на соответствие формату email), number(позволяет вводить только числовые значения, ограничивать максимальное и минимальное), submit (поле превращается в кнопку для отправки данных), checkbox, radio, date/month/daytime-local (для ввода даты в виде выпадающего календаря) и тд.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h37":{
    "theme":"h",
    "question":"Для чего используют data-атрибуты?",
    "answer":"Это устаревший подход. Раньше он применялся для хранения различной информации. То есть прямо в DOM-дереве можно хранить дополнительные данные.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h38":{
    "theme":"h",
    "question":"Разница между <script>, <script async> и <script defer>?",
    "answer":"Когда происходит чтение или парсинг html-документа, парсинг может наткнуться на тег script. Script вызывает выполнение JS-кода, но при этом блокируется дальнейшее чтение html, пока не будет выполнен script. Поэтому этот тег добавляют обычно в конец документа. script с атрибутом async будет выполняться параллельно с чтением html-документа. Обычно это скрипт, который выполняется независимо от других скриптов документа. script defer - его выполнения произойдет только после полного парсинга страницы, то есть когда DOM-дерево будет полностью готово.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h39":{
    "theme":"h",
    "question":"Для чего используется элемент <datalist>?",
    "answer":"Это html5 - элемент, который используется для создания выпадающего списка с возможностью в html нативной реализации автозаполнения. Для того чтобы добавить такой список на обычный input-элемент, ему добавляется атрибут list, а затем тегу datalist добавляется атрибут с таким же id. Когда пользователь начинает что-то печатать, ему предлагается список с подходящими вариантами.",
    "codeexample":"<input list=\"country\">\n<datalist id=\"country\">\n\t<option value=\"Russia\">\n\t<option value=\"Albania\">\n\t<option value=\"Bosnia\">\n\t<option value=\"Algeria\">\n</datalist>",
    "images":[],
    "checked":""
  },
  "h40":{
    "theme":"h",
    "question":"Почему хорошей практикой считается располагать <link> для подключения CSS стилей внутри тэга <head>, а <script> для подключения JS ставить перед закрывающимся тэгом </body>?",
    "answer":"Необходимость помещать тэг <link>  внутри шапки сайта описано в спецификации. Чтение HTML страницы происходит слева направо сверху вниз, а построение loyat и его стилизации - это процессы, которые идут параллельно. Основная задача для улучшения UIX - это как можно раньше показать пользователю хоть какой-то контент, а не белую страницу, поэтому стили размещают внутри <head> или на самом высоком уровне страницы для того, чтобы их можно было как можно раньше запросить и добавить на читаемый HTML. Если их переместить вниз, то такой порядок препятствует прогрессивной загрузке страницы во многих браузерах. Таким образом они блокируют загрузку страницы, чтобы избежать перерисовку элемента если его стили изменяются, а пользователь все это время будет видеть просто белую страницу. Когда браузер встречает тэг script все процессы построения DOM и стилизации элементов откладываются до тех пор пока найденный скрипт не будет исполнен, поэтому тэг указывается в самом конце, чтобы не влиять на описанные процессы. Однако даже такое поведение можно отменить, если воспользоваться атрибутами async или deffer. Еще одна причина добавлять script  в конец документа - это то, что зачастую для работы скрипта нужны элементы DOM-дерева, для того, чтобы к моменту исполнения они были доступны тэг script и помещают перед закрывающимся тегом body.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h41":{
    "theme":"h",
    "question":"Что такое мета-тэги?",
    "answer":"Это специальные теги <meta>, которые находятся внутри тега <head> и описывают само содержимое страницы. Они находятся в коде, но не отрисовываются в браузере. Основная их задача - это кратко описывать содержимое страницы поисковым системам, браузерам, социальным сетям. К ним можно отнести мета-тег для описании кодировки (<meta charset=\"UTF-8\">), СЕО-информации (автор, ключевые слова: напр., <meta name=\"keywords\" content=\"html, webdev\">), управления кешированием и другой дополнительной информации для браузеров.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h42":{
    "theme":"h",
    "question":"Что описывается в тэге <head>?",
    "answer":"В теге <head> HTML-документа содержатся метаданные, которые не отображаются непосредственно на веб-странице, но играют важную роль для работы браузера, поисковых систем и других сервисов. В него входит тег <title> - в нем указывается основной заголовок html-страницы, который индексируется поисковиками. Теги <meta> - в основном нужны чтобы прописать кодировку, добавить описание и ключевые слова страницы, и вспомогательную информацию для браузеров. Также внутри тега <head> прописывается путь к таблицам стилей и другим внешним ресурсам с помощью тега <link>. Тег <style> может быть использован для вставки CSS-правил прямо в документ (но обычно так не делают). Также внутри тега <head> в некоторых случаях при помощи тега <script> подключаются скрипты (хотя чаще скрипты размещают перед закрывающим тегом <body>.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h43":{
    "theme":"h",
    "question":"Для чего используются тэги <tr>, <th>, <td>?",
    "answer":"Это несамостоятельные теги, они используются внутри тега создания таблицы <table>. <tr> (table row) - служит контейнером, для создания строки таблицы, <th> (table head) - заголовок таблицы, <td> (table data) - для создания ячейки таблицы внутри строки.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h44":{
    "theme":"h",
    "question":"Расскажите о meta-теге с name=\"viewport\"?",
    "answer":"Метатег viewport используется при построении отзывчивой версии сайта, то есть сайта оптимизированного для мобильных устройств. В ключевом атрибуте content описывается, каким образом страница должна себя вести на устройствах с разным разрешением. Здесь речь идёт о глобальном подходе. Свойство width определяет размера окна просмотра. Он может быть установлен на некоторое количество пикселей или на специальное значение device-width которое означает ширину экрана в CSS пикселях в масштабе 100%, свойство initial-scale контролирует уровень масштабирования при первой загрузке страницы. Обычно данное значение определяют как 1.0 свойства maximum-scale и minimum-scale определяет, как  пользователям разрешено увеличивать или уменьшать страницу, а user-scalable=no запрещает любое масштабирование на девайсе.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h45":{
    "theme":"h",
    "question":"Что такое элемент <canvas>? И для чего он используется?",
    "answer":" Переводится как холст. Можно использовать для вставки изображений, градиентов и сложной анимации. А также он создает область, где при помощи JS можно рисовать объекты, преобразовывать их и изменять свойства. По сути он нужен для отрисовки графики.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h46":{
    "theme":"h",
    "question":"Что такое <svg> и <canvas>?",
    "answer":"SVG - это язык разметки масштабируемые векторные графики созданный консорциумом всемирной паутины или W3C и входящий в подмножество расширяемого языка разметки XML, предназначен для описания двумерной векторной и смешанной векторно-растровой графики в формате xml, поддерживает как неподвижную так и анимированную интерактивную графики или если говорить в контексте разработки то декларативную и скриптовую. Canvas - это HTML элемент использующийся для рисования графики средствами языков программирования. В WEB разработке таким языком является JavaScript, его можно использовать для рисования графиков создание коллажей, анимации, редактирования и анализа изображений.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h47":{
    "theme":"h",
    "question":"Разница между <canvas> и <svg>?",
    "answer":"Вопрос является открытым,поэтому постарайтесь запомнить несколько вариантов. Например: Canvas  - это одиночный дом элемент, а SVG - это набор элементов; canvas - это скриптовый язык, в то время как svg - это язык разметки; canvas используется для растровой графики,а  svg для векторной; у первого нет своего отдельного формата, а  svg изображение можно сохранить в отдельный файл соответствующем расширением; Canvas поддерживает различные события, а svg нет; Canvas с изображением нельзя сжимать, в то время как svg изображения поддаются сжатию.",
    "codeexample":"",
    "images":["https://qunee.com/attachments/2949237/3178625.png","https://qunee.com/attachments/2949237/3178624.png","https://qunee.com/attachments/2949237/3178623.png"],
    "checked":""
  },
  "h48":{
    "theme":"h",
    "question":"В каких случаях лучше использовать <canvas>s, а в каких <svg>?",
    "answer":"Canvas следует использовать для редактирования изображений: обрезки, изменения размеров, применения различных фильтров по типу яркости, контраста и т.д., создания растровой графики, визуализации данных, создания фракталов и графиков функций, анализа изображений, а также создания игровой графики такой как спрайты и фоны. SVG следует использовать для создания пользовательских интерфейсов веб-приложений независимых от разрешения экрана, высоко интерактивных анимированных пользовательских интерфейсов, графиков и диаграмм или редактирования векторных изображений.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h49":{
    "theme":"h",
    "question":"Плюсы и минусы <canvas> и <svg>?",
    "answer":"Плюсы canvas: 1.Высокая производительность при отрисовке любых 2D эффектов., 2. Стабильная производительность которая падает только в случаях увеличения разрешения изображений. Стабильность обеспечивается тем что работа происходит именно с пикселями. 3. Полученное изображение можно сохранить PNG или JPG файл. 4. Canvas лучше всего подходит для создания растровой графики редактирование изображений и операций требующих манипулирования на уровне пикселей. Минусы canvas: 1. Отрисовка основана на пикселях. 2. Не существует API для анимации приходится прибегать к использованию таймеров и других событий для обновления. 3.Слабые возможности по рендерингу текста. 4.Canvas - это не самый оптимальный вариант графики когда доступность имеет решающее значение. Холст представляет собой поверхность для рисования в выбранном контексте, то есть 2D или 3D, можно указать альтернативный контекст внутри элемента canvas, который будет показан в браузере при невозможности отображения графики. Кроме того можно выполнить проверку доступности выбранного canvas API с помощью JavaScript. На основе этого обеспечивается различная функциональность для пользователей браузеров с различной поддержкой canvas, но сам по себе этот механизм не прост для интеграции.  Плюсы svg: 1. Нет зависимости от разрешения svg, лучше подходит для кроссплатформенных пользовательских интерфейсов, так как позволяет масштабировать изображение при различных разрешениях экрана. 2. svg очень хорошо поддерживает анимацию, элементы могут быть анимированы с использованием описательного синтаксиса или с помощью JavaScript. 3. Можно получить полный контроль над каждым элементом используя SVG Dom API в JavaScript. 4. svg  хранится в формате xml, что представляет больше возможностей браузерам по обеспечению доступности svg документов по сравнению с canvas, таким образом svg выглядит лучшим решением для пользовательских интерфейсов веб-приложений. Минусы svg: 1. Низкая скорость рендеринга при увеличении сложности документа, так как используется Dom модель. 2. Не подходит для таких приложений как игры. Лучшим выбором будет именно комбинация из canvas и svg, так как каждыеских задач.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h50":{
    "theme":"h",
    "question":"Для чего нужен атрибут autocomplete?",
    "answer":"Этот атрибут помогает заполнять поля форм текстом который был введён в них ранее, по сути это нативная поддержка автозаполнения. Значения сохраняются и предоставляются самим браузером, при этом данное автозаполнение исходя из безопасности может отключаться пользователям в настройках браузера, после чего не может управляться атрибутом autocomplete через HTML. Если же говорить о принудительном выключении автозаполнения в разметке, то autocomplete принимает два аргумента - это on - включает функцию автозаполнения текста и off - отключает автозаполнение. Это значение обычно используется для отмены сохранения в браузере важных данных таких, как, например, пароли и номера банковских карт, а также редко вводимых или уникальных данных, например, капча.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h51":{
    "theme":"h",
    "question":"Что такое элемент <output> в HTML5?",
    "answer":"Элемент output требуется, когда нужно отобразить сумму двух введённых чисел в виде текста. В примере: есть два поля для ввода и нужно сложить числа из этих полей, после чего отобразить их сумму в виде текста. Для этого на тег формы добавляется специальный атрибут oninput данные с которого автоматически передаются в тег output. Также можно использовать атрибут форм для повышения читаемости, а для преобразования значений используется JS метод parseInt. ",
    "codeexample":"<form onsubmit=\"return false\" oninput=\"o.value = parseInt(a.value) + parseInt(b.value)\"> \n\t<input name=Ma\" type=\"number\"> +\n\t<input name=\"b\" type=\"number\"> =\n\t<output name=\"o\" />\n</form>\n\n// Using for\n<output name=\"o\" for=\"a b\"></output>",
    "images":[],
    "checked":""
  },
  "h52":{
    "theme":"h",
    "question":"Что такое свойство valueAsNumber?",
    "answer":"JavaScript свойство valueAsNumber для полей формы, в частности для number date и  range, возвращает значение в виде числа, а не строки, то есть больше нет необходимости использовать parseInt или parseFloat, данные автоматически суммируется или вычитаются без необходимости их приведения к числовому типу.",
    "codeexample":"<form onsubmit=\"return false\" oninput=\"o.value = a.valueAsNumber + b.valueAsNumber\">\n\t<input name=\"a\" id=\"a\" type=\"number\" step=\"any\"> +\n\t<input name=\"b\" id=\"b\" type=\"number\" step=\"any\"> =\n\t<output name=\"o\" for=\"a b\"></output>\n</form>",
    "images":[],
    "checked":""
  },
  "h53":{
    "theme":"h",
    "question":"Что такое атрибут target? Какие значения он принимает?",
    "answer":"Атрибут target используется в связке с тегом ссылки по умолчанию. При переходе по ссылке документ открывается в текущем окне или фрейме, при необходимости это поведение можно изменить атрибутом target. Все значения данного атрибута начинаются с нижнего подчёркивания, но принимает target четыре основные значения - это _blank: загружает страницу в новое окно браузера; _self: загружает страницу в текущее окно; _parent: загружает страницу в frame-родитель или, если фреймов нет, то значение отрабатывает как _self; и _top: отменяет все фреймы и загружает страницу  в полном окне браузера, если фреймов нет то это значение работает как _self. Чаще всего в проектах используется атрибут target со значением _blank.",
    "codeexample":"",
    "images":["https://velog.velcdn.com/images/sweetpumpkin/post/83ddf96a-d56a-45a4-9bd9-3422de0f871e/image.png"],
    "checked":""
  },
  "h54":{
    "theme":"h",
    "question":"Что такое ApplicationCache в HTML5?",
    "answer":"Доступность приложения оффлайн становится всё более актуальной фичей для веб-приложений. Все браузеры по умолчанию имеют механизмы кэширования, однако не все они надёжные и работают ожидаемо. HTMLl5 устраняет некоторые из этих нюансов с помощью интерфейса ApplicationCache. Кэш приложения позволяет разработчику указать, какие файлы браузер должен кэшировать и сделать доступными для оффлайновых пользователей. Приложение будет работать корректно, даже если пользователь нажимает кнопку “обновить” находясь в автономном режиме. Использование интерфейса кэша дают приложению три важных преимущества: 1. Автономный просмотр: пользователи могут использовать сайт целиком находясь в оффлайне; 2. Скорость: ресурсы кэшируются локально, поэтому загружается быстрее; 3. Снижение нагрузки на сервер: браузер загружает с сервера только изменённые ресурсы.",
    "codeexample":"",
    "images":["https://www.codecompiled.com/wp-content/uploads/2015/04/HTML-APP-CACHE.png"],
    "checked":""
  },
  "h55":{
    "theme":"h",
    "question":"Для чего используется элемент <picture>?",
    "answer":"Тег picture используется, когда для разных устройств или вариантов отображения нужны разные картинки. Он служит контейнером для одного или более элементов source и одного элемента img для обеспечения оптимальной версии изображения для разных размеров экрана. Одна и та же страница может быть открыта на разных устройствах и браузерных окнах разной ширины. У телефона небольшой экран и было бы отлично не загружать полноразмерные картинки с большим разрешением. Как раз для решения такой задачи и служит тег picture: браузер рассмотрит каждый из дочерних элементов source и выберет один соответствующий лучшему совпадению, чтобы выбрать оптимальное изображение. User agent анализирует атрибуты SRC, media и type элемента source и выбирает совместимое изображение, которое наилучшим образом соответствует текущему макету страницы и характеристикам устройства отображения.",
    "codeexample":"<picture>\n\t<source media=\"(min-width: 1024px\" srcset=\"https://picsum.photos/600/600\">\n\t<source media=\"(min-width: 768px\" srcset=\"https://picsum.photos/300/300\">\n\t<source media=\"(min-width: 360px\" srcset=\"https://picsum.photos/100/100\">\n\t<img src=\"https://picsum.photos/300/300\" alt=\"Just an image\" />\n</picture>",
    "images":[],
    "checked":""
  },
  "h56":{
    "theme":"h",
    "question":"Что такое srcset? Как работает srcset?",
    "answer":"Srcset - это атрибут для элемента картинки, который позволяет удобно работать с отзывчивыми изображениями. Атрибуты srcset можно использовать, если требуется предоставить пользователям разные изображения в зависимости от ширины экрана их устройств. В srcset содержатся URL изображений и сведения об их ширине, браузер выберет из предоставляемого ему набора изображений то, что подходит лучше всего, причём если у пользователя имеется ретина дисплей с повышенной плотностью пикселей, браузер это учтёт при выборе изображения. Атрибуты srcset содержат список URL изображений, за которыми следуют сведения о ширине изображения, пары URL/ширина разделены запятыми. Браузер автоматически выберет наилучшее изображение, руководствуясь сложным набором критериев, в которые входит то, изображение какого размера выводятся у пользователя и то, каков текущий размер в области просмотра или имеется ли у пользователя дисплей высокого разрешения.",
    "codeexample":"",
    "images":["https://webformyself.com/wp-content/uploads/2020/53/1.png"],
    "checked":""
  },
  "h57":{
    "theme":"h",
    "question":"Как семантически верно сверстать навигационное меню?",
    "answer":"Достаточно запомнить основную структуру <nav>, <ul>, <li>, <a>. В контейнер <nav> помещаются основные ссылки, по которым пользователь сможет быстро перейти на нужный раздел сайта. Внутри <nav> используется тег списка <ul>. Поскольку элементы меню однотипные по смыслу и связаны между собой. Каждый элемент списка - это <li>, а внутри каждого тега <li> находится ссылка <a>, где определён нужный адрес страницы.",
    "codeexample":"<nav class=\"menu\">\n\t<ul>\n\t\t<li><a href=\"#\">Главная</a></li>\n\t\t<li><a href=\"#\">О нас</a></li>\n\t\t<li><a href=\"#\">Контакты</a></li>\n\t</ul>\n</nav>",
    "images":[],
    "checked":""
  },
  "h58":{
    "theme":"h",
    "question":"Что такое <iframe>?",
    "answer":" iframe или сокращение от Inline Frame то есть встроенный фрейм - это контейнер который находится внутри обычного документа и позволяет вставить любой HTML документ из другого источника часто Этот документ интерактивный например Карта видео или пост и соцсети содержимое внутри области существует независимо от окружающей страницы сам контейнер обычно называют фреймом внешний вид фрейма и его положение на странице можно задать через CSS Однако стилизация поддаётся именно фрейм а не его содержимое также данный тег поддерживает довольно много атрибутов которые помогают Как настраивать его внешний вид так и взаимодействие к основным можно отнести width и height ширина и высота служат для задания размеров src содержит ссылку на встраиваемый объект sendbox включает дополнительный набор ограничений для содержания в элементе alowfullscreen разрешает разворачивать фрейм на весь экран и frameborder определяет отображать границу фрейма или нет.",
    "codeexample":"<iframe\n\tid=\"inlineFrameExample\"\n\ttitle=\"Inline Frame Map\"\n\twidth=\"560\"\n\theight=\"400\"\n\tframeborder=\"1\"\n\tallowfullscreen=\"true\"\n\tsrc=\"https://yandex/ru/map-widget/v1/-/CDFerWEF0A\"\n></iframe> ",
    "images":[],
    "checked":""
  },
  "h59":{
    "theme":"h",
    "question":"Для чего используются тэги <sub> и <sup>?",
    "answer":"Теги sub и sup относятся к текстурным тегам, однако чаще они используются для определения отдельных символов, а не слов. Их применяют для указания единиц измерения, написания простых формул, как математических, так и химических, а также выделения специфических элементов тэг sup  - это сокращение от Superscript отображает текст в виде верхнего индекса, а тег sub - это сокращение от Subscript и он обозначает текст в виде внешнего индекса. Для создания более сложных формул, например с несколькими степенями или математическими вычислениями, эти теги можно вкладывать друг друга. ",
    "codeexample":"",
    "images":["https://avatars.mds.yandex.net/i?id=ff353219a0f10889572b92ea9ee63992_l-7086399-images-thumbs&n=13"],
    "checked":""
  },
  "h60":{
    "theme":"h",
    "question":"Как можно скрыть элемент разметки не используя CSS и JS?",
    "answer":"Для того, чтобы скрыть элемент на странице, существует очень много подходов. Это можно сделать через CSS используя display:none, visibility:hidden или даже opacity. Также элемент прячут с помощью JavaScript либо с помощью добавления класса со  скрывающими свойствами либо удалением его из дом дерева. Но дополнительно убрать элемент со страницы можно и с помощью атрибута hidden прямо в HTML разметке. Это отличный вариант для тех случаев, когда не подходят opacity или visibility. Следует отметить, что это не лучшая практика - влиять на внешний вид страницы через разметку, но иногда это именно то, что нужно. По сути, это display:none именно так он описан в браузерных стилях. Поскольку атрибут hidden глобальный, его можно добавить к абсолютно любому тегу, чтобы спрятать его от пользователя. Важно знать, что тег спрятаный при помощи атрибута hidden становится невидимым не только для пользователя но и для скринридеров.",
    "codeexample":"",
    "images":["https://html-tuts.com/wp-content/uploads/2023/02/How-to-hide-text-in-HTML-code-Method-1-using-the-html-hidden-global-attribute-1080x608.jpg.webp"],
    "checked":""
  },
  "h61":{
    "theme":"h",
    "question":"Разница между <meter> и <progress>?",
    "answer":"Элемент meter определяет собой числовое, возможно дробное значение в известном диапазоне. Этот элемент не подходит для измерения чего-то вроде температуры, поскольку она не имеет фиксированного диапазона. Для использования данного тега должно быть известно максимальное значение, однако meter может, например, использоваться для отображения занятого места на жёстком диске. Дополнительно у данного тега на UI есть различные цветовые обозначения в зависимости от наполненности шкалы. Элемент progress используется для отображения хода выполнения задачи. В отличие от элемента meter, прогресс описанный в progress может быть не окончательным, например можно написать, что задание выполняется, но неизвестно, когда задача будет выполнена до конца.",
    "codeexample":"",
    "images":["https://media.geeksforgeeks.org/wp-content/uploads/20210818180323/progressbar.gif","https://media.geeksforgeeks.org/wp-content/uploads/20210818180849/meter.png"],
    "checked":""
  },
  "h62":{
    "theme":"h",
    "question":"Как можно сгруппировать опции внутри тэга <select>?",
    "answer":"Тег <select> представляет из себя элемент с выпадающим списком опций, каждая опция оборачивается в специальный тег <option>. Для того, чтобы сгруппировать несколько опций внутри <select>, можно использовать тег <optgroup> который и предназначен для решения данной задачи. Он указывается внутри тега <select> и в свою очередь оборачивает один или несколько элементов  <option>. Использование <optgroup> добавляет некоторые ограничения, а именно: нельзя вкладывать один <optgroup> в другой. Распространённые атрибуты, которые используются с данном тегом - это label -  добавляет обобщающий заголовок для сгруппированных опций disabled - находящиеся внутри группы опции станут недоступны для выбора.",
    "codeexample":"<form action=\"/action_page.php\">\n\t<label for=\"skills\">Choose a Skill:</label>\n\t<select name=\"skills\" id=\"skills\">\n\t\t <optgroup label=\"FrontEnd\">\n\t\t\t<option value=\"Angular\">Angular</option>\n\t\t\t<option value=\"React\">React</option>\n\t\t</optgroup>\n\t\t<optgroup label=\"Backend\">\n\t\t\t<option value=\"Java\">Java</option>\n\t\t\t<option value=\"PHP\">PHP</option>\n\t\t</optgroup>\n\t</select>\n\t<br><br>\n\t<input type=\"submit\" value=\"Submit\">\n</form>",
    "images":["https://res.cloudinary.com/practicaldev/image/fetch/s--VjTTwQ_C--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3fit9vrbt79szusx1jaj.png"],
    "checked":""
  },
  "h63":{
    "theme":"h",
    "question":"Что такое скринридер?",
    "answer":"Данный вопрос больше относится к доступности, чем к HTML, тем не менее доступность тесно связана с семантикой и валидностью разметки. Сайтами и приложениями пользуются разные люди. Кто-то может делать это с любого устройства, другим же нужны вспомогательные технологии. Вспомогательные технологии - это такие программы и устройства, которые упрощает взаимодействие пользователей с особыми потребностями с контентом, например: выносные кнопки, трекболы, брайлевские дисплеи, экранные лупы, скринридеры. Скринридер - это программа, которая превращает контент интерфейсов в речь или шрифт брайля. Другие названия: программы экранного доступа или чтения, программа чтения с экрана и экранное считывающее устройство. Она нужна людям со слепотой и слабовидящим, а также пользователем с когнитивными особенностями, которым легче воспринимать информацию на слух, например людям с дислексией. Слабовидящие пользователи могут сочетать скринридеры с другой вспомогательной технологией, например с экранной лупой она увеличивает контент на экране и тоже его озвучивает если это нужно.",
    "codeexample":"",
    "images":["https://www.ionos.ca/digitalguide/fileadmin/DigitalGuide/Screenshots_2018/EN-Screenreader.png","https://www.bobrlife.by/wp-content/uploads/2020/03/44b4d13c-96c5-4c54-a169-a140223bb9671.jpg"],
    "checked":""
  },
  "h64":{
    "theme":"h",
    "question":"Как можно изменить форму картинки или HTML элемента?",
    "answer":"Для данной задачи есть свойство clip-path. Оно создаёт ограниченную область, которая определяет, какая часть элемента должна быть видимой, а обрезанная область - это траектория, определяемая либо как внутренняя ссылка, либо как внешний SVG, либо как фигура. Существует два способа использования clip-path: 1. На CSS, в этом случае доступны разные фигуры по типу polygon, circle, ellipse, inset и так далее, преимущество этого подхода заключается в лёгком синтаксисе, а также возможности использования относительных единиц. 2. На SVG - в данном варианте в качестве альтернативы можно создать фигуру с помощью SVG, а затем обрезать элемент по этой фигуре с помощью специального синтаксиса. К преимуществам данного подхода можно отнести: лучшую браузерную поддержку по сравнению с CSS, а также то что обрезку можно выполнять сложными фигурами, а не ограниченным набором.",
    "codeexample":"",
    "images":["https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/08/s_1C7AD0A4850094E4D2D26A3CFDC9C88A0039A9E3AB842A383CDFC6264774BE81_1629785847040_5.png?resize=1536%2C864&ssl=1","https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/08/s_1C7AD0A4850094E4D2D26A3CFDC9C88A0039A9E3AB842A383CDFC6264774BE81_1629785777260_2.png?resize=1536%2C864&ssl=1"],
    "checked":""
  },
  "h65":{
    "theme":"h",
    "question":"Чем отличается <article> от <section>?",
    "answer":"Элемент article задаёт содержание сайтов вроде “новости”, “статьи”, “записи блога”, “форумы” и так далее. Если немного абстрагироваться, то можно сказать, что это специальный вид section, который обозначает независимую и самодостаточную часть страницы. На его месте можно использовать section, но article добавляет более семантическое значение. section  немного похож на обычный div, так как используется, как контейнер, но он уже имеет особое семантическое значение: объекты, которые располагаются внутри него объединены общим смыслом. section задаёт раздел документа, может применяться для блока новостей, контактной информации, глав текста, вкладок в диалоговом окне и так далее, раздел обычно содержит заголовок, в отличие от article, тег section допускается вкладывать друг в друга также этот элемент служит для разбивки текста на разделы.",
    "codeexample":"",
    "images":["https://front-end.su/images/div-section-article.png"],
    "checked":""
  },
  "h66":{
    "theme":"h",
    "question":"Расскажите об особенностях стилизации <svg>?",
    "answer":"Стилизация SVG отличается от стилизации стандартных HTML элементов. SVG  основан на XML и стилевые свойства отличаются по названию. Два основных элемента или атрибута которые используются для стилизации - это заливка fill и обводка stroke. fill - это альтернатива background-color, а stroke - это аналог свойства border, с помощью него можно менять цвет основной линии, на их базе строятся дополнительные свойства по типу stroke-width, stroke-linecap, stroke-opacity, fill-opacity и так далее, изображение в формате SVG можно стилизовать напрямую в разметке, а также используя соответствующие селекторы делать это в CSS файлах. Наибольшая особенность связана со SVG спрайтами: если они используются, то стилизовать SVG  можно только в разметке. Также не получится динамически изменить свойства SVG с помощью JavaScript.",
    "codeexample":"<?xml version=\"1.0\" standalone=\"no\"?>\n<svg\n\t width=\"200\"\n\t height=\"150\"\n\t xmlns=\"http://www.w3.org/2000/svg\"\n\t version=\"1.1\">\n\t<path\n\t\td=\"M 10 75 Q 50 10 100 75 T 190 75\" \n\t\tstroke=\"black\"\n\t\tstroke-linecap=\"round\"\n\t\tstroke-dasharray=\"5,10,5\"\n\t\tfill=\"none\"\n\t/>\n\t<path\n\t\td=\"M 10 75 L 190 75\" \n\t\tstroke=\"red\"\n\t\tstroke-linecap=\"round\"\n\t\tstroke-width=\"1\"\n\t\tstroke-dasharray=\"5,5\"\n\t\tfill=\"none\"\n\t/>\n</svg>",
    "images":["https://help.pilotems.com/beta/ru/Content/Resources/Images/note-show.png"],
    "checked":""
  },
  "h67":{
    "theme":"h",
    "question":"Разница между кнопкой и ссылкой в HTML?",
    "answer":"По-другому этот вопрос может звучать, как “назовите особенности кнопок и ссылок”. Из-за дизайнов, где ссылка может выглядеть как кнопка и наоборот кнопка как ссылка, из-за JavaScript, который может добавить логику на любой элемент, границы между этими элементами стираются. Однако, если говорить о нативных возможностях каждого из них, то они довольно разные. К особенностям кнопки можно отнести следующие: кнопка получает фокус с клавиатуры по умолчанию, она способна отправлять данные формы на сервер и очищать форму, блокироваться с помощью атрибута disabled, добавляет подсказку скринридеру с помощью неявного атрибута role=\"button\", а также показывает состояние focus, hover, active, disable. Если добавить JavaScript, то кнопка идеальный элемент для: открывания модального окна, вызова всплывающего меню и переключения интерфейса. Что же касается ссылки то она может создавать гипертекст и сеть онлайн ресурсов перевести пользователя на новую страницу или окно, изменять url-адрес вызывать браузерные перерисовки и перезагрузки переходить по якорям внутри страницы, способна принимать focus по умолчанию с помощью атрибута href, регистрировать клик по нажатию клавиши enter, не блокироваться, в отличие от кнопки. Однако, её также можно сделать не активной с помощью tabindex =”-1” и area-hidden=”true”. Итого, главное различие между ссылкой и кнопкой - это то, что ссылки перемещают пользователя на новый ресурс, то есть переносят его из текущего контекста, кнопка же переключает что-то в интерфейсе или вызывает новый контент в том же самом контексте.",
    "codeexample":"",
    "images":["https://i0.wp.com/miro.medium.com/v2/resize:fit:1400/1*am9jlbvMtHMUMd5900esvQ.jpeg?ssl=1"],
    "checked":""
  },
  "h68":{
    "theme":"h",
    "question":"Для чего используется атрибут decoding?",
    "answer":"Атрибут decoding используется в связке с тегом img, то есть с картинкой. Данный атрибут позволяет указать, как браузер должен декодировать изображение, он принимает три основных значения, которые определяют основной механизм: async - декодирование происходит вне основного потока, sync - декодирование идёт в основном потоке и auto - декодирование осуществляется по логике самого браузера. Следует отметить, что decoding и lazyload - это разные вещи decoding связан с тем, как браузер декодирует данные картинки, то есть картинка сначала загружается в кодированном виде, потом декодируется, и только потом отображается. По умолчанию декодирование происходит в основном потоке, а это может мешать другим процессам происходящим на странице с помощью decoding=”async” можно сообщить браузеру, что изображение может быть интерпретировано асинхронно, то есть декодировано в параллельном потоке и не должно влиять на основной поток рендера страницы. Здесь важно отметить, что в процессе загрузки браузер проскакивает область изображения, не зная какого размера нужно оставить место для него, и рендерит то, что идёт ниже. Одновременно с этим в параллельным потоке он подгружает картинку, узнаёт о её размерах и вписывает её в страницу, и когда изображение подгружается, вёрстка может скакать. Это в свою очередь негативно влияет на CLS или content layout shift метрику и об этом важно помнить когда планируется применять decoding.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h69":{
    "theme":"h",
    "question":"Для чего используется атрибут enterkeyhint?",
    "answer":"Данный атрибут используется в связке с элементами формы, точнее тегами input и textarea. Также его можно добавлять на элементы с атрибутом contenteditable, который превращает их в редактируемые. Enterkeyhint - это атрибут, который указывает, какое местку действия или значок представить для клавиши ввода на виртуальных клавиатурах пользователя. Он позволяет авторам настраивать представление клавиши ввода, чтобы сделать её более полезной для конечного пользователя. Enterkeyhint может принимать одно из семи основных назначений: enter - обычно означает вставку новой строки; done - означает что вводить больше нечего и редактор методов ввода будет закрыт; go - означает перевод пользователя к цели набранного текста; next - переводит пользователя в следующее поле, которое будет принимать текст; previous - переводит пользователя в предыдущие поле, которое также принимает текст; search - переводит пользователя к результатам поискам введённого текста и sent - отправляет введённый текст.",
    "codeexample":"",
    "images":["https://xhtml.ru/xyout/wp-content/uploads/2020/04/enterkeyhint-scaled.jpg"],
    "checked":""
  },
  "h70":{
    "theme":"h",
    "question":"Для чего используют атрибут novalidate?",
    "answer":"Атрибут novalidate предназначен для отключения нативной валидации формы на стороне браузера, каждое поле формы, которое заполняет пользователь, может иметь чётко указанный тип и правила ввода. В момент, когда пользователь отправляет форму, браузер проверяет правильность заполненных данных, блокируя отправку в случае ошибки и показывая подсказку там, где она была допущена. Например, поля с атрибутом required должны быть обязательно заполнены и браузер укажет, если пользователь вдруг какой-нибудь из них пропустил. Атрибут  novalidate говорит браузеру не проверять поля и не препятствовать отправке формы, так как иногда подобное поведение бывает нежелательным, например, форма проверяется с помощью JavaScript и нужно избегать конфликтов с браузерной валидацией, в том числе и убрать всплывающие подсказки чтобы показать вместо них свои кастомные.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "h71":{
    "theme":"h",
    "question":"Для чего используют атрибут inputmode?",
    "answer":"Атрибут inputmode говорит браузеру на устройствах с экранной клавиатурой, какой набор символов показать. Приводит данные в конкретное поле, определяется данный атрибут для элементов input или textarea важно понимать разницу между атрибутом type и атрибутом inputmode. inputmode только подсказывает браузеру какой набор символов предложить пользователю для взаимодействия с полем ввода, в то время как type устанавливает тип данных, которые пользователь может ввести в поле ввода. ",
    "codeexample":"",
    "images":["https://uxcellence.com/img/2014/keyboard_screencaps_all.png"],
    "checked":""
  },
  "h72":{
    "theme":"h",
    "question":"Для чего используется атрибут pattern?",
    "answer":"Атрибут pattern определяет регулярное выражение, которому должно соответствовать значению элементов формы. Если же введённое значение не соответствует указанному паттерну, то input поля будет подсвечено, как не валидное. Важным моментом является также то, что если присутствует атрибут pattern, то форма не будет отправляться, пока поле не будет заполнено правильно. Атрибут паттерн является атрибутом для полей ввода с типом tel, text, e-mail, url, password, search. В примере: браузер проверит перед отправкой формы, что пароль не меньше шести символов в длину, и если это не так, то input  подсветится и появится всплывающая.",
    "codeexample":"",
    "images":["https://doka.guide/html/pattern/images/chrome_tooltip-1078w.webp"],
    "checked":""
  },
  "h73":{
    "theme":"h",
    "question":"Почему стоит использовать семантические теги в верстке?",
    "answer":"Семантическая вёрстка - это подход к разметке, который опирается не на внешний вид сайта, а на смысловое предназначение каждого блока и логическую структуру документа. Использовать семантические теги можно по многим причинам, основные из которых это 1. Сделать сайт доступным, для незрячих людей основной инструмент для просмотра сайтов не браузер, которые отрисовывает страницу, а скринридер, который читает текст со страницы вслух. Этот инструмент зачитывает содержимое страницы, и семантическая структура помогает ему лучше определять, какой сейчас блок, а пользователю понимать, о чём идёт речь. 2. Чтобы сайт был выше в поисковиках. Компании, которые создают поисковики, не разглашают правила ранжирования, но известно, что наличие семантической разметки страниц помогает поисковым ботам лучше понимать, что находится на странице и, в зависимости от этого, ранжировать сайты в поисковой выдаче. 3. Семантика прописана в стандартах. Многие разработчики по старинке используют конструкции типа <div id=”nav”> для обозначения навигации или других структурных элементов на странице, тем временем, в стандарте HTML5 появилось множество семантических тегов, которые рекомендуется использовать для разметки страниц вместо стандартных div и span. В спецификации для каждого тематического элемента описаны его роль. 4. Семантика удобна с точки зрения разработки, помимо плюсов для пользователей сайта и поисковых ботов, огромным плюсом семантической верстки является удобство её чтения другими разработчиками.",
    "codeexample":"",
    "images":["https://delaemsait.info/wp-content/uploads/2019/12/html5-e1575378985564.jpg"],
    "checked":""
  },
  "h74":{
    "theme":"h",
    "question":"Для чего используется тэг <label>?",
    "answer":"Тег <label> определяет текстовую метку для элементов textarea, input, Селект а также checkbox и radiobutton по своему виду данная метка ничем не отличаются от обычного текста, сверстанного с помощью span, однако, у неё есть одна важная отличительная особенность: при пользовательском клике по тексту расположенному внутри элемента label элемент формы, который связан с данным лейблом становится активным, т.е. получает фокус. Чтобы определить, к какому элементу формы относится текущая метка, можно воспользоваться одним из двух подходов: первый - можно использовать атрибут for для <label>, значение атрибута for должно быть эквивалентно значению атрибута id элемента формы, к которому будет относиться метка; второй - просто поместить элемент формы внутрь тега <label> и в этом случае атрибут for можно не использовать.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c75":{
    "theme":"c",
    "question":"Что такое CSS? И для чего он используется?",
    "answer":"CSS (Cascading Style Sheets - каскадные таблицы стилей) — это язык стилей, используемый для описания внешнего вида и форматирования документов, написанных на HTML. То есть предназначены для добавления стилей на веб-страницу.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c76":{
    "theme":"c",
    "question":"Что такое CSS-правило?",
    "answer":"CSS-правило формируется из 2х основных составляющих: 1) селектор - указывает на HTML-элементы, к которым применяется стиль. Селектор определяет, какие элементы на странице будут затронуты данным правилом; 2) блок объявления - находится в фигурных скобках {} и содержит одно или несколько свойств и их значения.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c77":{
    "theme":"c",
    "question":"Варианты добавление CSS стилей на страницу?",
    "answer":"4 основных способа: Инлайновые стили (на конкретный элемент); Внутренние стили (в теге style внутри head); Внешние стили (файл с CSS-стилями добавляется при помощи тега link в head); Импортированные (импорты внутри файлов стилей @import).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c78":{
    "theme":"c",
    "question":"Типы позиционирования в CSS?",
    "answer":"5 основных типов: static (присваивается всем элементам по умолчанию - все элементы в основном потоке документа), relative (элемент можно перемещать относительно его первоначального места в документе, сам элемент остается в основном потоке), absolute ( элемент вырывается из основного потока и создает отдельные поток, позиционируется относительно ближайшего предка, у которого позиционирование не static, либо относительно края видимой области страницы), fixed (позиционирование только относительно окна браузера), sticky (внутри видимой области браузера ведет себя как fixed, при дальнейшем прокручивании скроллится вместе с родителем)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c79":{
    "theme":"c",
    "question":"Блочная модель CSS?",
    "answer":"Блочная модель CSS (Box Model) описывает, как браузеры рассчитывают размеры и размещение элементов на веб-странице. Она определяет, как элементы в документе отображаются и взаимодействуют друг с другом. В нее входят следующие компоненты: сам контент (внутреннее пространство элемента), padding (внутренний отступ), border (граница - линия, окружающая контент и внутренние отступы), margin (внешний отступ). Таким образом суммарный размер элемента будет состоять из данных компонентов. (Чтобы размер элемента равнялся именно заданному значению, то используется свойство box-sizing: border-box).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c80":{
    "theme":"c",
    "question":"Что такое селектор? И какие селекторы существуют?",
    "answer":"Это часть CSS-правила, которое сообщает браузеру, какому элементу/ам будет применен стиль. Все селекторы делятся на две большие группы: простые и составные. Простые (указан один вариант селектора): class, id, tag, универсальный (*), селектор атрибута. Составной селектор состоит из нескольких простых, разделенный либо пробелом либо другим символом: групповые селекторы (через ,), селектор потомка (через пробел вся цепочка: “div p”), селектор только дочернего элемента (знак >: “li > a”), селектор псевдокласса, псевдоэлемента.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c81":{
    "theme":"c",
    "question":"Что такое специфичность селектора? Как считать вес селектора?",
    "answer":"Специфичность это способ, с помощью которого браузеры определяют, какие значения css-свойств будут применены к элементу. К одному элементу могут быть применены сразу несколько стилей. И вот какие стили будут отображены в браузере зависит от специфичности, которая базируется на определении веса селектора. Есть 4 основных веса селектора: inline - вес 1000, id - 10, класс/атрибут/псевдокласс - 10, элемент/псевдоэлемент - 10",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c82":{
    "theme":"c",
    "question":"Разница между Reset.css и Normalize.css?",
    "answer":"Так как почти все html-элементы обладают дефолтными стилями, а каждый браузер отображает их по разному, то чтобы во всех браузерах сайт выглядел одинаково, то применяется Reset.css (чтобы сбросить все дефолтные стили) либо Normalize.css (унифицирует отображение во всех браузерах).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c83":{
    "theme":"c",
    "question":"Разница между margin и padding?",
    "answer":"padding это внутренний отступ (от границы блока до контента), margin - это внешний отступ (от границы блока до соседнего блока).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c84":{
    "theme":"c",
    "question":"Разница между display: none и visibility: hidden?",
    "answer":"Оба правила скрывают элементы на странице. Но свойство display: none полностью убирает элемент с html-страницы, из потока документа, из поисковиков, он остается доступным только в DOM-дереве. Правило visibility: hidden оставляет элемент в основном потоке документа, при этом он не виден на странице, а также остается виден для поисковиков.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c85":{
    "theme":"c",
    "question":"Разница между блочным (block) и строчным (inline) элементами?",
    "answer":"Блочный элемент по умолчанию всегда будет занимать всю доступную ширину экрана. Строчный элемент подстраивается под размер его контента. Блочные всегда идут друг под другом, а строчные могут располагаться рядом. Блочным элементам можно задавать ширину и высоту, для строчных это не работает. Блочные воспринимают отступы - margin и padding. Для строчных элементов margin padding сверху и снизу не работают.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c86":{
    "theme":"c",
    "question":"Разница между классом и идентификатором в CSS?",
    "answer":"Обычно для добавления стилей лучше использовать класс, хотя id может быть использован для уникальной стилизации отдельного элемента. id встречается на странице только один раз, является уникальным. У каждого элемента может быть только один id. class может использоваться на нескольких элементах и у каждого элемента может быть несколько классов. Идентификатор имеет высокий вес в спецификации CSS - 100, у класса вес CSS - 10. Это означает, что стили, применяемые через идентификатор, имеют высокий приоритет и могут переопределить стили, заданные через классы или элементы.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c87":{
    "theme":"c",
    "question":"Что такое CSS спрайт? И для чего он используется?",
    "answer":"CSS спрайт — это техника оптимизации загрузки веб-страниц, которая используется для уменьшения количества HTTP-запросов к серверу. CSS спрайт представляет собой одно большое изображение, которое объединяет несколько маленьких изображений. Эти маленькие изображения, как правило, являются графическими элементами интерфейса, такими как иконки, кнопки или фоны. Сначала создается одно большое изображение (спрайт), в котором размещаются все маленькие изображения. Обычно это делается в графическом редакторе или с помощью инструментов автоматизации. В CSS используется свойство background-image для установки спрайта как фона для элементов. Затем с помощью свойства background-position указывается, какая часть спрайта должна быть видима для конкретного элемента. Таким образом, из большого спрайта \"выбирается\" нужная часть для отображения. Плюсы использования: Уменьшение количества HTTP-запросов: Вместо нескольких запросов на сервер за отдельными изображениями, отправляется только один запрос за спрайтом. Это уменьшает нагрузку на сервер и ускоряет загрузку страницы.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c88":{
    "theme":"c",
    "question":"Что такое вендорные префиксы? И для чего они используются?",
    "answer":"Это приставка к css-свойству, которая обеспечивает поддержку данного свойства браузером, в котором оно не внедрено на постоянной основе (в стадии разработке либо тестирования). Это инструмент кросс-браузерной совместимости. Можно автоматизировать процесс добавления префиксов с помощью специальных программ Autoprefixer.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c89":{
    "theme":"c",
    "question":"Что такое псевдоэлементы? И для чего они используются?",
    "answer":"Псевдоэлемент - это ключевое слово, которое добавляется на селектор и позволяет стилизировать определенную часть выбранного элемента. Существует 5 типов: first-letter, first-line, before (вставка контента перед выбранным элементом), after (вставка после), selection (позволяет изменить часть элемента, которая была выбрана пользователем).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c90":{
    "theme":"c",
    "question":"Что такое схлопывание границ (margin collapsing)?",
    "answer":"Это механизм взаимодействия внешних отступов по вертикали, когда у блочных элементов расположенных друг под другом отступы не суммируются, а объединяются между собой, и итоговое расстояние получается равным большему из марджинов. Также взаимодействуют марджины вложенных блоков. Исключения из правил: Флекс-контейнеры и их дети: Внутри flex-контейнеров отступы не схлопываются. Грид-контейнеры и их дети: Внутри grid-контейнеров отступы также не схлопываются. Элементы с overflow, padding, border: Если элемент имеет overflow, padding или border, его отступы не схлопываются.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c91":{
    "theme":"c",
    "question":"Что такое CSS препроцессор?",
    "answer":"Это программа, которая позволяет генерировать css из собственного уникального синтаксиса. Синтаксис препроцессоров обычно проще и удобнее в использовании, чем в нативном css (переменные, вложенность, миксины)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c92":{
    "theme":"c",
    "question":"Что такое z-index? Как формируется контекст наложения?",
    "answer":"Любой элемент в HTML документе может быть на переднем или на заднем плане, по умолчанию порядок наложения равен порядку следования в HTML. Если же позиционирование элементов и их дочерних элементов задано явно, то такие элементы будут прикрывать собой элементы без явно заданного свойства позиционирования. z-индекс учитывается только на явно позиционированных элементах, для не позиционированных элементов он не работает. Если значение z-индекс задано, формируется контекст наложения. Контекст будет сформирован, если: элемент - корневой элемент документа; элемент позиционирован не статически и z-индекс не равен auto; элемент имеет прозрачность не менее 1.  У каждого контекста наложения будет свой корневой элемент в HTML структуре, все дочерние элементы будут добавлены в контекст и займут своё место в порядке наложения. Элемент внизу одного контекста не получится расположить над элементом другого контекста, располагающимся выше по иерархии даже с максимальным  z-индексом.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c93":{
    "theme":"c",
    "question":"Порядок наложения элементов в CSS (Stacking Order)?",
    "answer":"Элементы в HTML имеют объёмную структуру и могут перекрывать друг друга. При отсутствии z-индекса порядок наложения будет следующий (от нижнего к верхнему) : background и  border-элементы, элементы с  z-индекс < 0 и их дочерние элементы, элементы блочного уровня (position = static), float элементы, inline элементы, элементы с  z-индекс = 0/auto, элементы с  z-индекс > 0.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c94":{
    "theme":"c",
    "question":"Как с помощью CSS определить, поддерживается ли свойство в браузере?",
    "answer":"В каскадных таблицах стилей есть специальная директива, которая называется supports. Данная директива позволяет проверить, поддерживает ли браузер свойства, правила или CSS селектор. Правила использования - аналогично с медиа запросами: основной код с помощью фигурных скобок оборачивается в директиву, в директиве в круглых скобках указывается вариант проверки и если условие срабатывает, то будет выполнен css-код написанный в фигурных скобках. Следует отметить, что директива support очень активно используется в подходе progressive enhancement.",
    "codeexample":"",
    "images":["https://frontender.info/supports-will-change-your-life/img/blend-modes-supports-small.jpeg"],
    "checked":""
  },
  "c95":{
    "theme":"c",
    "question":"Как поддерживать страницы в браузерах с ограниченными функциями?",
    "answer":"Вопрос является открытым и ориентируется в первую очередь на опыт разработчика. Некоторые из базовых подходов: обнаружение функций с помощью библиотеки Modernizr, использование CSS директивы support, Autoprefixer для автоматической ставки браузерных префиксов, использование ресурса caniuse.com, чтобы проверить поддержку применения подходов Graceful degradation или Progressive enhancement.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c96":{
    "theme":"c",
    "question":"Как исправлять специфичные проблемы со стилями для разных браузеров?",
    "answer":"Данный вопрос открытый и помогает понять Ваш опыт в браузерной верстке. Поскольку существует разные браузеры, для некоторых свойств в закладываются разные значения. В результате, одна и та же страница может выглядеть по-разному, поэтому применяются различные подходы, чтобы унифицировать начальные стили, а также писать CSS свойства которые будут отрабатывать одинаково. Вот некоторые из таких техник: использование Autoprefixer  для автоматической ставки браузерных префиксов, подключение Reset Css или Normalize.css, в редких и очень специфических случаях можно использовать CSS-хаки, разделение стилей для разных браузеров и их динамическая подгрузка, использование сторонних библиотек по типу Bootstrap или Tailwind CSS, которые уже решают эти проблемы со стилями, регулярное тестирование приложения на специализированных сервисах, как например Browserstack.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c97":{
    "theme":"c",
    "question":"Глобальные ключевые слова в CSS?",
    "answer":"Для всех свойств CSS помимо стандартных значений можно задать значение в виде ключевых слов. В CSS есть четыре глобальных ключевых слова - это initial: у каждого из свойств CSS есть значение по умолчанию, оно применяется ещё до того, как что-либо написано в файле стилей. Ключевое слово initial сбрасывает все указанные значения свойства для конкретного блока до этих самых значений по умолчанию; inherit: CSS свойства делятся на наследуемые и не наследуемые, значение наследуемых свойств применяется не только к элементу для которого прописаны но и для всех вложенных дочерних элементов, это очень удобно, чтобы не писать много одинаковых свойств для разных селекторов перечисляя всех потомков; unset - это ключевое слово ведёт себя по-разному с наследуемыми и не наследуемыми свойствами, с наследуемыми свойствами ключевое слово unset ведёт себя как inherit, а с не наследуемыми свойствами оно ведёт себя как initial; revert - данное ключевое слово сбрасывает значение свойства до указанного в стилях браузера.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c98":{
    "theme":"c",
    "question":"Что такое CSS-атрибут (attr)?",
    "answer":"Функция attr или аббревиатура attribute - это CSS функция которая умеет получать значение любого атрибута элемента, а потом использовать это значение прямо в таблице стилей. Функция работает и с псевдоэлементами, в этом случае возвращается значение атрибута элемента, для которого формируется псевдоэлемент. Функцию attr можно использовать с любым свойством CSS, но поддержка иных кроме content является экспериментальной.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c99":{
    "theme":"c",
    "question":"Что такое перечисление селекторов?",
    "answer":"При помощи перечисления нескольких селекторов через запятую можно избежать дублирования кода. Если в нескольких элементах есть определённые повторяющиеся стили, то вполне допустимо внести эти стили в отдельный блок, после чего в качестве селектора указать несколько классов или тегов, или идентификаторов, перечислив их через запятую. Таким образом описанные стили будут применены сразу к нескольким элементам и нет необходимости повторно писать один и тот же код для каждого.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c100":{
    "theme":"c",
    "question":"Для чего используется ключевое слово currentColor в CSS?",
    "answer":"Ключевое слово currentColor можно использовать в качестве значения для CSS свойства принимающего цвет, то есть оно будет работать для свойств color, background color, box shadow, text shadow и так далее. В качестве примера можно рассмотреть box shadow. Браузер подставит вместо currentColor текущее значение свойства color, то есть красный, таким образом можно соблюдать консистентность или однообразие палитры и, в случае изменения основного цвета, автоматически будут изменены все зависящие, то есть определённые через currentColor цвета.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c101":{
    "theme":"c",
    "question":"Какие псевдоклассы были добавлены в CSS3?",
    "answer":"В спецификацию css-3 было добавлено 7 новых псевдо классов: первый :nth-child(n) - выбирает N-ый дочерний элемент внутри родительского элемента, и метка этого дочернего элемента N может принимать определённое значение или функции; второй :nth-last-child(n) выполняет ту же функцию что и первый но выполняет выборку элементов с конца; третий :last-child(n) выбирает последний дочерний элемент; четвёртый - :only-child(n) выбирает элемент, если он является единственным дочерним элементом родительского элемента; пятый :nth-of-type(n) выбирает элемент N-го типа внутри родительского элемента, N в свою очередь может принимать определённые значения или функции; шестой :first-of-type(n) выбирает первый элемент заданного типа внутри родительского элемента и седьмой :last-of-type(n) выбирает последней элемент заданного типа внутри родительского элемента.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c102":{
    "theme":"c",
    "question":"Какие фильтры есть в CSS?",
    "answer":"CSS позволяет накладывать поверх картинок или фонов различные фильтры, это помогает, например, размыть или обесцветить изображение, сделать его более контрастным. Основное свойство называется filter. Ему в виде значения присваиваются специальные функции, таких функций можно выделить несколько это grayscale - делает изображение чёрно-белым в скобках можно указать значение от 0% до 100%, значение 100 делает изображение полностью чёрно-белым; sepia- это имитация старых изображений, то есть такой своеобразный эффект старины, принимает значение в процентах, которое также указывается от 0 до 100; saturate - насыщенность, позволяет сделать даже блёклое изображение более сочным, в виде параметров принимает проценты, дефолтное значение насыщенности изображение - это 100, а диапазон определяется от 0 до не ограниченного числа; hue-rotate меняет цвета изображение за счёт поворота цветового круга угол поворота указывается в скобках; invert - инвертирует цвет изображения превращая его во что-то похожее на негатив значение передаётся в процентах и варьируется от 0 до 100; brightness меняет яркость изображения, в скобках можно указать любое значение от нуля процентов и выше, значение ноль сделает изображение полностью чёрным значение 100% вернёт изображению исходную яркость; contrast меняет контраст изображения, в скобках можно указать любое значение от нуля процентов и выше, значение ноль сделает изображение полностью чёрным значение 100% вернёт изображению  исходный контраст; blur применяет размытие по Гауссу к изображению, значение в скобках указывает, сколько пикселей будут слиты друг с другом.",
    "codeexample":"",
    "images":["https://cs1.htmlacademy.ru/blog/css/filter/7f482f215540b6a97166e1e76a7c8ed9.png"],
    "checked":""
  },
  "c103":{
    "theme":"c",
    "question":"Для чего используется псевдокласс :invalid?",
    "answer":"Обычно проверку формы перекладывают на JavaScript и в случае, если какие-то данные введены неверно, то на всю форму или на какой-то её конкретный элемент вешается класс, по которому добавляются стили. Однако, помимо динамического добавления классов можно воспользоваться и нативными возможностями CSS, для этого и применяется псевдокласс :invalid. Если говорить в общем, то данный псевдокласс облегчает стилизацию формы и элементов при её невалидности, он находит любые input или form элементы, контент которых не проходит валидацию или проверку в соответствии с типом поля и позволяет легко менять внешний вид полей, что в свою очередь даёт пользователю возможность видеть и исправлять ошибки. В дополнение можно добавить, что помимо псевдокласса :invalid есть псевдокласс :valid, который позволяет стилизовать поля, успешно прошедшие валидацию.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c104":{
    "theme":"c",
    "question":"Расскажите про свойство display в CSS?",
    "answer":"По умолчанию, все элементы HTML бывают блочными и строчными. Но в вёрстке часто бывают ситуации, когда требуется сделать элемент не строчным, а блочным или наоборот, и в таких случаях можно использовать свойство display со значениями block - блочное отображение или inline - строчное отображение. Помимо этих двух значений существует смешанный тип inline-block, то есть срочно-блочное отображение. Также можно использовать none, который полностью скрывает элемент со страницы не удаляя его при этом из HTML разметки. Flex - элемент становится flex контейнером, ведёт себя как блочный, а вложенные элементы становятся flex-элементами. Inline-flex - аналогичен flex, только шириной подстраивается под контент внутри себя. Grid - элемент становится grid контейнером, снаружи grid контейнер ведёт себя как block, дочерние элементы такого контейнера начинают подчиняться правилам grid раскладки. Inline-grid - аналогичен grid, только шириной подстраивается под контент внутри себя, а также table и table-cell или таблица и ячейка таблицы - трансформируют элемент, добавляют ему табличное поведение, которое распространяется на вложенные элементы и на контент внутри.",
    "codeexample":"",
    "images":["https://sitestudiodocs.acquia.com/sites/default/files/images/apply-styles/display-diagram-type-as-shape.svg"],
    "checked":""
  },
  "c105":{
    "theme":"c",
    "question":"В каком случае лучше использовать translate() вместо абсолютного позиционирования?",
    "answer":"Для анимаций лучше всего использовать именно CSS переходы или свойство translate. Всё дело в том, что браузер умеет хорошо его оптимизировать. У translate() большая частота кадров за счёт более быстрого рендеринга, под капотом у себя translate() использует субпиксельную интерполяцию которая работает плавнее и быстрее, что же касается анимации с помощью абсолютного позиционирования и заздания различных точек позиций элементов, здесь для движения используется пиксельная сетка, поэтому могут наблюдаться скачки. Также использование translate позволяет сделать небольшую хитрость в улучшении производительности анимаций - это вынос анимируемых элементов в отдельный слой, чтобы их изменения не затрагивали всё вокруг, делается это с помощью свойства will-change или, как это делалось раньше, transform со значением translateZ(0).",
    "codeexample":"",
    "images":["https://webformyself.com/wp-content/uploads/2022/17/3.png"],
    "checked":""
  },
  "c106":{
    "theme":"c",
    "question":"Что такое плавающие элементы (floats)? Как они работают?",
    "answer":"При применении этого свойства происходит следующее: первое - элемент позиционируется как обычно, а затем вынимается из основного потока документа, после чего он сдвигается влево для left или вправо для right до того, как коснётся либо границы родителя, либо другого элемента float; второе - если пространства по горизонтали не хватает для того чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться; третье - другие непозиционировнные блочные элементы без float ведут себя так, как будто элемента с float нет, так как он убран из основного потока; четвёртое - строки, то есть inline элементы напротив знают о float и обтекают элемент по сторонам. Изначально это свойство было создано для того, чтобы текст мог обтекать изображение слева или справа, отсюда и такие особенности поведения. В последующем float стал использоваться для построения многоколоночных макетов, в данный момент построение многоколоночного макета с помощью float считается устаревшим подходом.",
    "codeexample":"",
    "images":["https://itchief.ru/assets/images/tickets/2014.10/step3_float.png"],
    "checked":""
  },
  "c107":{
    "theme":"c",
    "question":"Расскажите о свойстве pointer-events?",
    "answer":"pointer-events позволяет управлять тем, как элементы будут реагировать на события мыши или прикосновения к сенсорному экрану. Свойство позволяет контролировать когда, как и может ли вообще указательное устройство взаимодействовать с элементом, принимает оно два основных значения это none и auto. None предотвращает событие указателя для элемента hover, active и так далее, в том числе способно отменять и JavaScript событие click. Auto - восстанавливает стандартное взаимодействие указателя с элементом, помимо этих двух ему можно передать значения по типу visiblePainted, visibleFill, visibleStroke, visible и так далее, однако эти значения работают только для SVG элементов. На практике pointer-events можно применять для случаев запрета пользователю клика правой кнопкой мыши по картинкам на сайте,  выключение взаимодействия со страницей во время обработки асинхронных запросов, блокировки любого элемента страницы от взаимодействия с курсором. Из негативных последствий необдуманного использования свойства можно назвать влияние на аналитику, другими словами из-за блокировки взаимодействия с элементом, аналитика может собираться не точно.",
    "codeexample":"",
    "images":["https://res.cloudinary.com/practicaldev/image/fetch/s--ThT7mATI--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://thepracticaldev.s3.amazonaws.com/i/o6nxqormoj09m42v39ty.jpg"],
    "checked":""
  },
  "c108":{
    "theme":"c",
    "question":"Почему не стоит использовать краткую запись свойств CSS?",
    "answer":"Периодически при задании стилей к элементам используется сокращённая запись свойств, с одной стороны, это вполне оправдано, так как уменьшает количество написанного кода, с другой стороны есть проблемы дефолтной стилизации, например есть задача перекрасить пункт кнопки в красный цвет. Для этого можно указать свойство background: red; после чего кнопка изменит свой фон. Мы всего лишь хотим чтобы у нашей кнопки был красный фоновый цвет, но на самом деле, под капотом задаётся целый набор правил. За счёт простого использования краткой записи мы безоговорочно решили, что не хотим использовать фоновое изображение, заодно указав для него: стартовую позицию с левого верхнего края, повторение по осям X и Y,  прокрутку вместе с элементом и так далее. Почти все проблемы баги и регрессии в CSS происходят из-за того, что разработчик делает слишком многое слишком рано, а через некоторое время сталкивается с последствиями этого. Из-за этого факта следует вывод: в CSS нужно делать лишь то, что требуется и ничего более. Именно поэтому краткая форма записи CSS свойств не всегда приемлема.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "c109":{
    "theme":"c",
    "question":"Расскажите о свойстве outline?",
    "answer":"Если говорить просто, то outline немного похож на border. К его особенностям можно отнести то, что свойство не влияет на размеры элемента, а также его можно отодвинуть от границ на любое расстояние. outline  присутствует стандартных стилях браузера для акцента на сфокусированных интерактивных элементах, другими словами размеры не меняются, верстка страницы не ломается, но пользователь наглядно видит, какой элемент в фокусе. outline - это shortcut т.е. короткое свойство для записи сразу нескольких значений. Внутри себя оно содержит свойства:outline-width, outline-style и outline-color. Всё по аналогии со значениями border. outline-width определяет толщину обводки, принимает значение thin, medium, thick, или заздаёт тонкую, среднюю или толстую ширину. Также толщина может быть задана в пикселях, ram и em. outline-style определяется стиль обводки может быть определена как dotted, dashed, solid, double и так далее, outline-color определяет цвет обводки, принимает любое доступное значение цвета, включая ключевые слова transparent, current color и invert.",
    "codeexample":"",
    "images":["https://blog.teamtreehouse.com/wp-content/uploads/2012/10/box-model.png","https://idg.net.ua/blog/wp-content/uploads/border-style-css.png"],
    "checked":""
  },
  "c110":{
    "theme":"c",
    "question":"Назовите псевдоэлементы для подсветки текста?",
    "answer":"В CSS-3 помимо набора стандартных псевдоэлементов появились так называемые псевдоэлементы выделения. Они представляют собой части документа, которым присвоен определённый статус, обычно данные части имеют другой стиль, чтобы подсветить этот статус пользователю, например выбранные части документа обычно выделяются с помощью задания альтернативного цвета фона и переднего плана или световой размывки, чтобы указать их выбранный статус. Существует четыре основных псевдоэлемента выделения - это selection - определяет выделенный текст target-text - определяет текст, на который непосредственно нацелен фрагмент и URL адреса документа. Другими словами, это поисковая строка, которая хранится в URL. spelling-error - содержимое, которое было помечено  User agent, как ошибочное. grammar-error  содержимое которое было помечено User agent как грамматически неверное, следует отметить, что последние два псевдо элемента ещё не поддерживаются браузерами. Все псевдоэлементы выделения могут принимать свойства: color, background-color, cursor, current-color, outline, text-decoration,  text-emphasis-color, text-shadow; все эти свойства можно использовать для стилизации выделенного текста.",
    "codeexample":"",
    "images":["https://www.bram.us/wordpress/wp-content/uploads/2021/02/style-text-to-scroll-fragments-2-1120x677.png"],
    "checked":""
  },
  "j111":{
    "theme":"j",
    "question":"Типы данных в JavaScript?",
    "answer":"8 основных типов: строка, число, bigint, boolean, Symbol(), Object(), null, undefined.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j112":{
    "theme":"j",
    "question":"Разница между == и === (нестрогое/строгое равенство)?",
    "answer":"Нестрогое просто сравнивает значения, строгое дополнительно сравнивает их типы.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j113":{
    "theme":"j",
    "question":"Разница между function declaration и function expression?",
    "answer":"Function Declaration и Function Expression — это два способа определения функций в JavaScript, и между ними есть несколько важных различий: Function Declaration (Объявление функции) - при помощи ключевого слова function; Function Expression (Функциональное выражение) - функция присваивается в переменную;Основная разница в поведении функций, объявленных разным способом, проявляется во всплытии (Hoisting): Function Declaration: Объявление функции полностью \"всплывает\" в начало своего контекста (глобального или локального). Это означает, что функцию можно вызывать до ее фактического определения в коде. Function Expression: Всплытие происходит только у переменной, которой присваивается функция, но не у самой функции. Это означает, что вы не можете вызвать функцию до того, как она была объявлена.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j114":{
    "theme":"j",
    "question":"Разница между null и undefined?",
    "answer":"Оба значения обозначают отсутствующие данные. Но undefined используется для обозначения отсутствия значения по умолчанию, например, для объявленной, но не инициализированной переменной, для значения функции, которая ничего не возвращает, для несуществующего свойства объекта, а null — для явного указания на отсутствие значения.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j115":{
    "theme":"j",
    "question":"Типы таймеров в JavaScript?",
    "answer":"Есть 2 основных типа таймеров: 1) setTimeout (позволяет вызывать некоторую функцию один раз по истечению определенного времени) 2)setInterval (позволяет вызывать функцию постоянно, через некоторый промежуток времени). Оба принимают два значения - функцию, которая будет выполнена по истечению, и время. setTimeout(sayHi, 1000) - sayHi() вызовется один раз, setInterval(sayHi, 1000) - sayHi() будет вызываться постоянно с промежутком в 1000 мс.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j116":{
    "theme":"j",
    "question":"Что такое поднятие (Hoisting)?",
    "answer":"Поднятие переменных это механизм подъема функции или переменной в глобальную или функциональную область видимости. Это происходит с переменными, объявленными при помощи var, и с функциями определенными function declaration - к ним можно получить доступ еще до объявления в документе.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j117":{
    "theme":"j",
    "question":"Что такое область видимости (Scope)?",
    "answer":"Это место откуда мы имеем доступ к переменной или функции. В JS мы имеем 3 области видимости - глобальная (), локальная(), блочная (новая, в ES6 - это область внутри {} для переменных, объявленных с помощью let и const).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j118":{
    "theme":"j",
    "question":"Разница между var, let и const?",
    "answer":"Переменная, объявленная с помощью var, всплывает. То есть, если такую переменную  вызвать еще до ее инициализации, то мы получим undefined. В случае переменных, объявленных let или const, мы получим ошибку. Во-вторых, у let и const область видимости блочная - то есть, если они объявлены внутри {},то доступны только внутри этого блока и на всех вложенных уровнях. Переменная, объявленная с помощью var, такую область видимости игнорирует, она имеет функциональную область видимости, то есть доступна в пределах функции, если объявлена внутри нее, либо доступна глобально, если объявлена за пределами функций. В-третьих, разница между let и const, что переменная, объявленная const, не может быть переопределена.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j119":{
    "theme":"j",
    "question":"Что такое замыкание (Closure)?",
    "answer":"Замыкание (closure) — это механизм в JavaScript, при котором функция «запоминает» своё лексическое окружение, даже когда она выполняется вне своей первоначальной области видимости. Когда функция создается в JavaScript, она запоминает не только свой код, но и окружение, в котором была создана. Это окружение включает все переменные и параметры, которые были в области видимости этой функции на момент её создания. Если функция обращается к переменным вне своего тела, она образует замыкание. Другими словами, при создании функции и использовании внутри нее переменных, эти переменные доступны только внутри этой функции. Для хранения этих переменных выделяется определенная память, и когда функция заканчивает свое выполнения, эта память очищается, и эти переменные больше нигде не существуют. Но если внутри одной функции создать вторую, то вложенная функция получит доступ к переменным, которые были объявлены во внешней функции. Этот механизм и называется замыканием. Тогда при отработке внешней функции возвращается внутренняя, которая замыкается на значение внешней и не дает памяти очиститься.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j120":{
    "theme":"j",
    "question":"Что обозначает this в JavaScript?",
    "answer":"В JavaScript this — это ключевое слово, которое ссылается на текущий контекст выполнения, то есть объект, к которому принадлежит функция или метод, где используется this.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j121":{
    "theme":"j",
    "question":"Что такое функции высшего порядка (Higher Order Functions)?",
    "answer":"Это функции, которые в качестве аргумента принимают другую функцию или же возвращают другую функцию (например, map, reduce, forEach, filter).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j122":{
    "theme":"j",
    "question":"Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?",
    "answer":"Для превращения можно использовать один из двух подходов: либо функцию Boolean(), внутрь которой мы передаем данные, а на выходе получаем булевое значение - true либо false. Второй подход - использовать двойное отрицание - !! В JS существует 6 основных элементов, которые возвращают ложное значение: ‘’(пустая строка), 0, null, undefined, NaN, false.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j123":{
    "theme":"j",
    "question":"Методы строк в JavaScript?",
    "answer":"length: Возвращает длину строки. toUpperCase(): Преобразует строку в верхний регистр. toLowerCase(): Преобразует строку в нижний регистр. indexOf(substring): Возвращает индекс первого вхождения подстроки или -1, если подстрока не найдена. includes(substring): Проверяет, содержится ли подстрока в строке, возвращает true или false. slice(start, end): Возвращает часть строки от start до end (не включая end). substring(start, end): Похож на slice, но не поддерживает отрицательные значения для start и end. substr(start, length): Возвращает подстроку определенной длины от заданной начальной позиции. trim(): Удаляет пробелы в начале и конце строки. split(separator): Разбивает строку на массив подстрок по указанному разделителю. replace(searchValue, newValue): Заменяет первое вхождение подстроки на новую строку. repeat(count): Повторяет строку указанное количество раз. charAt(index): Возвращает символ по указанному индексу. charCodeAt(index): Возвращает код символа по указанному индексу. concat(...strings): Объединяет две или более строки.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j124":{
    "theme":"j",
    "question":"Методы массивов в JavaScript?",
    "answer":"length: Возвращает количество элементов в массиве. push(element): Добавляет один или несколько элементов в конец массива и возвращает новую длину массива. pop(): Удаляет последний элемент из массива и возвращает его. shift(): Удаляет первый элемент из массива и возвращает его. unshift(element): Добавляет один или несколько элементов в начало массива и возвращает новую длину массива. concat(...arrays): Объединяет два или более массива и возвращает новый массив. slice(start, end): Возвращает новый массив, содержащий копию части исходного массива от start до end (не включая end). splice(start, deleteCount, ...items): Изменяет массив, удаляя элементы, добавляя новые или и то, и другое, возвращает удаленные элементы. indexOf(element): Возвращает первый индекс указанного элемента в массиве, или -1, если элемент не найден. includes(element): Проверяет, содержит ли массив определенный элемент, возвращает true или false. toString() преобразует массив в строку, где элементы массива разделены запятыми. Этот метод не изменяет исходный массив. join(separator): Объединяет все элементы массива в строку, используя указанный разделитель. reverse(): Переворачивает порядок элементов в массиве на месте. sort(compareFunction): Сортирует элементы массива на месте в порядке, определяемом функцией сравнения. map(callback): Создает новый массив с результатами вызова функции для каждого элемента. forEach() выполняет предоставленную функцию один раз для каждого элемента массива. Этот метод не изменяет массив, но позволяет выполнить побочные эффекты или обработку каждого элемента. filter(callback): Создает новый массив со всеми элементами, прошедшими проверку, заданную функцией. reduce(callback, initialValue): Применяет функцию для накопления значения по массиву, возвращая единственное значение. find(callback): Возвращает первый элемент массива, который удовлетворяет условию, заданному в функции. findIndex(callback): Возвращает индекс первого элемента массива, который удовлетворяет условию, заданному в функции. every(callback): Проверяет, удовлетворяют ли все элементы массива условию, заданному в функции, возвращает true или false. some(callback): Проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в функции, возвращает true или false.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j125":{
    "theme":"j",
    "question":"Что такое чистая функция?",
    "answer":"Это одна из концепций функционального программирования. В ней не должно быть побочных эффектов. Каждый раз она возвращает одинаковый результат, когда вызывается с тем же набором аргументов. Нечистая функция, например, может зависеть от какой-то внешней переменной и при вызове с одним же аргументом потенциально давать разные результаты.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j126":{
    "theme":"j",
    "question":"Разница между .forEach() и .map()?",
    "answer":"Оба метода можно применять к массивам, чтобы перебирать их элементы и к каждому элементу применять выбранную функцию. При этом .forEach() перебирает массив и ничего не возвращает, а .map()перебирая массив, формирует и возвращает новый массив, который получен при выполнении функции. Результирующий массив можно присвоить в переменную и использовать дальше. Исходный массив ни тот ни другой метод не изменяют.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j127":{
    "theme":"j",
    "question":"Разница между .call(), .apply() и bind()?",
    "answer":"Периодически внутри функции может использоваться ключевое слово this. В следствие ошибки или запутанности кода значение this может изменяться. Это называется потеря контекста. Для того чтобы этого избежать используются методы .call(), .apply() и bind() Методы .call(), .apply() и .bind() — это методы, которые позволяют управлять значением this внутри функции и задавать его вручную. Эти методы принадлежат всем функциям в JavaScript, так как каждая функция является объектом. Разница в том, что call() и apply() сразу вызывают функцию с заданным контекстом this, а bind() возвращает новую функцию с заданным контекстом this, которую можно вызвать позже. Основное различие между call() и apply() — это способ передачи аргументов (по отдельности или в массиве).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j128":{
    "theme":"j",
    "question":"Почему в JS функции называют объектами первого класса?",
    "answer":"В JS любые типы данных ведут себя как объекты. У каждого типа данных есть набор методов, которые можно использовать. Функции также. Они обрабатываются также как любое другое значение: ее можно присвоить в переменную, она может быть свойством объекта (тогда она называется методом), ее можно передать в другую функцию в виде аргумента или вернуть из функции. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j129":{
    "theme":"j",
    "question":"Как определить наличие свойства в объекте?",
    "answer":"Три способа: 1) использование метода .hasOwnProperty() (obj.hasOwnProperty(‘prop’) / true or false), 2) применение оператора in (‘prop’ in obj / true or false) 3)обратиться к свойству напрямую (obj[‘prop’] / если его нет, то вернется undefined) ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j130":{
    "theme":"j",
    "question":"Что такое IIFE (анонимная самовызывающаяся функция)?",
    "answer":"Она вызывается непосредственно после создания. Такой паттерн использовался до появления модулей ES6, чтобы избежать загрязнения  глобального пространства имен. Он применялся для создания поведения модуля. Переменные, созданные внутри функции не видимы в глобальной области видимости, и не засоряют глобальное пространство имен.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j131":{
    "theme":"j",
    "question":"Что такое псевдомассив arguments?",
    "answer":"Это коллекция аргументов, которые передаются в функцию. Псевдомассивом его называют, потому что это объект подобный массиву. Кроме length другие методы массивов ему недоступны. С помощью него можно получить доступ к любому из аргументов, которые были переданы в функцию. В стрелочных функциях он недоступен. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j132":{
    "theme":"j",
    "question":"Разница между host-объектами и нативными объектами?",
    "answer":"Хост-объекты это объекты, которые предоставляются средой выполнения - то есть браузером - это например window, localstorage, document и тд Нативные объекты - это объекты, которые являются частью языка JS (String, Object, function и тд)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j133":{
    "theme":"j",
    "question":"Почему результат сравнения 2х объектов это false?",
    "answer":"В JS механизмы сравнения примитивов и объектов отличаются. Примитивы сравниваются по значению, и если это строгое равенство (===), то дополнительно сравниваются типы. Объекты сравниваются по ссылке или адресу в памяти, где хранится переменная, соответственно, когда создаются объекты, даже если по внутренней структуре они одинаковы ссылки будут разные, поэтому сравнение двух одинаковых объектов или даже двух пустых объектов -  всегда false. Чтобы сравнение вернуло true переменной нужно присвоить ссылку на уже существующий объект.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j134":{
    "theme":"j",
    "question":"Что такое прототипное наследование? Как создать объект без прототипа?",
    "answer":"Все объекты в JavaScript имеют свойство Prototype, которая является ссылкой на другой объект. Когда к свойству объекта происходит обращение и если свойство не находится в текущем объекте, то механизм JavaScript просматривает прототип объекта и ищет это свойство там, затем он идет в прототип прототипа и так далее, до тех пор пока пока не найдет определенное свойство на одном из прототипов, или до тех пор пока не достигнет конца цепочки прототипов - это и есть прототипное наследование. Для того, чтоб создать объект без прототипа нужно воспользоваться Object.create(), внутрь которого в качестве аргумента передать null.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j135":{
    "theme":"j",
    "question":"Разница между классовым и прототипным наследованием?",
    "answer":"Классовое или классическое наследование - это механизм исследования, при котором экземпляры наследуется от классов, а также создаётся иерархическая система классов или подклассовые отношения. Экземпляры реализуются через конструктор функции через дискриптор new. Также экземпляр класса может не содержать дескриптор-класс начиная с версии ES6. Прототипное наследование - это механизм наследования, при котором экземпляры наследуется напрямую от других объектов, реализуется данный подход через фабрики или метод object create. Экземпляры могут быть составлены из множества различных объектов для упрощения выборочного насследования. К плюсам прототипного наследованием можно отнести: простота, если сравнивать с классовым; слабая связь: экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип. С прототипным наследованием легко поддерживать плоские иерархии используя конкатенацию, выборочное использование свойств одного объекта для создания другого и делегирование клонирования одного объекта в другой. Гибкая архитектура: поскольку можно выборочно наследоваться, больше не нужно беспокоиться о проблеме не правильного дизайна - новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов.",
    "codeexample":"",
    "images":["https://qph.cf2.quoracdn.net/main-qimg-e5427ba8cf6565194055be162060d83a-lq"],
    "checked":""
  },
  "j136":{
    "theme":"j",
    "question":"Что такое SOLID?",
    "answer":"SOLID - аббревиатура для обозначения пяти принципов, которые используются в ООП. Общая идея говорит о том, что использование сразу нескольких принципов как единого целого намного лучше, чем использование по отдельности. Принципы SOLID: Принцип единой ответственности. У модуля должна быть только одна причина для изменения или класс должен отвечать только за что-то одно. Основная идея - это организовать свой код таким образом, чтобы в случае возникновения изменения  задействовать наименьшее количество модулей. Принцип открытости и закрытости. Модуль должен быть открыт для расширения, но закрыт для изменения.  Основная идея - это разработка устойчивого к изменениям приложения и закладывания такой архитектуры, чтобы небольшое изменение класса не затрагивала кучу связанных с ним модулей. Принцип подстановки Барбары Лисков. Необходимо, чтобы подклассы могли служить заменой для своих суперклассов, другими словами функции, использующие базовый тип должны иметь возможность использовать его подтипы. Основная цель - это проектировать логику таким образом, чтобы классы наследники могли использовать методы родителей. Принцип разделения интерфейсов. Сущности не должны зависеть от интерфейсов, которые не используют. Принцип инверсии зависимостей. Модули высших уровней не должны зависеть от модулей низких уровней, оба должны зависеть от абстракции, абстракции не должны зависеть от деталей, детали должны зависеть от абстракции.",
    "codeexample":"",
    "images":["https://www.xlns.net/wp-content/uploads/2022/12/Colorful-Diamond-Cycle-Map.png"],
    "checked":""
  },
  "j137":{
    "theme":"j",
    "question":"Какие ещё принципы кроме SOLID вы знаете?",
    "answer":"SOLID - это основной принцип объектно ориентированного программирования. Однако помимо него также есть принципы DRY - расшифровывается, как don’t repeat yourself - \"не повторяйся\", также известен как DIE или duplication is evel \"дублирование - это зло\". Этот принцип заключается в том, что нужно избегать повторений одного и того же кода, лучше использовать универсальные свойства и функции. KISS - keep it simple stupid, то есть \"не усложняй\". Смысл заключается в том, что стоит делать максимально простую и понятную архитектуру, применять шаблоны проектирования и не изобретать велосипед. YAGNI значит You aren't gonna need it \"вам это не понадобится\". Его суть в том, чтобы реализовывать только поставленные задачи и отказаться от избыточного функционала. APO или Avoid Premature Optimization - \"избегайте преждевременной оптимизации\" - это практика призывает разработчиков не оптимизировать код до того, как эта необходимость будет доказана. Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функции на рынок.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j138":{
    "theme":"j",
    "question":"Однонаправленный поток данных и двусторонняя связь данных? В чем между ними разница?",
    "answer":"Эта концепция активно используется в архитектуре современных библиотек и фреймовков. Однонаправленный поток данных означает что только модель - это источник истины. Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание. Любые изменения в интерфейсе запускают события, которые сообщают пользователю о намерении модели. Для простоты понимания в ряде приложений такой моделью может быть state. Двухсторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, другими словами, при изменении интерфейса происходят изменения моделей и наоборот.Однонаправленные потоки данных чётко определены и по иерархии элементов идут сверху вниз то есть от родителя потомку. В то время как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.",
    "codeexample":"",
    "images":["https://raw.githubusercontent.com/lihongxun945/myblog/master/images/vue-vs-react-data-flow.png"],
    "checked":""
  },
  "j139":{
    "theme":"j",
    "question":"Почему расширение нативных JavaScript-объектов это плохая практика?",
    "answer":"JavaScript использует механизм прототипного наследования,то есть если свойство или метод не найдены в текущем объекте, то поиск будет осуществляться дальше по цепочке прототипов. Расширение нативных JavaScript-объектов означает добавление новых свойств или методов его прототипу. Расширив текущую версию прототипа кастомное свойство может вступить в конфликт с вновь добавленным. Можно получить сложную реализацию логики из-за добавленных свойств, которые используются только в одном проекте. Единственным решением расширения нативных JavaScript-объектов является создание полифила для старых браузеров.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j140":{
    "theme":"j",
    "question":"Что такое NaN? Как определить, что значение равно NaN?",
    "answer":"NaN (not a number) - значение представляющее не число. Это не настраиваемое и не записываемое свойство глобального объекта. Оно получается когда математическая функция сработала неверно. NaN не равно любому другому, включая саму себя. Для того чтобы проверить является ли значение не числом используют функцию isNaN(), в качестве аргумента принимает проверяемую величину, а результатом работы возвращает boolean-значение.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j141":{
    "theme":"j",
    "question":"Что такое временная мёртвая зона (temporal dead zone)?",
    "answer":"Одной из отличительной из особенностей между старым var и новыми let и const, является то, что var может “всплывать”, тем самым вызывая его до объявления получается undefined. Вызов значений let и const до их объявлений вызывает ошибку. Если немного углубиться, то механизм их работы описывает так называемая “временная мертвая зона”.  Дело в том, что  let и const на самом деле “всплывают” точно так же как и var, но для того, что того, чтобы отлавливать ошибки в ES6 для переменных констант создали “temporal dead zone”. Это значит, что переменные будут созданы когда интерпретатор зайдет в область видимости, но они будут недоступны до тех пор пока выполнение кода не дойдет до места их фактического объявления и только в этот момент произойдет выход из временной мертвой зоны.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j142":{
    "theme":"j",
    "question":"Что такое объектная обертка (Wrapper Objects)?",
    "answer":"Понятие объектная обертка тесно связана со спецификой языка JavaScript . В JS основные типы данных - это примитивы и объекты/ Тем не менее даже у примитивов есть свои методы. Например, если применить к строке name применим метод .toUpperCase(), то результатом работы получим не ошибку, а трансформированное в верхний регистр слово. Такое поведение возможно благодаря объектной обертке, то есть момент исполнения кода этот примитив временно преобразуется в объект. Это аналогично тому, как если бы в момент применения метода использовался конструктор new String(). У каждого примитива, кроме null и undefined, есть такой объект-обертка. ПОсле работы со свойством или методом временный объект отбрасывается.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j143":{
    "theme":"j",
    "question":"Можно ли изменить значение определенное через const?",
    "answer":" С появлением ES6 определять различные значения можно благодаря let и const. let унаследовала функциональность var, то есть переменная переданная через let в процессе выполнения скрипка может быть переопределена. const - это константа, то есть при попытке переопределения значения происходит ошибка. Однако,  если речь идет об объекте, то его свойства и методы могут быть изменены, а вот переназначение объекта в const по прежнему вызывает ошибку, это происходит потому что в саму const записывается записывается не значение, а ссылка на объект. Объект хранится в области оперативной памяти.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j144":{
    "theme":"j",
    "question":"Как в JavaScript создать объект?",
    "answer":"1Объектный литерал; Функция конструктор; Использование метода Object.create()",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j145":{
    "theme":"j",
    "question":"Для чего используется ключевое слово new?",
    "answer":"В JavaScript  для создания объектов используется несколько методов. Один из них - использование функции конструктора, которая вызывается со специальным словом new. Результатом выполнения получается новый объект (экземпляр класса). Ключевое слово new выполняет следующее: Создает пустой объект. Привязывает к созданному объекту значение this, то есть this указывает на вновь созданный объект. Функция устанавливает внутреннее недоступное свойство этого нового объекта prototype как внешний доступный объект прототип функции конструктора, то есть каждый объект, созданный функцией, автоматически получает свойство prototype. Возвращает значение this, если в реализации не указано другое.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j146":{
    "theme":"j",
    "question":"Операторы «И» и «ИЛИ» (&& и ||)?",
    "answer":"В JS есть три логических оператора (&&, ||,  !). “И” (&&) находит и возвращает первое ложное значение, или последний операнд, когда все значения истинные). То есть как только находится первое подходящее значение, дальнейшая проверка не выполняется.  “ИЛИ” (||) возвращает первое истинное значение или последнее значение, если все операторы ложны. Для && выполнение прекращается, если найден ложный операнд. Для || выполнение прекращается, если найден истинный операнд.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j147":{
    "theme":"j",
    "question":"Для чего используется оператор двойного отрицания (!!)?",
    "answer":"Оператор двойного отрицания (!!) используется для приведения значения, которая находится справа от него, к логическому типу. Таким образом используя его с каким-либо типом данных, например, null, undefined, строки, числа и т.д. на выходе получаем либо true, либо false. Еще одним способом преобразования типом к логическому значению служит объект Boolean.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j148":{
    "theme":"j",
    "question":"Для чего используется оператор остатка (%)?",
    "answer":"Периодически в JS возникает необходимость получить остаток двух чисел, таким образом может проверять кратность. В JS основной способ проверки кратности - это оператор остатка (%). Данный оператор возвращает остаток от деления двух чисел. Если в остатке есть какое-то число отличное от 0, значит число не кратный, если 0, значит число кратный.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j149":{
    "theme":"j",
    "question":"Как проверить, является ли значение массивом?",
    "answer":"Чтобы проверить является значение массивом используются метод Array.isArray(), внутрь которого передаете значение, и на выходе метод возвращает булевое значение. true, если данное представляет массив, false, если не массив.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j150":{
    "theme":"j",
    "question":"Как работает boxing/unboxing в JavaScript",
    "answer":"Термины упаковки и распаковка или boxing, unboxing пришли JavaScript из других языков программирования. На практике данный механизм тесно связан с понятием объект-обертка. Если у примитивного значения, например, строки мы вызываем метод  несмотря на то, что метод вызывается не у объекта, а у примитива это не вызывает ошибку. Происходит это благодаря объекту-обертки new String(), вызов которого происходит не явно. Этот объект оборачивает примив и вызывает метод, после исполнения объект уничтожается, а нам возвращается результат работы. Этот процесс получил название boxing (упаковка). Такое оборачивание может быть нативным, когда оно идет “под капотом”, а может быть явным, когда мы самостоятельно оборачиваем примитив в конструктор.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j151":{
    "theme":"j",
    "question":"Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?",
    "answer":"Мемоизация - это прием создания функции способной запомнить ранее вычисленное значение, а также результат.  При повторном вызове функции  с одинаковыми аргументами она не будет выполнена, а результат работы вернется из кэша. Это является плюсом использования подобных функций. К минусам можно отнести то, что для хранения всех полученных результатов нужно выделять дополнительную память. На примере создается функция, внутри которой используя замыкание в const cashe хранятся результаты. Каждый раз когда вызывается мемоизированная функция происходит проверка, если кэш хранит ключ, которому соответствует передаваемая в функцию аргумент, то возвращается сохраненный результат, если такого ключа нет, то дополнительно при возврате результата в объекте  cashe создается новое поле с ключем аргумента и свойством результата. При повторном вызове мемоизированное значение просто вернется из функции.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j152":{
    "theme":"j",
    "question":"Разница между оператором in и методом .hasOwnProperty()?",
    "answer":"Оба подхода предназнены для проверки наличия определенного свойства в объекте. Разница между ними заключается в том, что оператор in проверяет наличие свойства не только в самом объекте, но и в его прототипах, в то время как метод .hasOwnProperty() проверяет наличие свойства только в основном объекте.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j153":{
    "theme":"j",
    "question":"Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?",
    "answer":"В JavaScript есть два способа передачи и копирования: по значению и по ссылке. Когда копирование происходит по значению, это значит, что создается новое отдельное и независимое значение подобное оригиналу. Когда копирование происходит по ссылке, то новая сущность не создается, а по сути происходит создание псевдонима для уже существующего значения. Такой вариант копирования называется поверхностным. При глубоком копировании, так как создается независимая копия, при изменений свойств в копируемом объекте копия сохраняет свое значение. При поверхностном копировании, при внесении изменений в копируемый объект, копия так же изменяют свои значения, так как по сути являются только ссылкой. Если изменить копию изменится и оригинал.Для того, чтобы сделать поверхностную копию объекта его достаточно присвоить в новую переменную.Для создания глубокого копирования можно использовать следующие варианты: spread operator; Метод Object.assign(); Комбинацию JSON.parse() и JSON.stringify()/",
    "codeexample":"",
    "images":["https://www.csharp411.com/wp-content/uploads/2008/05/objectclone.jpg"],
    "checked":""
  },
  "j154":{
    "theme":"j",
    "question":"Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?",
    "answer":"Сhaining или цепочка вызовов - это подход, при котором методы объекта вызывается один за другим без дополнительного обращения к исходному объекту. В нативной реализации JS,например, это некоторые методы строк и массивов. При использовании промисов это методы then() и catch(). Для того, чтобы реализовать такую возможность самостоятельно, можно использовать замыкание, либо из метода возвращать контекст вызова или ключевое слово this.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j155":{
    "theme":"j",
    "question":"Что такое необъявленная переменная?",
    "answer":"Необъявленная переменная создается при определении значения идентификатору, который не был объявлен с использованием ключевых слов var, let или const. Необъявленные переменные, объявляются за пределами текущей области видимости в глобальной области видимости. Таким образом они получают возможность быть видимыми в любом месте кода. Их  использование, так же как использование глобальных переменных, считается плохой практикой, так как из глобальной области к ним можно  получить свободный доступ и нарушить выполнение программы. В строгом режиме при попытке добавления значения необъявленной переменной будет выброшено ислючение ReferenceError.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j156":{
    "theme":"j",
    "question":"Как передаются параметры в функцию: по ссылке или по значению?",
    "answer":"Параметры, которые передаются в функцию всегда передаются по значению. Однако переменная представляющая объекты записаны ссылки на эти объекты, поэтому когда в функцию передают объект и изменяют свойство этого объекта это изменение сохраняется в объекте при выходе из функции. Поэтому может возникнуть ощущение того, что параметры в фунцию передают по ссылке, но если изменить значение переменной, представлющая объект,  то это изменение никак не повлияет объект, находящийся за пределами функций.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j157":{
    "theme":"j",
    "question":"Разница между функцией и методом?",
    "answer":"Функция - это фрагмент кода, который вызывается по имени и не связан с каким-либо объектом, и не определен внутри объекта. В функцию могут быть переданы данные для работы, то есть параметры и при желании могут быть возвращены данные. Метод - это фрагмент кода, который вызывается по имени и определяется внутри объекта он почти идентичен функции за исключением того что он всегда связан с объектом и работает только с данными внутри него.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j158":{
    "theme":"j",
    "question":"Что такое прототип объекта в JavaScript?",
    "answer":"Объекты в JavaScript можно организовать в цепочке таким образом, чтобы свойства не найденные в одном объекте автоматически искалось бы в другом, т.е. прототипе. Для реализации такой цепочки есть специальное свойство, которое называется proto, если один объект имеет специальное ссылку proto на другой объект, то при чтении свойства из него если свойство отсутствует в самом объекте оно ищется в объекте proto, другими словами прототип - это резервное хранилище свойств и методов объекта, которая автоматически используется при поиске. Минус такого подхода в том, что он не поддерживается Internet Explorer ниже 10 версии. Однако в JavaScript имеется альтернативный встроенный в язык и полностью кроссбраузерный способ -  чтобы новым объектам автоматически ставить прототип конструктору ставится свойство prototype. При создании объекта через new его прототип proto записывается ссылка из prototype функции-конструктора.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j159":{
    "theme":"j",
    "question":"Как работает метод Object.create()?",
    "answer":"метод object.create() в ES5 - это самый простой способ наследования одного объекта от другого без вызова функции конструктора в качестве аргумента. Метод принимает объект от которого будет происходить наследование в приведённом примере мы создаём новый объект emp1, который наследуется от объекта employee, другими словами прототип emp1 установлен на employee. После этого emp1 сможет получить доступ ко всем свойствам и методам employee, а также он может добавить новые или переопределить существующие задав новое свойство или методы с тем же именем. В дополнение к этому в методе Object.create также можно указать второй аргумент, который является объектом содержащим дополнительные свойства и методы для добавления к новому объекту, т.е. передав в метод дополнительный объект, его значениями можно расширить результирующий объект наследник или же переопределить некоторые свойства и методы.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j160":{
    "theme":"j",
    "question":"Разница между Object.freeze() и Object.seal()?",
    "answer":"Object.seal(): Предотвращает добавление или удаление свойств из защищенного объекта, использование delete в этом случае вернет false; Делает каждое существующее свойство не конфигурируемым, то есть они не могут быть преобразованы из дескрипторов данных, дескрипторы доступа и наоборот, а также никакой атрибут дескрипторов доступа не может быть изменен вообще, тогда когда как дескрипторы данных могут изменить свой writeable и их атрибуты, если у writeable  определено значение true; Может выдавать type error в строгом режиме при попытке изменить значение самого защищенного объекта. Object.freeze() делает все то же самое, что и Object.seal() плюс предотвращает изменение любых существующих свойств.",
    "codeexample":"",
    "images":["https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fi%2Fwssueapx8jykyx0rkixk.png"],
    "checked":""
  },
  "j161":{
    "theme":"j",
    "question":"Разница между методами .slice() и .splice()?",
    "answer":"Оба метода используется для работы с массивами. Метод slice возвращает выбранные элементы массива в виде нового массива, а метод splice используется для добавления или удаления элементов в или из массива. Главное отличие заключается в следующем: slice не изменяет исходный массив, splice изменяет, slice возвращает подмассив исходного массива, splice  возвращает удалённые элементы в виде массива, slice служит только для извлечения элементов из массива, splice служит для добавления и удаления элементов в и из массива.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j162":{
    "theme":"j",
    "question":"Как работают методы .find(), .findIndex() и .indexOf()?",
    "answer":"Все три метода используются для поиска элементов в массиве. Метод .find() возвращает первый элемент массива, соответствующий заданному критерию. Этот метод найдя первый подходящий элемент не продолжает дальнейший поиск массиву. В качестве аргумента он принимает функцию. Метод .findIndex() похож на .find(), но он вместо, что возвращать первый подходящий элемент массива, возвращает индекс такого элемента.В качестве передаваемого аргумента принимает функцию. Метод .indexOf() похож на .findIndex(), но в отличие от двух предыдущих принимает в качестве аргумента значение. Использовать его нужно в том случае, если при поиске нужного элемента не нужна сложная логика.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j163":{
    "theme":"j",
    "question":"Плюсы и минусы использования use strict?",
    "answer":"Use strict - это директива, которая используется для включения строго режима во всем скрипте или отдельных функциях. К преимуществам использования можно отнести: не позволяет случайно создавать глобальные переменные; любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение; при попытке удалить неудаляемые свойства выдаст исключение; требует, чтобы имена параметров функции были уникальными; this в глобальной области видимости равно undefined; перехватывает распространение ошибки, выдавая исключение; исключает неочевидные особенности языка. Минусы: нельзя использовать некоторые особенности языка; нет доступа к function.caller и function.arguments; объединение скриптов в строгом режиме может вызвать проблемы.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j164":{
    "theme":"j",
    "question":"Разница между методами .push(), .pop(), .shift() и .unshift()?",
    "answer":"Методы .push(), .pop(), .shift() и .unshift() используются для работы с массивами, добавляя или удаляя элементы. Метод .push() добавляет один или несколько элементов в конец массива и возвращает новую длину массива. Метод .pop() удаляет последний элемент массива и возвращает его. Метод .shift() удаляет первый элемент массива и возвращает его. Метод .unshift() добавляет один или несколько элементов в начало массива и возвращает новую длину массива. Методы, которые работают с концом массива (.push() и .pop()), более эффективны с точки зрения производительности, так как они не требуют пересчета индексов элементов, в отличие от методов, работающих с началом массива (.shift() и .unshift()).",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j165":{
    "theme":"j",
    "question":"Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?",
    "answer":"Иммутабельность (immutability) — это концепция, согласно которой объект или структура данных не может быть изменена после своего создания. Вместо изменения существующего объекта создается его новая версия с изменениями, оставляя исходный объект нетронутым. Плюсы иммутабельности: Предсказуемость: Поскольку объекты не меняются, легче предсказать поведение программы. Безопасность: Уменьшается вероятность появления ошибок, связанных с изменением состояния объектов в разных частях программы. Тестируемость: Тестировать иммутабельный код проще, так как исходные данные не изменяются. Отладка: Легче отслеживать состояние программы во времени, так как каждое изменение приводит к созданию нового объекта. Минусы: Производительность: При создании новых объектов на основе старых вместо их изменения требуется больше памяти и времени, особенно при работе с большими данными. Усложнение кода: В сложных структурах данных требуется более сложное управление копированием объектов (например, глубокое клонирование). Требуются дополнительные библиотеки: Иногда для удобства работы с иммутабельностью могут понадобиться сторонние библиотеки, такие как Immutable.js или immer. Чтобы достичь иммутабельности можно использовать const и метод Object.freeze(), или использовать дополнительные библиотеки.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j166":{
    "theme":"j",
    "question":"Типы всплывающих окон в JavaScript?",
    "answer":"Существует три типа модальных окон, которые JS поддерживает нативно и которые можно использовать для взаимодействия с пользователем. Это alert - выводит диалоговое окно с кнопкой Ok, используется чтобы информировать пользователя, что что-то произошло. Confirm - отображает диалоговое окно с кнопками ok и cancel. Пользователь может подтвердить или отклонить свой выбор. И prompt - диалоговое окно с кнопками ok и cancel, а также с полем для ввода данных. С помощью него можно получить какую-то дополнительную информацию от пользователя.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j167":{
    "theme":"j",
    "question":"Типы объектов JavaScript?",
    "answer":"Можно выделить 9 основных типов объектов: объект массива (используется для хранения упорядоченных коллекций данных), строковый объект (используется для работы со строковыми значениями), объект даты (используется для манипулирования датой и временем), числовой объект (работает с числовыми данными), логический объект (предоставляет истинные или ложные значения), функциональный объект (представляет функции), объект Math (содержит математические константы и функции, используется для выполнения математических операций), объект RegExp (представляет регулярные выражения, которые используются для поиска и сопоставления текста по заданным шаблонам), объект Object (базовый объект, от которого наследуются все другие объекты в JavaScript. Используется для создания пользовательских объектов с определенными свойствами и методами.)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j168":{
    "theme":"j",
    "question":"Парадигмы программирования в JavaScript?",
    "answer":"JavaScript поддерживает несколько парадигм программирования, включая объектно-ориентированное программирование (ООП) и функциональное программирование (ФП). Объектно-ориентированное программирование (ООП): Наследование: Позволяет одному объекту наследовать свойства и методы другого объекта, что способствует повторному использованию кода. Инкапсуляция: Объединяет данные и методы, которые работают с этими данными, внутри объекта, ограничивая доступ к ним извне. Полиморфизм: Позволяет методам работать с объектами разных типов, обеспечивая их гибкость и универсальность. Абстракция: Позволяет скрывать сложные детали реализации и предоставлять простой интерфейс для взаимодействия с объектом. Функциональное программирование (ФП): Чистые функции: Функции, которые не имеют побочных эффектов и возвращают одно и то же значение при одинаковых входных данных. Иммутабельность: Данные не изменяются после их создания; любые изменения данных приводят к созданию новых объектов. Ссылочная прозрачность: Вызовы функций с одинаковыми аргументами всегда возвращают одинаковые результаты, что делает код предсказуемым и легко тестируемым. Замыкание: Механизм, позволяющий функции запоминать контекст, в котором она была создана, и доступ к переменным этого контекста. Функции первого класса: Функции в JavaScript могут быть переданы как аргументы другим функциям, возвращены из функций, а также присвоены переменным. Функции высшего порядка: Функции, которые принимают в качестве аргументов другие функции или возвращают их.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j169":{
    "theme":"j",
    "question":"Что такое функциональное программирование?",
    "answer":"Функциональное программирование - это парадигма программирования, в которой процесс вычисления трактуется, как вычисление значения функций, противопоставляется в парадигме императивного программирования, которое описывает процесс вычисления, как последовательное изменение состояний при необходимости. В функциональном программировании вся совокупность последовательных состояний вычислительного процесса предоставляется явным образом, например, как список. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций и не предполагает явного хранения состояния программой, соответственно не предполагает оно и изменяемость этого состояния в отличие от императивного, где одной из базовых концепций является переменная хранящая своё значение и позволяющая менять его по мере выполнения алгоритма. Таким образом, приложение написанное в функциональном стиле проходит через три основных этапа: первый - это получение аргументов для работы, второй - выполнение функции с этими аргументами или без них, третий - возвращение результата. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j170":{
    "theme":"j",
    "question":"Плюсы и минусы функционального и объектно-ориентированного программирования",
    "answer":"Большой плюс функционального программирования - это использование функциональной парадигмы, которая позволяет избежать общих состояний и нежелательных эффектов. Также исключаются ошибки возможные из-за конкурирования функций благодаря таким фичам. как неявное программирование. Функции радикально упрощаются и легко перестраиваются для более лёгкого, по сравнению с ооп, повторного использования. Вычисления, которые используют чистые функции, легко масштабируются на несколько процессов без опасения возникновения проблем с ресурсами. Минус функционального программирования - это чрезмерная эксплуатация функциональных подходов, что иногда может привести к снижению читабельности кода, так как конечный код получается более абстрактным, кратким и менее конкретным. Некоторые общие идиомы функционального программирования могут вызывать трудности у начинающих разработчиков. Концепции функционального программирования описываются идиомами и обозначениями из лямбда исчислений и теории категорий требующих для понимания знания основ этих областях. Если говорить о плюсах ООП то это простая для понимания концепция объектов и методов вызова. ООП стремится использовать императивный стиль нежели декларативный, который читается, как прямой набор машинных инструкций. Минусы ООП - это, как правило, зависимость от общего состояния. Объекты и их поведения связаны с одной сущностью которой может быть получен доступ любым количествам функций в неопределённом порядке, что в конечном итоге может привести к непредсказуемому поведению.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j171":{
    "theme":"j",
    "question":"Типы ошибок в JavaScript?",
    "answer":"Можно выделить три основных типа ошибок - это ошибки времени загрузки - это ошибки которые возникают при загрузке веб-страницы; ошибки времени выполнения - это ошибки возникающие из-за неправильного использования команды внутри языка HTML и логические ошибки это ошибки которые возникают из-за неправильной логики выполняемой в функциях или других операциях. И уже исходя из данной классификации можно выделить следующие варианты ошибок: EvalError ошибка в конструкции Eval, является устаревшей; Range Error происходит, когда число не попадает в диапазон; ReferenceError ошибка ссылки, когда логика ссылается на несуществующий элемент в коде; SyntaxError - синтаксическая ошибка; TypeError - ошибка при использовании в логике неверного типа; URIError появляется при использовании методов encodeURI и decodeURI с не валидными данными; ThrowError ошибка при использовании ключевого слова throw; CustomError - тип ошибки созданный непосредственно разработчиком.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j172":{
    "theme":"j",
    "question":"Разница между typeof и instanceof?",
    "answer":"typeof - это оператор, который возвращает строку с типом того, что передаётся. Он проверяет, принадлежит ли значение одному из восьми основных типов: число, строка, логическое значение, undefined и так далее. instanceof работает на уровне прототипов, в частности он проверяет появляется ли правый операнд где-нибудь в цепочке прототипов левого. В большинстве случаев это означает, что объект был создан с помощью этого конструктора или его потомка, но также прототип может быть задан явно методом object set property of или свойством proto. Таким образом instanceof применим только к объектам. Также instanceof не может проверить, какой именно конструктор был использован для создания объекта, но вернёт true даже если объект является производным от проверяемого класса. Оператор проверяет текущий объект и возвращает true, если объект имеет указанный тип и false, если объект данный тип не имеет. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j173":{
    "theme":"j",
    "question":"JavaScript статически, или динамически типизированный язык?",
    "answer":"JavaScript это язык с динамической типизацией. В языке с динамической типизацией тип переменной проверяется во время выполнения в отличие от языка со статической типизацией где тип переменной проверяется во время компиляции. И поскольку JavaScript - это язык со слабой динамической типизацией, переменные в JS не связаны ни с каким типом, а это значит что переменная может содержать значение любого типа данных. Таким образом, например, переменная, которой присвоен числовой тип может быть преобразована в строковый тип и это не вызовет никаких ошибок и исключений.",
    "codeexample":"",
    "images":["https://i.imgur.com/Ahg8rVL.png"],
    "checked":""
  },
  "j174":{
    "theme":"j",
    "question":"Что такое регулярное выражение (Regular Expression)?",
    "answer":"Регулярное выражение - это шаблон, используемый для сопоставления последовательностей символов в сроках. В JavaScript регулярные выражения также являются объектами. Эти шаблоны используются в методах test, exec, match, replace, search и split. Создать регулярное выражение можно двумя способами. Более очевидный - это использование литерала регулярного выражения то есть по сути создать переменную и присвоить ей специальное значение описанное внутри наклонных черт. За пределами крайней наклонной черты указываются специальные символы, которые называются флагами, они описывают, каким образом должен вести себя механизм поиска: должен ли он быть глобальным, нужно ли учитывать регистр символов и так далее. Второй способ - это вызвать функцию конструктор RegExp в качестве аргументов. Функция принимает два значения: первый - это строка регулярного выражения, второй - уже описанные флаги. Шаблон регулярного выражения может состоять из обычных символов или комбинация обычных и специальных символов.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j175":{
    "theme":"j",
    "question":"Что такое рекурсия?",
    "answer":"Рекурсия - это логика, при которой функция в своём теле вызывает саму себя. Функцию, вызывающую себя, называют рекурсивной функцией, а вызов рекурсивной функции называется рекурсивным вызовом.  Рекурсия - это не фича только языка JavaScript, данная логика применима для любого языка программирования. Одной из самых распространённых задач на собеседовании по рекурсии может быть сумма чисел в последовательности Фибоначчи, когда есть функция принимающая число, это число раскладывается на ряд Фибоначчи, и по результату возвращается сумма вхождений. Реализацию логики можно видеть в примере: функция называется Фибоначчи: внутри она содержит простое условие, и если входящее число меньше или равно единице, то оно возвращается, если нет - то возвращается сумма из двух предыдущих значений, каждая из которых пробрасывается в эту же функцию. Это и есть рекурсия, то есть вызов функций из самой себя.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j176":{
    "theme":"j",
    "question":"Что такое прототип (Prototype) объекта?",
    "answer":"Прототип - это план объекта, если он существует в текущем объекте, то используется как резерв для свойств и методов. То есть если какого-то значения нет в объекте, оно ищется в прототипе. Это способ обмена свойствами и функциональностью между объектами и основная концепция прототипного наследования в JS. Например, несмотря на то, что метод toString не существует в объекте “O” он не выдаёт ошибку, а возвращает строку object Object Когда свойства не существует в объекте, оно ищется в его прототипе, а если нет в прототипе, то в прототипе прототипа и так далее, до тех пор пока не найдено свойство с таким же именем в цепочке прототипов. Конец цепочки прототипов - это Object.prototype.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j177":{
    "theme":"j",
    "question":"Какие методы используются в регулярных выражениях?",
    "answer":"В регулярных выражениях используется два основных метода это test и exec. Метод exec ищет совпадение с регулярным выражением в переданной ему в качестве аргумента строке. Поведение данного метода зависит от того, имеет ли регулярное выражение флаг g или global. Если нет, то возвращается первое совпадение, если же флаг g есть, то тут срабатывает следующим механизм: для начала вызов exec возвращает первое совпадение и запоминает позицию после него в свойстве last index, далее следующий такой вызов начинает поиск с позиции  last index и возвращает следующее совпадение, после чего происходит запоминание позиции и обновление last index новым значением, и, в заключение, если совпадений больше нет, то exec возвращает null, а для last index устанавливается значение равное нулю.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j178":{
    "theme":"j",
    "question":"Что такое полифил (polyfill)?",
    "answer":"Это блок кода, который выполняет аналогичную логику метода, для которого и был написан. Полифил используется для обеспечения работы современного javascript-кода старых браузеров, это делается за счёт реализации новых возможностей языка на старом синтаксисе. Сам процесс преобразования нового кода в старый называется транспиляцией. В большинстве своём полифилы создаются для логики, которая может работать некорректно в разных браузерах, либо в старых версиях браузера. Также полифилом можно считать любую пользовательскую функцию, которая решает какие-то проблемы кроссбраузерности.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j179":{
    "theme":"j",
    "question":"Что такое switch/case? Правила использования switch/case?",
    "answer":"switch/case является альтернативой if/else и представляет собой более наглядный способ выполнения кода в зависимости от переданного условия. Инструкция switch сравнивает выражение со случаями или кейсами, перечисленными внутри неё, а затем выполняет соответствующие инструкции. Каждый случай отделён ключевым словом case, внутри case описывается логика и в конце указывается ключевое слово brake. Это нужно чтобы прекратить дальнейшее выполнение проверок, если одна из них сработала. В конце указывается обязательно блок default  для случаев, когда не один из кейсов не отработал. При использовании конструкции switch/case необходимо придерживаться следующих правил: условие может быть числом или строкой, не допускается дублирование значений, инструкция default является опциональной, если ни для одного блока кейс не найдено совпадение, выполняется блок default, break используется для остановки цикла break также является опциональным, но без него выполнение цикла будет продолжаться.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j180":{
    "theme":"j",
    "question":"Типы функций по способности принимать другие функции?",
    "answer":"JavaScrip так как вся его суть сводится к тому что Функция может принимать другие функции как аргументы или же возвращать их в JS можно выделить три основных типа функций в зависимости от принимаемых данных функция первого порядка это функция которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значение функция высшего порядка это функция которая принимает другую функцию в качестве аргумента или возвращает функцию как значение и унарная функция её ещё называют функция монада - это функция которая принимает только один аргумент который не является функцией ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j181":{
    "theme":"j",
    "question":"Что такое выражения (expression) и инструкции (statement) в JavaScript?",
    "answer":"В JavaScript выражения или Expression - это фрагмент кода, некая комбинация значений, переменных, операций и функций, которые в ходе своего выполнения приводят к вычислению и возврату некоторого значения, например числа, строки или значения логического типа. Выражения могут быть сколь угодно длинными, но они всегда будут приводить к вычислению некоторого одного значения например 5 + 3 вернёт 8 а Math.random() случайное число. Инструкция или statement - это фрагмент кода, который выполняет какое-то определённое действие или, если говорить другими словами, является командой. Большинство инструкций в JavaScript заканчивается точкой запятой, примеры инструкции - это блоки if else while for switch и так далее. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j182":{
    "theme":"j",
    "question":"Разница между .some() и .every()?",
    "answer":"Оба метода предназначены для перебора массива, они проверяют каждый элемент массива на соответствие условиям переданной функции, после чего возвращают полученный результат. some() перебирает массив и смотрит, соответствует ли один конкретный элемент массиве в логическому условию, every() можно использовать, чтобы узнать, соответствуют ли все элементы массива логическому условию. Оба метода возвращают булевое значение true если условие выполнилось и false если оно не прошло.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j183":{
    "theme":"j",
    "question":"Как сгенерировать случайное число в JavaScript?",
    "answer":" Самый простой вариант для того чтобы сгенерировать случайное число в JavaScript - это воспользоваться функцией Math.random() - это одна из самых часто используемых функций объекта Math она возвращает случайное число в диапазоне от нуля до единицы не включая единицу.На самом деле, функция не генерирует случайное число, это лишь имитация. За генерацию подобных чисел отвечают специальные алгоритмы, которые относятся к категории и PRNG или pseudorandom number generator их также называют генераторами псевдослучайных чисел. Любой PRNG алгоритм генерирует числа, которые в конечном счёте будут повторяться поэтому числа генерируемые с помощью Math.random() можно предугадать. Для небольших проектов такой генерации вполне достаточно, но для серьёзных продакшн проектов лучше использовать специализированные сторонние библиотеки.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j184":{
    "theme":"j",
    "question":"Типы операторов в JavaScript?",
    "answer":"В JavaScript можно выделить 11 основных типов операторов это: операторы присваивания - это обычное одинарное равно, либо комбинация равно и например математической операции; операторы сравнения, как нетрудно догадаться, используются для сравнения двух или более значений; арифметические операторы - умножения, деления, сложения и вычитание и так далее; битовые или поразрядные операторы - обрабатывают свои операнды как последовательности нулей и единиц; логические операторы, их три - это и, или, не; строковые операторы - самый простой пример - это плюс или конкатенация строк; условный или тернарный оператор комбинация “?”, как проверяемое условие и “:”, как вариант исполнения; оператор запятая “,” просто вычисляет оба операнда и возвращает значение последнего операнда; унарные операторы - это операция только с одним операндом, например удаление из объекта или оператора определения типа; операторы отношения сравнивают свои операнды и возвращают результат сравнения в виде булевого значения; оператор нулевого слияния новый тип, который представляет из себя два вопросительных знака.",
    "codeexample":"",
    "images":["https://avatars.mds.yandex.net/get-lpc/1220100/65f1543d-6895-4825-8f51-7a97200969f7/width_1280x2_q70"],
    "checked":""
  },
  "j185":{
    "theme":"j",
    "question":"Разница между параметром и аргументом функции?",
    "answer":"Параметры - это переменные, которые используются при создании функции, то есть это переменная, указанная в круглых скобках в объявлении функции; аргументы - это фактически значение или данные, которые передаются функции при её вызове.",
    "codeexample":"",
    "images":["https://efim360.ru/wp-content/uploads/argumenty-funkczii-i-parametry-funkczii-javascript-1536x828.png"],
    "checked":""
  },
  "j186":{
    "theme":"j",
    "question":"Правила задания имён для переменных и функций в JavaScript?",
    "answer":"В JavaScript есть два основных ограничения, которые касаются имён переменных: 1. имя переменной должно содержать только буквы цифры или символы доллара и нижнего подчёркивания. 2. первый символ не должен быть цифрой. Что же касается функций, то тут ещё проще, имя функции должно понятно и чётко отражать, что она делает и что возвращает. Функция - это действие, поэтому её имя обычно является глаголом. Есть много общепринятых префиксов, таких как create, show, get и так далее и начинать именно с них, это отличная подсказка, которая поможет понять что делает функция.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j187":{
    "theme":"j",
    "question":"Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?",
    "answer":"Неявное преобразование - это способ приведения значения к другому типу без участия разработчика, другими словами данный тип преобразования происходит автоматически. Если разобрать на практических примерах, то результатом сложения числа 1 и строки “шесть” будет 16, в других языках это бы привело к ошибке. Единица конвертируется в строку и конкатенируется с шесть при этом дополнительно ничего не выполнялось, преобразование произошло автоматически. При сложении false и true получается также единица false было преобразовано в ноль, а true в один 0 + 1 = 1. Результатом умножения 6 числом и “два” строкой будет 12 строка два была преобразована в число перед умножением на шесть. Так работает не явное преобразование, явное преобразование предполагает участие разработчика в приведении значения к другому типу и здесь идут явные преобразования с использованием parseInt или number для приведения к числу или, например, объекта обёртки boolean или двойного восклицательного знака для приведения значения к булевому типу и так далее.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j188":{
    "theme":"j",
    "question":"Для чего применяется метод Array.from()?",
    "answer":"Array.from() создаёт новый массив на основе переданного объекта. Объект должен быть либо массиво подобным, как, например, строка или псевдомассив-объект arguments, либо интегрируемые, как например коллекции Set или Map. Функция Array.from() принимают три аргумента: объект, на основе которого создаётся массив - это обязательный аргумент, и два опциональных: функция преобразования элемента перед его добавлением массив - работает как метод map, то есть перед добавлением элементов массив над ним можно дополнительно выполнить какие-то манипуляции и в заключении значение, которое будет использоваться как this функций из второго параметра результатом работы метода будет новый массив, составленный из элементов переданного объекта.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j189":{
    "theme":"j",
    "question":"Назовите способы преобразования массива в объект?",
    "answer":"В JavaScript Есть несколько вариантов преобразования массива в объект. Самые часто используемые - это метод Object.assign, применение spread оператора появившегося в стандарте es-6, использование метода reduce. При Object.assign внутрь метода передаются два аргумента первый - это пустой объект, куда и будут добавляться значения, второй - это массив, который требуется преобразовать; при использовании spread оператора исходный массив просто распыляется внутрь объекта, а при методе reduce происходит преобразование исходного массива, в результате которого его значение будут присвоены в объект, который в свою очередь передаётся вторым аргументом в reduce.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j190":{
    "theme":"j",
    "question":"Что такое каррирование?",
    "answer":"Каррирование - это процесс в функциональным программировании, в котором возможно преобразовать функцию с несколькими аргументами в набор вложенных функций с одним аргументом. Исходная функция возвращает новую функцию, которая ожидает следующий встроенный аргумент. Новая функция, ожидающая следующего аргумента, возвращается при каждом вызове карированной функции до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы благодаря механизму замыканий ждут того момента когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисление и возвращает результат. Преобразование функции позволяет легко получать частичные данные избегая многократных передач одной и той же переменной. Каррирование создаёт вложенные функции в соответствии с количеством аргументов функций, поэтому каждая функция получает аргумент и если аргумента нет каррирование не выполняется.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j191":{
    "theme":"j",
    "question":"Для чего используется свойство .dataset?",
    "answer":"Свойство dataset позволяет считывать или устанавливать любые data атрибуты на HTML элементы. data атрибут - это пользовательский атрибут на элементе, название которого начинается с префикса data, например data-test-id. Дата атрибуты используется, чтобы хранить значения на элементах в HTML. Использование таких атрибутов - это валидный и безопасный способ передачи пользовательских данных, но для того, чтобы получить значение данного атрибута, можно воспользоваться свойством dataset. Обращение к свойству dataset  возвращает объект со всеми data атрибутами, которые есть на элементе. Названиями полей или ключами в объекте будут имена дата атрибутов после префикса data, например, если атрибут называется data-episode, то в объекте поле этого атрибута будет называться episode, если data-id то просто id. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j192":{
    "theme":"j",
    "question":"Каким образом можно обмениваться кодом между файлами?",
    "answer":"Способ обмена зависит от среды выполнения JavaScript кода. На клиенте, то есть в браузере, пока переменные и функция объявлены в глобальной области видимости, все скрипты могут на них ссылаться - это первый вариант обмена, однако глобальные переменные - это плохая практика, поэтому такой подход лучше не использовать. В качестве альтернативы можно применять AMD через requare.js для модульного подхода. На сервере, то есть, например, на node.js обычно используется подход commonJS. При данном подходе каждый файл считается модулем, и он может экспортировать переменные и функции, добавляя их к объекту module.exports. Также, с версией Ecmascript 2015 появилась возможность использовать модульный синтаксис, который был призван заменить как AMD, так и commonJS. В конечном итоге использование import и export уже активно применяется  как в браузере так и в Node.JS. ",
    "codeexample":"",
    "images":["https://www.11meigui.com/wp-content/uploads/2023/05/image-1685417132225.png"],
    "checked":""
  },
  "j193":{
    "theme":"j",
    "question":"Как работает «сборщик мусора» в JavaScript?",
    "answer":"Основной алгоритм сборки мусора называется “алгоритм пометок” или Mark and Sweep. Согласно этому алгоритму сборщик мусора регулярно выполняет следующие шаги: он помечает и запоминает все корневые объекты, затем идёт по ним и помечает все ссылки из них, далее он идёт по помеченным объектам и отмечает их ссылки, все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды и так далее, пока не будут посещены все достижимые из корней ссылки, все не помеченные объекты в итоге удаляются. ",
    "codeexample":"",
    "images":["https://i0.wp.com/softnshare.com/wp-content/uploads/2019/08/2441328_a732_2.jpg?w=480&ssl=1"],
    "checked":""
  },
  "j194":{
    "theme":"j",
    "question":"Что такое утечки памяти?",
    "answer":"Утечки памяти можно определить, как фрагменты памяти, которые больше не нужны приложению, однако, по какой-то причине невозвращённые операционной системе или в пул свободной памяти. Языки программирования используют различные способы управления памятью. Одни языки предоставляют разработчику вспомогательные средства для управления памятью, другие ожидают от программиста явных указаний касательно используемых и неиспользуемых участков памяти. Если говорить о JavaScript, то это автоматический сборщик мусора алгоритмом mark and sweep. Однако проблема точного определения того, используется ли на самом деле некий участок памяти или нет, не разрешима, другими словами, только разработчик знает, можно или нет вернуть операционной системе некую область памяти.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j195":{
    "theme":"j",
    "question":"Назовите основные типы утечек памяти в JavaScript?",
    "answer":"В JavaScript есть четыре основные причины утечек памяти: 1. Глобальные переменные. Помимо того, что использование глобальных переменных является плохой практикой, так они ещё являются одной из причин утечек памяти. Даже если говорить о вполне безобидных переменных, созданных осознанно, во многих программах их слишком много. Они по определению не подвергаются сборке мусора, а следовательно засоряют память не нужными данными. Для того, чтобы избежать подобных ошибок, можно добавить оператор Use strict или, если проще, использовать строгий режим. 2. Таймеры или забытые коллбеки. В JavaScript программах использование функции setInterval обычное явление. Таймеры, а также весь относящийся к ним код не подвергаются сборке мусора. Поэтому каждый таймер возвращает свой идентификатор, используя который, данный таймер можно остановить вручную, и когда пишешь код, об этой возможности не нужно забывать. 3. Замыкание - это внутренняя функция, у которой есть доступ к переменным, объявленным во внешней по отношению к ней функции. Таким образом JavaScript сохраняет в памяти все",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j196":{
    "theme":"j",
    "question":"Разница между Rest и Spread операторами?",
    "answer":"Несмотря на то, что синтаксис Rest и Spread одинаков, задачи которые они выполняют, противоположные. Spread оператор используется для разделения коллекций на отдельные элементы. С помощью Spread  удобно производить “распыление”, например, когда в массив или объект можно добавлять новое значение их других массивов или объектов , причем эти значения не обязательно перечислять полностью. Достаточно взять распыляемую структуру и поставить … Так же он используется при копировании объектов или массивов. Rest предназначен для соединения отдельных значений в массив. Позволяет группировать массив определенные данные. Например, собрать остаточные аргументы передаваемые в функцию.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j197":{
    "theme":"j",
    "question":"Что такое деструктуризация?",
    "answer":"Деструктуризация или деструктурирующее присваивание это выражение доступно со стандарта ES6, которая предоставляет удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные. Оно призвано минимизировать написанный код, а так же сделать его более понятным несмотря на объем.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j198":{
    "theme":"j",
    "question":"Что такое статический метод класса (static)? Как осуществляется его вызов?",
    "answer":"Свойства и методы являются статическими, если они не привязаны к конкретному экземпляру класса и имеют одинаковое значение вне зависимости от того какой экземпляр ссылается на них. Статические свойства обычно определяются конфигурационными переменными, а статические методы являются чисто служебными функциями, которые не зависят от состояния экземпляра и часто используются для создания вспомогательных функций приложения. Данные свойства и методы внутри класса обозначаются специальным словом static . Также статичные методы функции принадлежат объекту класса, но недоступны другим объектам того же класса, а это значит, что если создать экземпляр класса, то к статичным методам обратиться не получится. Для того, чтобы их вызвать внутри другого статичного метода используется ключевое слово this. В нестатичном методе используется, либо имя класса.ю либо их вызов происходит через конструктор.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j199":{
    "theme":"jib",
    "question":"Что такое DOM?",
    "answer":"DOM - это объектная модель документа, которую браузер создает в памяти компьютера на основании html-кода, полученного им от сервера. DOM имеет древовидную структуру, поэтому его еще называют DOM-дерево",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j200":{
    "theme":"jib",
    "question":"Что такое распространение события (Event Propagation)?",
    "answer":"Это механизм, который отрабатывает, когда какое-либо событие происходит в документе. Событие распространяется от объекта window до вызывающего его элемента, при этом событие последовательно затрагивает всех предков целевого элемента. Есть три фазы распространения событий: Capturing(фаза захвата - событие начинается от корня документа и проходит по DOM-дереву до целевого элемента), target(событие достигает целевого элемента - обычно его называют event target), bubbling(всплытие - заключительная фаза: событие возвращается обратно до window параллельно вызывая все события на родительских элементах)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j201":{
    "theme":"jib",
    "question":"Что такое делегирование событий (Event Delegation)?",
    "answer":"Это прием разработки, когда вместо того, чтобы вешать много однотипных обработчиков на все элементы, можно добавить один обработчик на общего предка (например, не вешать обработчики на каждую ячейку таблицы, а добавить обработчик на саму таблицу (тег table) и с помощью event.target  отслеживать элемент, на который произошел клик)",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j202":{
    "theme":"jib",
    "question":"Разница между e.preventDefault() и e.stopPropagation()?",
    "answer":"Метод preventDefault()отключает поведение элемента по умолчанию. Например, если его использовать на ссылке и вызвать при клике, то мы отменим переход, а если на форме, то мы отменим ее отправку при клике на submit. Метод stopPropagation() отключает распространение событие события - т есть всплытие или погружение. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j203":{
    "theme":"jib",
    "question":"Методы поиска элементов в DOM?",
    "answer":"document.getElementById(‘id’); document.getElementsByName(‘name’); (редко используется); document.getElementsByTagName(‘div’); document.getElementsByClassName(‘class’); document.querySelector(‘nav + p’); (вернет только первый найденный элемент); document.querySelectorAll(‘nav > ul > li’); (вернет все найденные элементы);",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j204":{
    "theme":"jib",
    "question":"Разница между event.target и event.currentTarget?",
    "answer":"event.target - это элемент, в котором происходят события, или который вызывает событие. А event.currentTarget - это непосредственно элемент, к которому прикреплен прослушиватель события. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j205":{
    "theme":"jib",
    "question":"Разница между .stopPropagation() и .stopImmediatePropagation()?",
    "answer":"При наступления события в браузере происходит всплытие - в результате обработчики вызываются на самом элементе, а затем на всех родителях. Остановить такое поведение всплытия можно добавив .stopPropagation() или .stopImmediatePropagation()При этом .stopPropagation() отменяет всплытие, но на текущем обработчике событие срабатывает. А .stopImmediatePropagation()не только остановит всплытие, но и остановит обработку событий на текущем элементе.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j206":{
    "theme":"jib",
    "question":"Разница между событиями load и DOMContentLoaded?",
    "answer":"Оба события срабатывают при загрузке веб-страницы в браузере. Но DOMContentLoaded отрабатывает, когда браузер полностью загрузил html и DOM-дерево было построено, однако внешние ресурсы (стили, картинки, шрифты) еще не прогружены. А load срабатывает, когда загружен и html и все внешние ресурсы. Таким образом DOMContentLoaded всегда срабатывает раньше чем load. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j207":{
    "theme":"jib",
    "question":"Разница между attribute и property у DOM-элементов?",
    "answer":"Аttribute - это статичное значение определенного DOM-элемента, которая не изменяема и может быть добавлена в HTML разметку. Property - это вычисленное значение DOM-элемента, оно может динамически изменяться.Например, в поле input есть атрибут value, значение этого атрибута можно получить с помощью getAttribute() или свойства value. При первом рендеринге эти значения будут одинаковыми, но если пользователь введет какие-либо данные в input, то при повторном обращении за новыми значениями динамически поменяются только value.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j208":{
    "theme":"jib",
    "question":"Разница между HTMLCollection и NodeList?",
    "answer":"HTMLCollection - это динамическия HTML коллекция, которая представляет собой массивоподобной итерируемой объект дочерних элементов. NodeList - это статический список node или узлов, в которые входят все найденные в документе элементы. Например, getElementsByClassName() возвращает HTMLCollection, querySelectorAll() возвращает NodeList. Отличие между ними,в том, что если разметку динамически будет добавлен еще один элемент, то обновленные данные будут присутствовать только в HTMLCollection, так как HTMLCollection - это динамическая структура данных, а NodeList - статическая.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j209":{
    "theme":"jib",
    "question":"Как динамически добавить элемент на HTML-страницу?",
    "answer":"Создание новых элементов осуществляются с помощью метода .createElement(), внутрь которого передается тег создаваемого элемента. С помощью методов .classList.add() на созданный элемент можно навесить класс, а используя .createTextNode() можно создать текстовую ноду, которую в последующем с помощью .appendChild можно поместить внутрь созданного элемента, после того как элемент полностью готов с помощью .appendChild() он помещается в основную разметку DOM-дерева.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j210":{
    "theme":"jib",
    "question":"Типы узлов DOM-дерева?",
    "answer":"Спецификация браузерного JavaScript насчитывает 12 типов узлов. На практике чаще всего применяются четыре: document - входная точка в DOM-дерево; elementNode (узлы элементы) по сути это узлы обычных HTML-тэгов, из которых состоит страница; textNode (текстовые узлы) содержат текст; commentNode (узлы комментарии). Любой комментарий на HTML-странице становится отдельным типом узла. Каждому из типов узлов соответствует свое цифровое значение от 1 до 12. Для проверки к какому типу относится узел используется  свойство nodeType, которая возвращает числовое значение.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j211":{
    "theme":"jib",
    "question":"Свойства для перемещения по DOM-дереву?",
    "answer":"Существует 12 основных свойств, которые позволяют перемещаться по DOM-дереву от найденного элемента. Они делятся на две большие группы. Для всех типов узлов: childNodes - возвращает коллекцию дочерних элементов; firstChild и lastChild - обеспечивают доступ к первому и последнему дочернему элементу соответственно; previousSibling и nextSibling - свойства для возврата соседей, первое возвращает предыдущий узел, второе - следующий узел. Всё это происходит в границах одного элемента, то есть общего родителя; для того, чтобы получить родительский узел существует свойство parentNode. Данные 6 методов возвращают любой тип узла - это может быть текст или комментарий. Для передвижения только по узловым элементам существует еще 6 методов: parentElement; children; firstElementChild; lastElementChild; previousElementSibling; nextElementSibling. По сути это копии первых 6, однако, они возвращают только Node элементы.",
    "codeexample":"",
    "images":["https://learn.javascript.ru/article/traversing-dom/dom-links@2x.png","https://learn.javascript.ru/article/traversing-dom/dom-links-elements@2x.png"],
    "checked":""
  },
  "j212":{
    "theme":"jib",
    "question":"Виды событий в JavaScript?",
    "answer":"Список часто используемых DOM-событий: События мыши: mousedown, mouseup - события нажатия/отпускания кнопки мыши; click - включают оба описанные ранее события; dblclick - двойное нажатие; mousemove - это событие перемещения курсора; mouseover - срабатывает при вхождении курсора мыши в область принадлежащей целевому элементу и другим элементам вложенным в него; 2. Клавиатурные события: keydown и keyup - когда пользователь нажимает/отпускает клавиатуру; keypress - событие происходит когда пользователь нажал клавишу на клавиатуре над элементом. 3. События формы: submit - подтверждение отправки формы; focus и blur - фокусировка и расфокусировка определенного поля формы; change - срабатывает при изменении данных внутри input поля или textarea; reset - событие происходит перед очисткой формы. 4. События перетаскивания: dragstart и dragend - срабатывает когда пользователь начал/закончил перетаскивание элемента; drag - вызывается непосредственно в момент перемещения элемента.",
    "codeexample":"",
    "images":["https://itchief.ru/assets/images/tickets/2015.06/javascript-events.png"],
    "checked":""
  },
  "j213":{
    "theme":"jib",
    "question":"Как добавить обработчик события на DOM-элемент?",
    "answer":"В браузерном JavaScript есть три основных способа добавления обработчика на элемент: встроенный обработчик событий в этом случае добавление происходит непосредственно в HTML разметке на элемент. Плюсом подхода является то, что элемент, на который требуется добавить событие, не нужно искать. Минус - на элементе может быть только один обработчик; свойства обработчика событий. В этом случае элемент нужно сначала найти в разметке, а затем свойство эквивалентное обработчику, например, onclick, onsubmit, onmousemove и т.д., присвоить вызываемую функцию. Минус - если на один элемент нужно повесить два обработчика , то такой способ не подойдет. О двух этих вариантах полезно знать и рассказывать при ответе на вопрос, но на практике в реальных проекта нужно использовать третий вариант. Добавления события через функцию addEventListener(). Порядок действия точной такой же как  во втором варианте.: сначала в разметке ищется элемент; на него используя addEventListener() добавляется обработчик в функцию двумя первыми аргументами передается название события без приставки “on” и callback, который будет вызван.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j214":{
    "theme":"jib",
    "question":"Как удалить обработчик события с DOM-элемента?",
    "answer":"Самый часто используемый подход, который применяется для добавления события на элемент это функция addEventListener(), и если такой вариант используется в коде, то для удаления с элемента обработчика, применяется функция которая по аналогии называется removeEventListener(). Её особенностью и плюсом является то, что как и addEventListener() в качестве двух первых аргументов она принимает те же самые данные, т.е. названия события и callback-функцию.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j215":{
    "theme":"jib",
    "question":"Сколько аргументов принимает addEventListener?",
    "answer":"Функция addEventListener, с помощью которой на элемент можно добавить обработчик события, принимает 3 аргумента - два обязательных и один опциональный. Имя событий без приставки “on”, например, click, dblclick. submit, reset и т.д. 2. Callback-функция, которая будет вызвана при срабатывании события. 3. Является опциональным и может быть либо объектом, либо булевым значением. Если это объект он принимает 3 основных свойства: once со значениями true или false, при определения значения как true обработчик будет автоматически удален после выполнения, т.е. callback-функцию можно вызвать только один раз; capture - также определяется через булевое значение, данное свойство определяет на какой фазе должен сработать обработчик, если true - событие будет перехвачено на стадии погружения, а не всплытия. Поскольку это часто используемый параметр, то вместо определения объекта можно воспользоваться сокращенной формой записи и просто передать булевое значение;passive, если его значение определено как true, то обработчик никогда не вызовет preventDefault. Дополнительно существует mouse systemgroup, useCapture, wantsUntrustes, но это специфичные кейсы, которые используются очень редко.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j216":{
    "theme":"jib",
    "question":"Разница между innerHTML и outerHTML?",
    "answer":"Оба свойства предназначаются для возврата разметки HTML элемента. Свойство innerHTML содержит HTML-код, который находится внутри найденного элемента. При установке нового значения этого свойства внутренний HTML-код изменяется и рендерится браузером заново. Свойство outerHTML работает аналогично innerHTML. Разница заключается в том, что outerHTML  возвращает полный HTML-код найденного элемента.",
    "codeexample":"",
    "images":["https://img2023.cnblogs.com/blog/1232210/202309/1232210-20230920154304417-95251847.png"],
    "checked":""
  },
  "j217":{
    "theme":"jib",
    "question":"Расскажите про координаты в браузере?",
    "answer":"Чтобы перемещать и позиционировать элементы на экране в браузере имеется система координат. Оси координат начинаются в левом верхнем углу экрана и идут вправо для оси X и вниз для оси Y. Позиционирование с помощью координат может быть относительно окна браузера или относительно отдельного элемента. Всего существует две системы координат: одна начинается от угла HTML страницы, а вторая от угла окна браузера. С помощью первой можно определять, как элемент расположен относительно всей страницы, а с помощью второй, как элемент расположен относительно окна браузера и того, что там находится. Объекты, события мыши и тач события содержат координаты места на экране и в документе, где событие произошло page X page Y - для документа, client X и client Y - для экрана. Координатами элемента является расстояние в пикселях от осей системы координат до левого верхнего угла. С помощью метода элемента Get bounding line tracking можно получить подробные данные о координатах элемента и его размере.",
    "codeexample":"",
    "images":["https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99B75B405BFCB4E631"],
    "checked":""
  },
  "j218":{
    "theme":"jib",
    "question":"Разница между JSON и XML?",
    "answer":"JSON - это формат обмена данными, xml - это язык разметки, в котором можно задавать синтаксис, структуру, типы данных и их модель. JSON позволяет определять данные любого формата. В то время как в xml есть свои правила и ограничения, JSON более компактный, так как представляет из себя формат ключ-значение. xml - объёмный т.к. данные оборачиваются в разметку и за счёт этого нюанса парсинг данных в xml формате происходит медленнее, чем парсинг данных в JSON формате.Оба могут быть использованы для передачи данных и для работы с обоими стандартами используются различные фреймворки и библиотеки.",
    "codeexample":"",
    "images":["https://itchief.ru/assets/images/tickets/2015.12/json-vs-xml.png"],
    "checked":""
  },
  "j219":{
    "theme":"jib",
    "question":"Как узнать об использовании метода event.preventDefault()?",
    "answer":"У объекта события можно вызвать специальный метод preventDefault который отменит выполняемые по умолчанию действия. Например, если его добавить на кнопку submit, которая находится в форме, то при клике на эту кнопку форма перестанет отправляться. Однако, помимо вызова метода может понадобиться проверка, а был ли вызван данный метод у объекта события для такой проверки есть специальное свойство которое называется defaultPrevented, находится оно также внутри объекта события и возвращает булевое значение true, если метод preventDefault был вызван и false если данный метод на событии не вызывался.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j220":{
    "theme":"jib",
    "question":"Для чего используется свойство window.navigator?",
    "answer":"Если говорить просто, то свойство navigator возвращает объект описания приложения, которое выполняет скрипт. В подавляющем большинстве случаев данным приложением является браузер. Сам объект содержит свойства описывающее браузер и методы для выполнения действий. Из самого свойства можно получить немного полезной информации о настройках браузера у клиента, в частности, используя свойство userAgent, можно узнать, какой именно браузер использует пользователь. language возвращает предпочитаемый язык интерфейса в виде языкового тега, languages возвращает массив предпочитаемых языков в порядке предпочтительности, cookieEnabled возвращает true, если браузер пользователя поддерживает куки и они включены, в противном случае возвращается false.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j221":{
    "theme":"jib",
    "question":"Для чего используется метод .focus()?",
    "answer":"Вызов метода focus() на DOM элементе, устанавливает фокус на этот элемент. Когда элемент находится в фокусе он перехватывает и обрабатывает события клавиатуры. Важный нюанс заключается в том, что фокус нельзя установить на элемент, если тот заблокирован. Например, если у кнопки или поля ввода стоит атрибут disabled, то фокус на этот DOM элемент установлен не будет. Обычно метод focus() вызывается без аргументов, однако по умолчанию браузер прокручивает страницу до элемента, на который перемещён фокус. Если такое поведение не нужно, то в метод можно дополнительно передать объект со свойством preventScroll. Если preventScroll установлен в true, то прокрутки страницы к элементу не произойдёт, если preventScroll установлен false - это значение по умолчанию, браузер прокрутит страницу до сфокусированного элемента. ",
    "codeexample":"",
    "images":["https://cs1.htmlacademy.ru/blog/css/hover-focus-active/610234c7e9882140331ef0e609b982f3.gif"],
    "checked":""
  },
  "j222":{
    "theme":"jib",
    "question":"Для чего используется свойство .forms?",
    "answer":"forms - это поле или свойство объекта document. Оно хранит коллекцию всех элементов форм, которые есть на текущей открытой странице, данная коллекция доступна только для чтения. Если на странице форм нет, тогда возвращённый результат будет пустым, а длина коллекции равна нулю. В качестве примера можно взять страницу с тремя формами: форма для применения промокода, форма с полем для подписки на рассылку и форма авторизации с помощью номера телефона. При обращении к свойству forms мы получим живую коллекцию или HTML Collection которая очень напоминает массив, но также она позволяет обращаться к элементам по их имени или идентификатору. Формы, у которых указаны атрибуты ID или name, можно получить по значению этих атрибутов, в остальных случаях получить форму можно по индексу, который совпадает с порядком описания форм на странице. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j223":{
    "theme":"jib",
    "question":"Для чего используется метод .scrollIntoView()?",
    "answer":"Метод scrollIntoView() позволяет программно прокрутить окно до определённого элемента вне зависимости от положения элемента в окне. Следует отметить, что прокручивание осуществляется таким образом, чтобы элемент, на котором был вызван scrollIntoView() стал виден пользователю. scrollIntoView() может быть аргумент булевого типа если указать true, то скролл будет перемещён, чтобы верхняя граница элемента совпадала с верхней границей окна, если указать false то скролл остановится так, чтобы нижняя граница элемента была вровень с нижней границей окна. Дополнительно можно указать объект, который более точно определит механизм прокрутки. В нём можно определить свойства behavior, которые задают анимацию прокрутки и принимает значение auto или smooth - это главная прокрутка, block определяет вертикальное выравнивание, принимает start, center, and и nearest, и inline - определяет горизонтальное выравнивание и также принимает аналогичное значение как и блок.",
    "codeexample":"",
    "images":["https://images.ctfassets.net/f20lfrunubsq/4NBY2S6nAuUO5JoccinT96/16f63ca6c9bd316e71719a0724f12a6f/Screenshot_2020-08-09_at_14.33.29.png"],
    "checked":""
  },
  "j224":{
    "theme":"asyncjs",
    "question":"Разница между синхронными и асинхронными функциями?",
    "answer":"Синхронные функции являются блокирующими - все дальнейшие операции блокируются, пока не будет выполнена данная функция. Асинхронные функции не блокируют дальнейшее выполнение скрипта. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j225":{
    "theme":"asyncjs",
    "question":"Что такое AJAX?",
    "answer":"AJAX (Asynchronous JavaScript and XML) - термин, который описывает подход использования нескольких существующих технологий вместе для работы на стороне клиента и для создания асинхронных web-приложений. С помощью AJAX  web-приложения могут отправлять данные на сервер и получать их с сервера асинхронно, таким образом происходит отделение логики представления (отрисовки UI) от логики обмена данными. В результате страницы могут динамически изменять содержимое без полной перезагрузки, поэтому они работают быстрее  и становятся более отзывчивыми к действиям пользователя. На практике для получения или передачи данных используют формат данных JSON вместо XML, из-за того, что JSON основан на JavaScript, а для работы с асинхронными запросами используют новый метод fetch вместо устаревшего XMLHttpRequest.",
    "codeexample":"",
    "images":["https://simplystatic.com/wp-content/uploads/2022/11/AJAX-how-works.png.webp"],
    "checked":""
  },
  "j226":{
    "theme":"asyncjs",
    "question":"Что такое same-origin policy в контексте JavaScript?",
    "answer":"Same-origin policy или принцип одинакового источника определяет как документ или скрипт, загруженный из одного источника, может взаимодействовать с ресурсом из другого источника.  Этот принцип не позволяет JavaScript выполнять запросы за границей домена. Источник определяется как комбинация схемы uri имени хоста и номера порта. Это помогает изолировать потенциально вредоносные документы и не дает вредоносному сценарию на одной странице  получить доступ к конфиденциальным данным на другой. Для того, чтобы разрешить запросы такие кроссдоменные запросы используются corse.",
    "codeexample":"",
    "images":["https://habrastorage.org/r/w1560/getpro/habr/post_images/040/1e1/45c/0401e145c764718ca2276853ec9cbf9c.png"],
    "checked":""
  },
  "j227":{
    "theme":"asyncjs",
    "question":"Что такое цикл событий (event loop) и как он работает?",
    "answer":"JavaScript является однопоточным, другими словами движок JavaScript  в одну единицу времени может выполнять только одну операцию. Для такого потока выделяется область памяти, которая называется Stack. В Stack хранятся frame - это локальные переменные и аргументы вызываемых функций. Список событий, которые должны обрабатываться формируют очередь событий. Когда Stack освобождается движок может обработать любое событие из этой очереди. Координирование этого процесса происходит в event loop, по сути это бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая движок браузера ждет когда поступит  новое событие, если не пустая, то первое событие из очереди извлекается и обработчик начинает его выполнять и так до бесконечности.",
    "codeexample":"",
    "images":["https://habrastorage.org/webt/h2/-x/aj/h2-xajggqa9vcloczh7owhqiffc.png"],
    "checked":""
  },
  "j228":{
    "theme":"asyncjs",
    "question":"Что такое CORS?",
    "answer":"В целях безопасности браузеры ограничивают кроссдоменные запросы, которые создаются скриптами, то есть XMLHttpRequest и fetch следуют политике одного источника или same-origin policy. Это значит что веб-приложения, которые используют такие API  могут запрашивать ресурсы только с того домена, с которого они были загружены. CORS (Cross-origin resource sharing) - это механизм, который использует дополнительные Http заголовки, чтобы дать возможность браузеру пользователя получать разрешение на доступ к  выбранным ресурсам сервера или домена, которые отличаются от того, что сайт использует в данный момент.",
    "codeexample":"",
    "images":["https://habrastorage.org/r/w1560/getpro/habr/post_images/040/1e1/45c/0401e145c764718ca2276853ec9cbf9c.png"],
    "checked":""
  },
  "j229":{
    "theme":"asyncjs",
    "question":"Что такое промисы (Promises)?",
    "answer":"Промисы - это один из приемов работы с асинхронным кодом в JS. Промис - это объект, который может вернуть одно значение в будущем, либо выполненное значение, либо причина, по которой промис не был выполнен, т.е. ошибку. \nПромис может находиться в одном из трех возможных состояний: \n1.выполнено (fulfilled); \n2.отклонено (rejected); \n3.ожидает выполнения (pending). \nПри использовании промисов можно добавлять callback-функции для обработки выполненного значения или причиной отказа. Для такого взаимодействия используются chaining или цепочка вызовов с методами .then() и .catch()",
    "codeexample":"",
    "images":["https://cdn.hashnode.com/res/hashnode/image/upload/v1677409815862/3588ce49-a480-46fe-a229-9dafafa4c61d.png?w=1600&h=840&fit=crop&crop=entropy&auto=compress,format&format=webp"],
    "checked":""
  },
  "j230":{
    "theme":"asyncjs",
    "question":"Плюсы и минусы использовании Ajax?",
    "answer":"К плюсам можно отнести следующее:\n -повышение интерактивности - новые данные сервера могут быть добавлены динамически без перезагрузки всей страницы;\n -сокращение количества обращений к серверу - скрипты и таблицы стилей нужно запрашивать только один раз;\n -хранение состояния страницы - переменная JS и состояние DOM сохраняется, поскольку основная страница контейнера не перезагружается.\nМинусы:\n -проблемная реализация добавление динамической веб-страницы в закладке, так как данные добавляются динамически любые операции нужно хранить, например, в URL-адресе, чтобы при повторном открытии не начинать все с нуля.\n -Ajax не работает если в браузере отключен javascript;\n -некоторые поисковые роботы не выполняют javascript и не видят данные, загружающиеся при помощи javascript.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j231":{
    "theme":"asyncjs",
    "question":"Подходы при работе с асинхронным кодом?",
    "answer":"Асинхронные код или асинхронные функции - это функции, которые не блокируют основной поток исполнения. Из-за такой особенности, если между функциями имеется зависимость, их нужно обрабатывать последовательно. Для этого можно воспользоваться следующими подходами:\n1.Callback - механизм достаточно прост. Внутри одной асинхронной функции записывается другая и так далее, до тех пор пока не получится многоуровневая вложенность. Стоит отметить, что данный механизм немного устарел и от него стараются отказываться из-за его Callback Hell, то есть из-за очень большой вложенности;\n2.Использование Promise. В данном случае асинхронная функция возвращает специальный объект, которая называется Promise, используя его, а также специальные методы then и catch можно обрабатывать получаемые данные и передавать их дальше по цепочке;\n3.Конструкция Async/Await . Для общей функции добавляется ключевое слово async(), а внутри каждая асинхронная операция помещается как await, таким образом исполнение асинхронного кода идет  наподобие синхронного.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j232":{
    "theme":"asyncjs",
    "question":"Преимущества использовании промисов вместо колбэков?",
    "answer":"1.Помогает избежать Callback Hell, который может быть нечитаемым;\n2.Упрощает написание последовательного, читаемого, асинхронного кода с помощью then, а также обработку ошибок с помощью catch;\n3.Упрощает написание параллельного асинхронного кода с помощью Promise All;\n4.С использованием промисов можно избежать следующих проблем, которые возникают при использовании коллбэк-функции:\n-коллбэк-функция была вызвана слишком рано или поздно, либо слишком мало или много раз;\n-пропуск ошибок или исключений;\n-не удалось передать необходимую среду или параметр.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j233":{
    "theme":"asyncjs",
    "question":"Что такое коллбэк-функция (Callback)? Что такое Callback Hell?",
    "answer":"Колбэк-функция или функция обратного вызова - это передача исполняемого кода в качестве одного из параметров в другой код. Другими словами - это передача одной функции в виде параметра в другую. Такой обратный вызов позволяет функции исполнять код, который задаётся в аргументах при её вызове. Колбек функции очень распространены и могут использоваться функциях высшего порядка таких как map, filter, reduce и так далее, в таймерах, в асинхронных функциях чтобы гарантировать правильный порядок вызовов, а также в браузерном javascript. Например, при добавлении события в случае использования функции обратного вызова в асинхронных функциях  может получиться случай так называемого callback Hell - это такая вложенность колбеков при которой получается несколько уровней, то есть первая функция вызывает вторую, вторая третью, третья четвёртую и так далее. В результате получается плохо читаемый код который трудно поддерживать. ",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j234":{
    "theme":"asyncjs",
    "question":"Что такое async/await?",
    "answer":"async/await - это новый способ написания асинхронного или не блокирующего кода в JavaScript. Он построен на основе промисов, и это делает написание асинхронного кода более читаемым и чистым, чем  промисы и функции обратного вызова или колбеки. async/await заставляет код, который работает асинхронно выглядеть как синхронный код. Это именно то, ради чего его используют. Ключевое слово async перед объявлением функции заставляет функцию неявно возвращать промис. Ключевое слово await можно использовать только внутри асинхронной функции, использование ключевого слова await в любой другой функции, которая не является синхронной, вызовет ошибку. Ключевое слово await ожидает возврата выражения из правой части, предположительно промис, перед выполнением следующей строки кода. Таким образом асинхронный код выполняется последовательно. Особенно это полезно, если один запрос зависит от результата другого. Используется async/await чаще с конструкцией try/catch, которая позволяет отлавливать ошибки в асинхронных запросах.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j235":{
    "theme":"asyncjs",
    "question":"Разница между Promise.all(), Promise.any() и Promise.race()?",
    "answer":"Все три метода предназначены для работы с промисами и в качестве аргумента они принимают массив промисов. Promise.all() - это промис, принимающий массив других промисов, в качестве аргумента и возвращающий результат выполнения промисов или ошибку при отклонении одного из них. Основное отличие - все промисы должны резолвнуться, тогда будет получен результат. Promise.race() возвращает результат первого выполненного или отклонённого промиса из переданных ему в виде массива промисов, то есть результат возвращается из первого резолвнутого или реджектнутого промиса.  Promise.any() - это комбинация двух ранее описанных вариантов. Вернёт результат первого резолвнутого промиса То есть отработает как race, но reject вернётся  только в том случае если упадут все переданные промисы.",
    "codeexample":"",
    "images":["https://daynhauhoc.s3.dualstack.ap-southeast-1.amazonaws.com/original/3X/5/5/5551b1f90818c86387e4457db2ad8179d6289721.png"],
    "checked":""
  },
  "j236":{
    "theme":"asyncjs",
    "question":"Расскажите про статический метод .allSettled()?",
    "answer":"Метод .allSettled() - это один из статических методов объекта promise, его используют, когда нужно запустить несколько промисов параллельно и дождаться их выполнения. Promise.allSettled() очень похож на Promise.all(), но работает немного по-другому. В отличие Promise.all(), Promise.allSettled() ждет выполнения всех промисов, при этом неважно, завершились они успешно или с ошибкой, следует помнить, что в случае с Promise.all() resolve возвращается только если все параллельные промисы завершились успешно, reject - если хоть один из промисов упал. ",
    "codeexample":"",
    "images":["https://webformyself.com/wp-content/uploads/2021/64/1.png"],
    "checked":""
  },
  "j237":{
    "theme":"webh",
    "question":"Что такое прогрессивный SSR?",
    "answer":"Прогрессивный рендеринг на стороне сервера или progressive server side rendering основан на концепции потоковой передачи HTML, он разбивает страницы на осмысленные самостоятельные компоненты с помощью разделения кода. Эти части страницы управляются разными скриптами, в результате появляется возможность сделать гидрацию независимо. Основными этапами прогрессивного рендеринга можно назвать следующие: браузер запрашивает у сервера html-код, сервер делает API запросы и сначала рендерит критический контент, а затем отправляет его клиенту, браузер анализирует HTML и отображает его на экране, сервер рендерит не критический контент и передаёт его браузеру, браузер анализирует и отображает не критичный контент, параллельно JS бандлы загружаются и выполняются в фоновом режиме, а браузер передаёт интерактивность элементам DOM. Прогрессивный рендеринг повышает производительность WEB приложения извлекая или визуализируя компоненты страницы параллельно.",
    "codeexample":"",
    "images":["https://miro.medium.com/v2/resize:fit:1400/1*i5WWiWt3t3rAS7hgxRTuBQ.png"],
    "checked":""
  },
  "j238":{
    "theme":"webh",
    "question":"Что такое Progressive Web Application (PWA)?",
    "answer":"Progressive Web Application (PWA) или прогрессивное веб приложение - это веб-сайты, которые ведут себя подобно нативным приложениям. Они могут быть установлены на телефон или компьютер, а также, как правило, работают в оффлайн. Для последнего используется сервис worker и интерфейс кеширование. Преимуществом PWA перед мобильными приложениями является их размер и относительная лёгкость разработки, не нужно тратить ресурсы на создание двух версий приложений, то есть Web и мобильной, для одного сайта, при этом сохраняется хороший пользовательский опыт.",
    "codeexample":"",
    "images":["https://miro.medium.com/v2/resize:fit:1100/format:webp/1*UPn7pTCi81P6cMmh6EEXUQ.jpeg"],
    "checked":""
  },
  "j239":{
    "theme":"webh",
    "question":"Что такое поток документа?",
    "answer":"Поток - это одно из важнейших базовых понятий в вёрстке. Это принцип организации элементов на странице при отсутствии стилей, т.е., если создать html-страницу и не стилизовать её с помощью CSS, то отображение в браузере будет предсказуемо. Благодаря тому, что мы точно знаем, как браузер располагает элементы в потоке, даже если к странице не подключено никаких стилей, каждому элементу всё равно будут применяться CSS правила, зашитые в движке браузера. Благодаря этим правилам заголовок h1 крупнее заголовка h2, а ссылки синие и подчеркнутые. Это дефолтные браузерные стили, на основании этих правил условно все элементы на странице можно разделить на две категории: блочные и строчные. Например, <div> будет блочным, а <span> и <strong> -  срочными, поменять стандартное поведение можно при помощи CSS свойства display. Если вообще не применять никаких стилей, браузер формирует из элементов нормальный поток также в CSS есть свойства которые вырывают элемент из нормального потока документа, к таким свойствам можно отнести float и position.",
    "codeexample":"",
    "images":["https://htmlacademy.ru/assets/courses/65/flow2.png"],
    "checked":""
  },
  "j240":{
    "theme":"webh",
    "question":"Что такое Веб-компоненты и какие технологии в них используются?",
    "answer":"Веб-компоненты это технология, которая позволяет создавать многократно используемые компоненты в веб-документах и приложениях. Они поддерживаются браузерами напрямую и не требуют дополнительных библиотек для работы. Веб-компоненты включают четыре технологии, каждая из которых может использоваться отдельно от других:\n1.customEvent() - IP для создания собственных HTML элементов;\n2.HTML <template> тэг позволяет реализовать изолированные DOM-элементы;\n3.shadowDOM изолирует DOM и стили в разных элементах;\n4.HTML import или импорт HTML-документа.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j241":{
    "theme":"webh",
    "question":"Особенности разработки мультиязычных сайтов?",
    "answer":"Рассмотрим основные особенности: \n- использование lang-атрибута на HTML-страницах, причем зачастую это значение может изменяться динамически;\n- автоматическое перенаправление пользователя на нужную версию сайта, проверяя установленный его язык. В крайнем случае можно сделать небольшой компонент для выбора страны и языка;\n- следует учитывать разные направления чтения (слева-направо, сверху-вниз, справа-налево). Большинство кейсов может быть решено с помощью css свойств и специальных библиотек;\n- форматирование даты и валюты - для решения данных нюансов так же есть большое количество js-библиотек;\n- использование ограничения длинных слов и предложений, речь идет об обрезке текста или слов и выставления многоточия, либо дополнительных кнопок для чтения полного описания;\n- нужно стараться не склеивать результирующие строки, так как грамматическое расположение слов в разных языках может быть разное, вместо этого можно использовать шаблон для разных языков и динамически вставлять их значения.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j242":{
    "theme":"webh",
    "question":"Что такое Flash Of Unstyled Content (FOUC)? Как его избежать?",
    "answer":"Flash Of Unstyled Content (FOUC) (вспышка нестилизированного контента) или появление неоформленного контента при загрузке. Например, при первом появлении страницы текст отображается одним шрифтом, а после подгрузки нужного шрифта происходит его изменение.\nИзбежать такое поведение можно следующим путем:\n-путем вставки критичного css в head-странице. Критичный css - это минимальный набор блокирующего css, требуемого для рендеринга первого экрана с контентом, по сути это часть сайта, которую в первую очередь видит пользователь.\n-показ preloader до полной загрузки.",
    "codeexample":"",
    "images":["https://media.dev.to/cdn-cgi/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fi%2Fyftc0s00303flkhl96nf.jpg"],
    "checked":""
  },
  "j243":{
    "theme":"webh",
    "question":"Что такое History API в браузере?",
    "answer":"History API даёт доступ к управлению истории браузера в рамках текущей сессии. Браузер создаёт новую сессию, когда пользователь открывает новую вкладку или новое окно браузера. С помощью history API можно переходить по истории вперёд, назад и управлять содержимым истории. Доступ к API осуществляется с помощью объекта window.history. Основные методы - это back - перемещает пользователя по истории на странице назад, forward - перемещает пользователя по истории на страницу вперёд, go - универсальный метод для перемещения по истории вперёд или назад, pushState добавляет новую запись в истории сессии, replaceState изменяет текущую запись в истории сессии. ",
    "codeexample":"",
    "images":["https://s1.o7planning.com/web-rs/web-image/vi/arf-1147821-vi.webp"],
    "checked":""
  },
  "j244":{
    "theme":"webh",
    "question":"Что такое веб-хранилище (web storage)?",
    "answer":"web storage или web-хранилище - это интерфейс, позволяющий хранить данные в виде пары ключ-значение локально, то есть в браузере пользователя причём делать это более удобным способом, чем при использовании куки. Веб-хранилище представляет два основных механизма хранения данных - это локальное хранилище или LocalStorage - предназначено для хранения данных текущего пользователя неограниченное количество времени и сессионное хранилище или SessionStorage - служит для хранения данных на протяжении текущей сессии, то есть при закрытии вкладки браузера данные будут потеряны.",
    "codeexample":"",
    "images":["https://i0.wp.com/pediaa.com/wp-content/uploads/2019/07/Difference-Between-localStorage-and-sessionStorage-Comparison-Summary-new.jpg?resize=768%2C622&ssl=1"],
    "checked":""
  },
  "j245":{
    "theme":"webh",
    "question":"Что такое BOM?",
    "answer":"BOM Browser Object Model или объектная модель браузера - это модель, которая позволяет JavaScript взаимодействовать с браузером. Данная модель включает в себя такие объекты как navigator, location, history, screen, xml, http request и так далее, другими словами BOM - это дополнительные объекты предоставляемые браузером чтобы работать со всем кроме документов. Также следует обратить внимание, что BOM не стандартизирована, поэтому её реализация может отличаться в разных браузерах.",
    "codeexample":"",
    "images":["https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwiZEE%2FbtqygCNpnQT%2FRl42UKxwUFESx3KWmkzJq1%2Fimg.png"],
    "checked":""
  },
  "j246":{
    "theme":"webh",
    "question":"Разница между cookie, sessionStorage и localStorage?",
    "answer":"Все три технологии используется для хранения данных на клиенте. Сами данные хранятся в виде ключ-значение в формате строки. \nКритерии сравнения:\n 1.Инициатор:\n для всех инициатор - клиент, для cookie дополнительно может быть и сервер через заголовок Set-Cookie.\n 2.Длительность хранения:\nдля cookie установка идет вручную: может быть 1 час, может быть 1 месяц; для sessionStorage пока открыта вкладка браузера данные будут доступны; localStorage хранит информацию практически неограниченное время, пока хранилище не будет очищено клиентом самостоятельно.\n 3.Связь с доменом есть только у cookie.\n 4.Емкость для cookie 4 Kb, для sessionStorage и localStorage по 5 Mb.\n 5.Место откуда данные могут быть доступны:\n 6.Информация из cookie и localStorage  доступна из любого окна в браузере, из sessionStorage только для открытой вкладки.",
    "codeexample":"",
    "images":["https://osipenkov.ru/wp-content/uploads/2020/07/session-local-storage-1.jpg"],
    "checked":""
  },
  "j247":{
    "theme":"webh",
    "question":"Способы уменьшения времени загрузки веб-страницы?",
    "answer":"1.Минификация и конкатенация css и js файлов.\n2.Оптимизация или сжатие изображений. Для изображений иконок можно применять иконочные шрифты или создать css sprite.\n3.Использование CDN.Такие сети состоят из серверов в разлиных точках мира. При подключении сайта к сети пользователю отдают данные с ближайшего к нему сервера, что в итоге увеличивает скорость загрузки.\n4.Использование jsp метода компрессии. Данный способ сжатия подключается на сервере буквально в пару строк.\n5.Использование кэширования.",
    "codeexample":"",
    "images":[],
    "checked":""
  },
  "j248":{
    "theme":"webh",
    "question":"Что такое HTTP?",
    "answer":"HTTP(Hypertext Transfer Protocol)- это прикладной протокол для передачи гипертекстовых документов по типу HTML. В настоящее время используется для передачи произвольных данных. Создан он для связи между web-браузерами и web-серверами. HTTP протокол без сохранения состояния, то есть сервер не сохраняет никаких данных между парами запрос-ответ, а также он следует классической клиент-серверной модели, когда клиент открывает соединение для создания запроса,а затем ждет ответа. Все программное обеспечение для работы протокола разделяется на три категории:\n1.Клиент или потребитель услуг;\n2.Сервер или поставщик услуг.\n3.Прокси или посредник,используется для выполнения транспортных услуг. ",
    "codeexample":"",
    "images":["https://img.webnots.com/2013/06/HTTP-Request-and-Response-Over-Web-1.png"],
    "checked":""
  },
  "j249":{
    "theme":"webh",
    "question":"Из чего состоит HTTP-запрос?",
    "answer":"HTTP-запрос содержить следующие элементы:\n1.HTTP-метод: get, post, put, delete и т.д. Метод помогает определить какой тип операции хочет выполнить пользователь.\nget - получение данных\npost - отправка\ndelete - удаление \nput - обновление данных\n2.Путь к ресурсу\n3.Версия HTTP протокола\n4.В дополнение могут идти различные заголовки, которые отправляют дополнительную информацию на сервер. Также в запросе может быть тело, которое содержит информацию, например, если используется запрос put , то в теле запроса могут быть указаны ключи и значения, которые должны быть обновлены.",
    "codeexample":"",
    "images":["https://www.algoassembly.com/wp-content/uploads/2023/12/http8.png"],
    "checked":""
  },
  "j250":{
    "theme":"webh",
    "question":"Какие методы может иметь HTTP-запрос?",
    "answer":"HTTP определяет множество видов запроса, которые указывают какое именно действие хочет произвести пользователь. Основных методов можно выделить 9, но на практике чаще используют первые 4.\n1. get запрос на получение данных. С использованием данного метода можно только извлекать данные;\n2. post используется для отправки данных на определенный ресурс, часто вызывает изменения состояния, т.е. добавление, либо какие-то побочные эффекты на сервере;\n3. delete запрос на удаление указанных данных;\n4. put заменяет все текущие представления ресурса данными запроса, используется для редактирования;\n5. head запрашивает ресурс аналогично get, но без тела ответа.\n6. connect устанавливает туннель к серверу или определенному ресурсу;\n7. trace выполняет вызов возвращаемого тестового сообщения с ресурса;\n8. patch используется для частичного изменения ресурса;\n9. options используется для описания параметров соединения с ресурсом.",
    "codeexample":"",
    "images":["https://avatars.mds.yandex.net/get-lpc/1527204/19bdfe55-7f57-41aa-8a15-7322b5f68475/width_480_q70"],
    "checked":""
  },
  "j251":{
    "theme":"webh",
    "question":"Что такое HTTP cookie? Для чего они используются?",
    "answer":"HTTP - это протокол без сохранения состояния, а это значит что каждая пара “запрос-ответ” не связана с предыдущим запросом и ответом. На реальных проектах это не очень удобно, так как иногда нужно запомнить аутентификацию пользователя или, например, хранить данные пользователя с товаром. Для хранения такой информацию используются HTTP cookie.HTTP cookie - это небольшой фрагмент данных отправляемых сервером на браузер пользователя, который тот может сохранить и отсылать обратно с запросом к данному серверу.\nКуки могут использоваться для:\n1.управления сеансом (логины, корзины для виртуальных покупок);\n2.мониторинга (отслеживания поведения пользователя);\n3.персонализации (пользовательские предпочтения).\nПолучив HTTP-запрос вместе с ответом сервер может отправить заголовок Set-Cookie. Cookie обычно запоминаются браузером и посылается значение заголовка в HTTP Cookie с каждым новым запросом к одному и тому же серверу. Для них можно создать срок действия, после которого они будут перезапрошены или не будут отправляться, а также можно указать ограничения на путь и домен.",
    "codeexample":"",
    "images":["https://www.wisecleaner.com/images/think-tank/292/cookie.png"],
    "checked":""
  },
  "j252":{
    "theme":"webh",
    "question":"Разница между HTTP и HTTPS?",
    "answer":"HTTP - это наиболее широко используемый протокол в интернете. Он является стандартом для запросов и ответов клиентов и серверов. Он используется для передачи гипертекста с сервера в локальный браузер.\nHTTPS - это канал HTTP, цель которого безопасность, другими словами, это безопасное версия HTTP, то есть к HTTP добавляется уровень SSL. SSL требуется для деталей шифрования.\nОсновной функцией протокола HTTPS можно разделить на два типа:\n1.установить информационный канал для обеспечения безопасности данных;\n2.подтвердить подлинность веб-сайта.\nHTTP запрос не зашифрован, HTTPS в свою очередь зашифрован. \nHTTP порт - 80, а HTTPS - 443.",
    "codeexample":"",
    "images":["https://directlinedev.com/media/page_photos/0002/photo_2892.wide.jpeg?_=1605526505"],
    "checked":""
  },
  "r25":{
    "theme":"r",
    "question":"Что такое React?",
    "answer":"React - это JavaScript библиотека с открытым исходным кодом, разработанная компанией Facebook. Он предназначен для создания пользовательских интерфейсов. React отвечает за слой представление, то есть vue, в мобильных и веб-приложениях. Основная философия - это компонентный подход, то есть весь интерфейс может быть разбит на минимальные функционирующие единицы -компоненты. Переиспользуя такие компоненты в других местах приложения можно в разы ускорить разработку.",
    "codeexample":"",
    "images":[],
    "checked":""
  }
}